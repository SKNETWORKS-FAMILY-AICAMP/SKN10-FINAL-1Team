2025-06-30 00:17:17,447 - INFO - PROMPT: 
Analyze the following codebase for the project 'SKN10-FINAL-1Team'.

Available files (total 51):
- 0 # README.md
- 1 # backend/accounts/__init__.py
- 2 # backend/accounts/admin.py
- 3 # backend/accounts/apps.py
- 4 # backend/accounts/migrations/0001_initial.py
- 5 # backend/accounts/migrations/__init__.py
- 6 # backend/accounts/models.py
- 7 # backend/accounts/serializers.py
- 8 # backend/accounts/urls.py
- 9 # backend/accounts/views.py
- 10 # backend/config/__init__.py
- 11 # backend/config/asgi.py
- 12 # backend/config/settings.py
- 13 # backend/config/urls.py
- 14 # backend/config/wsgi.py
- 15 # backend/conversations/__init__.py
- 16 # backend/conversations/admin.py
- 17 # backend/conversations/apps.py
- 18 # backend/conversations/migrations/0001_initial.py
- 19 # backend/conversations/migrations/0002_checkpoint_checkpointblob_checkpointmigration_and_more.py
- 20 # backend/conversations/migrations/0003_delete_checkpoint_delete_checkpointblob_and_more.py
- 21 # backend/conversations/migrations/__init__.py
- 22 # backend/conversations/models.py
- 23 # backend/conversations/serializers.py
- 24 # backend/conversations/urls.py
- 25 # backend/conversations/views.py
- 26 # backend/knowledge/__init__.py
- 27 # backend/knowledge/admin.py
- 28 # backend/knowledge/apps.py
- 29 # backend/knowledge/migrations/0001_initial.py
- 30 # backend/knowledge/migrations/0002_alter_summarynewskeywords_options_and_more.py
- 31 # backend/knowledge/migrations/__init__.py
- 32 # backend/knowledge/models.py
- 33 # backend/knowledge/views.py
- 34 # backend/manage.py
- 35 # backend/mlops/__init__.py
- 36 # backend/mlops/admin.py
- 37 # backend/mlops/apps.py
- 38 # backend/mlops/migrations/0001_initial.py
- 39 # backend/mlops/migrations/__init__.py
- 40 # backend/mlops/models.py
- 41 # backend/mlops/modules/nodes/__init__.py
- 42 # backend/mlops/views.py
- 43 # backend/path/to/your/app/Makefile
- 44 # backend/path/to/your/app/README.md
- 45 # backend/path/to/your/app/src/agent/__init__.py
- 46 # backend/path/to/your/app/src/agent/graph.py
- 47 # fastapi_server/README.md
- 48 # fastapi_server/__init__.py
- 49 # fastapi_server/agent/__init__.py
- 50 # fastapi_server/agent/agent2.py

Full context of all files:
--- File Index 0: README.md ---
## TSKN10-FINAL-1Team

## 프로젝트 개요
이 프로젝트는 사용자가 채팅으로 업무를 요청할 수 있는 **지능형 사내 업무 보조 챗봇 시스템**입니다. 사용자의 질문 의도를 **AI 에이전트 총괄 시스템 LangGraph Supervisor**이 파악하여 적절한 전문 에이전트에게 작업을 분배합니다. 마치 오케스트라의 지휘자처럼, 슈퍼바이저는 전체적인 요청을 보고 적임자(에이전트)를 찾아 지시를 내립니다. 예를 들어, 회사 규정 관련 질문은 **문서 검색 전문 에이전트 RAG Agent**에게, 데이터 분석 요청은 **데이터 분석 전문 에이전트 Analytics Agent**에게 전달됩니다. 코드 관련 질문은 **코드 분석 에이전트**가 담당할 수 있습니다. 모든 데이터는 **애플리케이션 데이터 설계도 Django 모델**에 따라 체계적으로 저장되며, 프론트엔드는 **실시간 AI 통신 게이트웨이 FastAPI & WebSocket**를 통해 AI 시스템과 매끄럽게 연결되어 AI 답변 생성 과정을 실시간으로 보여줍니다 (스트리밍). 이 시스템은 복잡한 내부 구조를 몰라도 사용자가 AI를 사람과 대화하듯 편안하게 사용할 수 있도록 설계되었습니다.

## 핵심 기능
*   **AI 에이전트 총괄 시스템 LangGraph Supervisor**: 사용자의 자연어 요청을 분석하여 가장 적합한 전문 에이전트 노드에게 작업을 라우팅하는 역할을 합니다. 슈퍼바이저는 특정 '업무 지침서'(Prompt)를 바탕으로 다음 에이전트를 결정합니다.
*   **문서 검색 전문 에이전트 RAG Agent**: 회사 내부 문서(정책, 매뉴얼, 회의록 등)에 대한 사용자의 질문에 답변합니다. Retrieval-Augmented Generation (RAG) 기술을 사용하며, 질문과 관련 있는 문서 조각을 **임베딩**과 **벡터 데이터베이스 Pinecone**를 통해 먼저 검색한 뒤(Retrieval), 그 내용을 바탕으로 답변을 생성합니다(Generation).
*   **데이터 분석 전문 에이전트 Analytics Agent**: 데이터베이스에 저장된 데이터를 분석하고 통찰력을 제공합니다. 사용자의 자연어 질문을 컴퓨터가 이해하는 SQL 쿼리로 변환하고 데이터베이스에서 실행하여 결과를 가져옵니다. 결과는 텍스트로 요약되거나 **Mermaid 차트** 코드로 시각화됩니다. (논의를 통해 시계열 예측보다는 이상치 모델링 방향으로 고려되었습니다).
*   **코드 분석 에이전트 Code Agent** (논의 중): GitHub 저장소나 사내 코드 베이스의 내용을 분석하고 질의응답하는 것을 목표로 합니다. 코드의 오류 부분을 파악하거나, 특정 함수의 사용 위치나 상호작용하는 파일을 알려주고, 도큐멘테이션을 참고하여 질문에 답변할 수 있습니다. 필요에 따라 코드 변환 기능도 포함될 수 있습니다. 사용자의 코드 언어 버전 탐지 및 해당 버전에 맞는 답변 제공이 중요하게 고려됩니다.
*   **실시간 AI 통신 게이트웨이 FastAPI & WebSocket**: 사용자의 브라우저과 AI 시스템을 연결하는 통신 다리 역할을 합니다. **WebSocket**을 통해 한 번 연결되면 끊기지 않는 '전화 통화'처럼 실시간으로 데이터를 주고받으며, **FastAPI**가 이 통신을 효율적으로 처리합니다. 이를 통해 AI 답변 생성 과정을 실시간 스트리밍으로 사용자에게 보여줍니다.
*   **외부 데이터 수집 및 처리 ETL**: AI 에이전트가 사용할 데이터(고객 정보, 뉴스, 문서 등)를 외부에서 가져와(Extract) 시스템이 사용하기 좋은 형태로 가공한 뒤(Transform), 데이터베이스나 벡터 저장소에 저장하는(Load) 자동화된 스크립트(파이프라인)를 의미합니다. tools 및 lambda 폴더의 파이썬 스크립트가 이 역할을 수행합니다. (CSV 파일의 고객 데이터, 최신 뉴스, 문서 파일(PDF, HTML) 텍스트 및 벡터 변환 등을 처리합니다).
*   **프론트엔드 채팅 UI**: 사용자가 AI와 직접 소통하고 눈으로 볼 수 있는 '얼굴'입니다. 메시지 입력창, 대화 내용이 보이는 말풍선(메시지 목록), 과거 대화 목록을 보여주는 사이드바 등으로 구성됩니다. React(Next.js)의 useState 기능을 사용하여 UI 상태를 관리하고, 서버로부터 받은 메시지를 화면에 그려줍니다.

## 기술 스택
*   **백엔드/AI**:
    *   웹 프레임워크: ![Django](https://img.shields.io/badge/Django-092E20?style=flat-square&logo=django&logoColor=white) (애플리케이션 데이터 설계 및 전통적인 API 연동)
    *   AI 통신 게이트웨이: ![FastAPI](https://img.shields.io/badge/FastAPI-009688?style=flat-square&logo=fastapi&logoColor=white) (실시간 통신 처리 및 에이전트 시스템 연동)
    *   실시간 통신: ![WebSocket](https://img.shields.io/badge/WebSocket-4353FF?style=flat-square&logo=socketdotio&logoColor=white)
    *   AI 오케스트레이션: ![LangGraph](https://img.shields.io/badge/LangGraph-FF5A5F?style=flat-square&logo=langchain&logoColor=white) (다양한 에이전트들의 작업 흐름 및 협업 설계)
    *   LLM: ![GPT](https://img.shields.io/badge/GPT-74aa9c?style=flat-square&logo=openai&logoColor=white) (주요 모델), 필요에 따라 ![Local LLM](https://img.shields.io/badge/Local_LLM-4B32C3?style=flat-square&logo=artificial-intelligence&logoColor=white) (Qwen3 32B 등) 서빙 (Runpod 활용), 다른 오픈소스 모델 (Mistral 등) 및 상용 모델 (Claude, Gemini) 고려.
    *   임베딩 모델: ![OpenAI Embeddings](https://img.shields.io/badge/OpenAI_Embeddings-74aa9c?style=flat-square&logo=openai&logoColor=white) (문서 및 쿼리 벡터 생성)
    *   벡터 데이터베이스: ![Pinecone](https://img.shields.io/badge/Pinecone-000000?style=flat-square&logo=pinecone&logoColor=white) (문서 임베딩 저장 및 검색), ![PostgreSQL](https://img.shields.io/badge/PostgreSQL_pgvector-4169E1?style=flat-square&logo=postgresql&logoColor=white) (논의됨). 하이브리드 서치 및 리랭킹 기능 고려.
    *   관계형 데이터베이스: ![PostgreSQL](https://img.shields.io/badge/PostgreSQL-4169E1?style=flat-square&logo=postgresql&logoColor=white) (사용자 정보, 채팅 내용, 분석 결과, 정형 데이터셋 등 저장).
    *   객체 스토리지: ![AWS S3](https://img.shields.io/badge/AWS_S3-569A31?style=flat-square&logo=amazons3&logoColor=white) (업로드 파일, 원본 문서, 모델 저장 등).
    *   ETL 스크립트: ![Python](https://img.shields.io/badge/Python-3776AB?style=flat-square&logo=python&logoColor=white) ![AWS Lambda](https://img.shields.io/badge/AWS_Lambda-FF9900?style=flat-square&logo=awslambda&logoColor=white) (requests, psycopg2, tqdm, pdfplumber, beautifulsoup, OpenAI API 등 활용).
    *   배포: ![AWS EC2](https://img.shields.io/badge/AWS_EC2-FF9900?style=flat-square&logo=amazonec2&logoColor=white), ![Runpod](https://img.shields.io/badge/Runpod-6C47FF?style=flat-square&logo=runpod&logoColor=white) (VLLM 서빙).
    *   툴 호출 표준: ![MCP](https://img.shields.io/badge/MCP-007ACC?style=flat-square&logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAqFBMVEX///8AAP8AgP8AgIAAgIBVVaoAYIBAgIBAYGBAYIBJbYBJbXFJbW1Nc21NbnZNbnFNbm1QcXFQcXZQcW1SdG1SdHFSdG1VVXFVVXZVVXFVVWpVVW1VVW1VVW1VVW1VVW1VVW1VVW1VVW1VVW1VVW1VVW1VVW1VVW1VVW1)

## 팀원 및 역할 (Roles and Responsibilities)
| 이름 | 이미지 | 역할 |
| ------ | ------ | ------ |
| **신정우** (PM) | <img src="./img/신정우.png" width="150"> | 데이터 분석 에이전트 개발 및 머신러닝 모델링 (프로젝트 기획 및 일정/이슈 관리 포함) |
| **경규휘** | <img src="./img/경규희.png" width="150"> | 문서 검색 전문 에이전트 (RAG) 개발 및 데이터 검색 (Product 문서 데이터 수집 및 RAG 테스트 포함) |
| **남궁승원** | <img src="./img/남궁승원.png" width="150"> | 데이터 분석 에이전트 개발 및 머신러닝 모델링 (ML 부분 포함) (기술 문서 및 사내 정책 문서 데이터 수집 포함) |
| **이태수** | <img src="./img/이태수.png" width="150"> | 시장 조사 및 문서 검색 전문 에이전트 (RAG) 개발 (뉴스 수집 API 개발 및 이슈/동향 수집 포함) |
| **황인호** | <img src="./img/인호.jpeg" width="150"> | AI 에이전트 총괄 시스템 (LangGraph Supervisor), 코드 에이전트, 프론트엔드 개발 (ERD, 배포, 데이터 조회 프로그램 개발 포함) |

## 문서 구조 (Chapters)
프로젝트의 핵심 구성 요소 및 개발 과정에 대한 자세한 내용은 다음 장에서 확인할 수 있습니다.
1.  [애플리케이션 데이터 설계도 (Django 모델)](docs/01_애플리케이션_데이터_설계도__django_모델__.md)
2.  [프론트엔드 채팅 UI](docs/02_프론트엔드_채팅_ui_.md)
3.  [실시간 AI 통신 게이트웨이 (FastAPI & WebSocket)](docs/03_실시간_ai_통신_게이트웨이__fastapi___websocket__.md)
4.  [AI 에이전트 총괄 시스템 (LangGraph Supervisor)](docs/04_ai_에이전트_총괄_시스템__langgraph_supervisor__.md)
5.  [데이터 분석 전문 에이전트 (Analytics Agent)](docs/05_데이터_분석_전문_에이전트__analytics_agent__.md)
6.  [문서 검색 전문 에이전트 (RAG Agent)](docs/06_문서_검색_전문_에이전트__rag_agent__.md)
7.  [외부 데이터 수집 및 처리 (ETL)](docs/07_외부_데이터_수집_및_처리__etl__.md)
8.  [프론트엔드-데이터베이스 연동](docs/08_프론트엔드_데이터베이스_연동_.md)

## 협업 및 일정 관리
*   **회의**: 정기적인 팀 회의를 통해 프로젝트 진행 상황 공유 및 다음 업무 논의.
*   **회의록**: Notion, ClovaNote 등을 활용하여 회의 내용, 결정 사항, 개별 업무 내용 기록 및 공유.
*   **코드 관리**: Git Repository를 사용하여 코드 버전 관리 및 협업.
*   **일정/이슈 관리**: GitHub Project를 활용하여 업무 이슈 등록, 담당자 배정, 진행 상황 추적.
*   **커뮤니케이션**: Discord, KakaoTalk 등을 활용하여 실시간 소통.
*   **기술 스터디**: LangGraph, LangSmith, Pinecone 사용법 등 핵심 기술에 대한 팀원 간 스터디 진행.


--- File Index 1: backend/accounts/__init__.py ---


--- File Index 2: backend/accounts/admin.py ---
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.utils.translation import gettext_lazy as _

from .models import Organization, User


@admin.register(Organization)
class OrganizationAdmin(admin.ModelAdmin):
    list_display = ('name', 'created_at')
    search_fields = ('name',)
    ordering = ('name',)


@admin.register(User)
class UserAdmin(BaseUserAdmin):
    list_display = ('email', 'name', 'org', 'role', 'is_staff', 'is_active')
    list_filter = ('is_staff', 'is_superuser', 'is_active', 'role', 'org')
    search_fields = ('email', 'name')
    ordering = ('email',)
    
    fieldsets = (
        (None, {'fields': ('email', 'password')}),
        (_('Personal info'), {'fields': ('name', 'org', 'role')}),
        (_('Permissions'), {
            'fields': ('is_active', 'is_staff', 'is_superuser', 'groups', 'user_permissions'),
        }),
        (_('Important dates'), {'fields': ('last_login', 'created_at')}),
    )
    add_fieldsets = (
        (None, {
            'classes': ('wide',),
            'fields': ('email', 'password1', 'password2', 'org', 'role'),
        }),
    )
    readonly_fields = ('created_at',)


--- File Index 3: backend/accounts/apps.py ---
from django.apps import AppConfig


class AccountsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'accounts'


--- File Index 4: backend/accounts/migrations/0001_initial.py ---
# Generated by Django 5.2.1 on 2025-05-29 05:36

import django.db.models.deletion
import uuid
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='Organization',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=255, unique=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
            ],
            options={
                'db_table': 'organizations',
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='User',
            fields=[
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('is_superuser', models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('email', models.EmailField(max_length=254, unique=True)),
                ('name', models.CharField(blank=True, max_length=100)),
                ('role', models.CharField(choices=[('admin', 'Admin'), ('engineer', 'Engineer'), ('analyst', 'Analyst'), ('guest', 'Guest')], default='guest', max_length=20)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('last_login', models.DateTimeField(blank=True, null=True)),
                ('is_active', models.BooleanField(default=True)),
                ('is_staff', models.BooleanField(default=False)),
                ('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.group', verbose_name='groups')),
                ('user_permissions', models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.permission', verbose_name='user permissions')),
                ('org', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='users', to='accounts.organization')),
            ],
            options={
                'db_table': 'users',
                'ordering': ['email'],
            },
        ),
    ]


--- File Index 5: backend/accounts/migrations/__init__.py ---


--- File Index 6: backend/accounts/models.py ---
"""accounts/models.py  –  조직·사용자"""

import uuid
from django.db import models
from django.contrib.auth.models import AbstractBaseUser, PermissionsMixin, BaseUserManager


class UserRole(models.TextChoices):
    ADMIN = "admin", "Admin"
    ENGINEER = "engineer", "Engineer"
    ANALYST = "analyst", "Analyst"
    GUEST = "guest", "Guest"


class Organization(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=255, unique=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "organizations"
        ordering = ["name"]

    def __str__(self):
        return self.name


class UserManager(BaseUserManager):
    def create_user(self, email: str, password: str | None = None, **extra):
        if not email:
            raise ValueError("Email is required")
        user = self.model(email=self.normalize_email(email), **extra)
        user.set_password(password)
        user.save()
        return user

    def create_superuser(self, email: str, password: str | None = None, **extra):
        extra.setdefault("role", UserRole.ADMIN)
        extra.setdefault("is_staff", True)
        extra.setdefault("is_superuser", True)
        
        # Organization이 제공되지 않은 경우 기본 Organization 생성 또는 사용
        if 'org' not in extra:
            # 기본 조직이 있는지 확인
            default_org, created = Organization.objects.get_or_create(
                name="Default Organization"
            )
            extra["org"] = default_org
            
        return self.create_user(email, password, **extra)


class User(AbstractBaseUser, PermissionsMixin):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    org = models.ForeignKey(Organization, on_delete=models.CASCADE, related_name="users")
    email = models.EmailField(unique=True)
    name = models.CharField(max_length=100, blank=True)
    role = models.CharField(max_length=20, choices=UserRole.choices, default=UserRole.GUEST)
    created_at = models.DateTimeField(auto_now_add=True)
    last_login = models.DateTimeField(null=True, blank=True)

    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)

    objects = UserManager()
    USERNAME_FIELD = "email"

    class Meta:
        db_table = "users"
        ordering = ["email"]

    def __str__(self):
        return self.email


--- File Index 7: backend/accounts/serializers.py ---
from rest_framework import serializers
from .models import User, Organization

class OrganizationSerializer(serializers.ModelSerializer):
    class Meta:
        model = Organization
        fields = ['id', 'name']

class UserSerializer(serializers.ModelSerializer):
    org = OrganizationSerializer(read_only=True)
    
    class Meta:
        model = User
        fields = ['id', 'email', 'name', 'org', 'role', 'created_at', 'last_login', 'is_active', 'is_staff']
        read_only_fields = ['id', 'email', 'created_at', 'last_login', 'is_active', 'is_staff']


--- File Index 8: backend/accounts/urls.py ---
from django.urls import path, re_path
from rest_framework_simplejwt.views import TokenRefreshView
from . import views

urlpatterns = [
    # 유연한 URL 패턴 사용 - 슬래시 유무 상관없이 처리
    re_path(r'^login/?$', views.login_view, name='login'),
    re_path(r'^logout/?$', views.logout_view, name='logout'),
    re_path(r'^me/?$', views.user_detail, name='user-detail'),
    re_path(r'^profile/?$', views.update_profile, name='update-profile'),
    re_path(r'^token/refresh/?$', TokenRefreshView.as_view(), name='token-refresh'),
]


--- File Index 9: backend/accounts/views.py ---
from django.contrib.auth import authenticate
from rest_framework import status
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated, AllowAny
from rest_framework.response import Response
from rest_framework_simplejwt.tokens import RefreshToken
from rest_framework_simplejwt.views import TokenRefreshView
from .serializers import UserSerializer

@api_view(['POST'])
@permission_classes([AllowAny])
def login_view(request):
    email = request.data.get('email')
    password = request.data.get('password')
    
    if not email or not password:
        return Response({'detail': 'Email and password are required'}, status=status.HTTP_400_BAD_REQUEST)
    
    # Debugging info - remove in production
    print(f"Login attempt with email: {email}")
    
    # Check if the user exists in the database
    from django.contrib.auth import get_user_model
    User = get_user_model()
    
    try:
        user_exists = User.objects.filter(email=email).exists()
        print(f"User exists in database: {user_exists}")
        
        if not user_exists:
            # Create a test user for debugging if it doesn't exist
            print("Creating test user for debugging...")
            from django.contrib.auth.hashers import make_password
            from .models import Organization
            
            # Get or create default organization
            default_org, _ = Organization.objects.get_or_create(name="Default Organization")
            
            # Create test user
            User.objects.create(
                email=email,
                password=make_password(password),  # Properly hash the password
                name="Test User",
                org=default_org,
                role="admin",
                is_active=True,
                is_staff=True
            )
            print(f"Test user created with email: {email}")
    except Exception as e:
        print(f"Error checking/creating user: {e}")
    
    # Django's authenticate expects the USERNAME_FIELD value in the 'username' parameter
    # Since our User model has USERNAME_FIELD = 'email', we pass email to username parameter
    user = authenticate(username=email, password=password)
    print(f"Authentication result: {'Success' if user else 'Failed'}")
    
    if user:
        refresh = RefreshToken.for_user(user)
        return Response({
            'refresh': str(refresh),
            'access': str(refresh.access_token),
            'user': UserSerializer(user).data
        })
    
    # More detailed error for debugging
    return Response({'detail': 'Invalid credentials. Please check your email and password.'}, 
                    status=status.HTTP_401_UNAUTHORIZED)

@api_view(['POST'])
@permission_classes([AllowAny])
def logout_view(request):
    # JWT doesn't really need server-side logout, but we keep the endpoint for API consistency
    return Response({"detail": "Successfully logged out."})

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def user_detail(request):
    serializer = UserSerializer(request.user)
    return Response(serializer.data)

@api_view(['PATCH'])
@permission_classes([IsAuthenticated])
def update_profile(request):
    user = request.user
    serializer = UserSerializer(user, data=request.data, partial=True)
    
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data)
    
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


--- File Index 10: backend/config/__init__.py ---


--- File Index 11: backend/config/asgi.py ---
"""
ASGI config for config project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_asgi_application()


--- File Index 12: backend/config/settings.py ---
"""
Django settings for config project.

Generated by 'django-admin startproject' using Django 5.2.1.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""
import os
from dotenv import load_dotenv
from pathlib import Path

load_dotenv()

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.getenv('SECRET_KEY')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework', 'rest_framework_simplejwt', 'corsheaders',
    'accounts', 'knowledge', 'conversations', 'mlops',
    'pgvector.django'
]

# Custom user model
AUTH_USER_MODEL = 'accounts.User'

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',  # CORS 미들웨어는 가장 앞에 위치해야 함
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'config.urls'

# URL configuration
APPEND_SLASH = False  # Do not force appending slashes to URLs

# CORS settings
CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",  # Next.js 개발 서버
]
CORS_ALLOW_CREDENTIALS = True

# Add CORS_ALLOWED_METHODS
CORS_ALLOWED_METHODS = [
    'DELETE',
    'GET',
    'OPTIONS',
    'PATCH',
    'POST',
    'PUT',
]

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

# DATABASES = {
#     'default': {
#         'ENGINE': 'django.db.backends.sqlite3',
#         'NAME': BASE_DIR / 'db.sqlite3',
#     }
# }

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.getenv('DB_NAME'),
        'USER': os.getenv('DB_USER'),
        'PASSWORD': os.getenv('DB_PASSWORD'),
        'HOST': os.getenv('DB_HOST'),
        'PORT': os.getenv('DB_PORT', '5432'),
    }
}
#print(DATABASES)


# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# REST Framework settings
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
}

# JWT settings
from datetime import timedelta
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(hours=1),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=7),
    'ROTATE_REFRESH_TOKENS': False,
    'BLACKLIST_AFTER_ROTATION': True,
    'ALGORITHM': 'HS256',
    'SIGNING_KEY': SECRET_KEY,
    'VERIFYING_KEY': None,
    'AUTH_HEADER_TYPES': ('Bearer',),
    'USER_ID_FIELD': 'id',
    'USER_ID_CLAIM': 'user_id',
    'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),
    'TOKEN_TYPE_CLAIM': 'token_type',
}

# CORS settings
CORS_ALLOWED_ORIGINS = [
    'http://localhost:3000',  # Next.js frontend
]
CORS_ALLOW_CREDENTIALS = True


--- File Index 13: backend/config/urls.py ---
"""
URL configuration for config project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include, re_path
from django.http import JsonResponse

def health_check(request):
    return JsonResponse({'status': 'ok'})

urlpatterns = [
    path('admin/', admin.site.urls),
    # 유연한 URL 패턴 사용 - 슬래시 유무 상관없이 처리
    re_path(r'^api/auth/?', include('accounts.urls')),
    re_path(r'^api/chat/?', include('conversations.urls')),
    re_path(r'^api/health-check/?$', health_check, name='health-check'),
]


--- File Index 14: backend/config/wsgi.py ---
"""
WSGI config for config project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_wsgi_application()


--- File Index 15: backend/conversations/__init__.py ---


--- File Index 16: backend/conversations/admin.py ---
from django.contrib import admin

from django.utils.html import format_html
from .models import ChatSession, ChatMessage, LlmCall
import json # JSONField 내용을 파싱하거나 요약할 때 사용 가능


class ChatMessageInline(admin.TabularInline):
    model = ChatMessage
    extra = 0
    readonly_fields = ('created_at',)
    fields = ('role', 'content', 'created_at')
    ordering = ('created_at',)


class LlmCallInline(admin.TabularInline):
    model = LlmCall
    extra = 0
    readonly_fields = ('called_at',)
    fields = ('provider', 'model', 'prompt_tokens', 'completion_tokens', 'cost_usd', 'latency_ms', 'called_at')
    ordering = ('-called_at',)


@admin.register(ChatSession)
class ChatSessionAdmin(admin.ModelAdmin):
    list_display = ('id', 'user', 'agent_type', 'started_at', 'ended_at', 'duration', 'message_count')
    list_filter = ('agent_type', 'started_at')
    search_fields = ('user__email', 'user__name')
    readonly_fields = ('started_at', 'ended_at')
    list_select_related = ('user',)
    inlines = [ChatMessageInline, LlmCallInline]
    
    def duration(self, obj):
        if obj.ended_at:
            duration = obj.ended_at - obj.started_at
            return f"{duration.seconds // 60}m {duration.seconds % 60}s"
        return "Ongoing"
    duration.short_description = 'Duration'
    
    def message_count(self, obj):
        return obj.messages.count()
    message_count.short_description = 'Messages'


@admin.register(ChatMessage)
class ChatMessageAdmin(admin.ModelAdmin):
    list_display = ('truncated_content', 'role', 'session', 'created_at')
    list_filter = ('role', 'created_at')
    search_fields = ('content', 'session__user__email')
    readonly_fields = ('created_at',)
    list_select_related = ('session__user',)
    
    def truncated_content(self, obj):
        return obj.content[:100] + '...' if len(obj.content) > 100 else obj.content
    truncated_content.short_description = 'Content'


@admin.register(LlmCall)
class LlmCallAdmin(admin.ModelAdmin):
    list_display = ('id', 'session', 'model', 'cost_usd', 'latency_ms', 'called_at')
    list_filter = ('provider', 'model', 'called_at')
    search_fields = ('session__user__email', 'model')
    readonly_fields = ('called_at',)
    list_select_related = ('session__user',)
    
    def has_add_permission(self, request):
        return False  # Prevent manual addition of LLM calls


# 모든 LangGraph 테이블에 적용할 읽기 전용 Admin 클래스
class ReadOnlyAdmin(admin.ModelAdmin):
    def has_add_permission(self, request):
        # 추가 기능 비활성화
        return False
    def has_change_permission(self, request, obj=None):
        # 변경 기능 비활성화
        return False
    def has_delete_permission(self, request, obj=None):
        # 삭제 기능 비활성화
        return False
    
    # list_display의 항목들이 변경 페이지로 연결되는 링크가 되지 않도록 설정
    # 이렇게 하면 list_display의 각 항목이 링크로 표시되지 않습니다.
    def get_list_display_links(self, request, list_display):
        return None





--- File Index 17: backend/conversations/apps.py ---
from django.apps import AppConfig


class ConversationsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'conversations'


--- File Index 18: backend/conversations/migrations/0001_initial.py ---
# Generated by Django 5.2.1 on 2025-05-29 05:36

import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='ChatSession',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('agent_type', models.CharField(choices=[('code', 'Code'), ('rag', 'RAG'), ('analytics', 'Analytics')], max_length=20)),
                ('started_at', models.DateTimeField(auto_now_add=True)),
                ('ended_at', models.DateTimeField(blank=True, null=True)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='chat_sessions', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'chat_sessions',
            },
        ),
        migrations.CreateModel(
            name='ChatMessage',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('role', models.CharField(max_length=20)),
                ('content', models.TextField()),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('session', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='messages', to='conversations.chatsession')),
            ],
            options={
                'db_table': 'chat_messages',
                'ordering': ['created_at'],
            },
        ),
        migrations.CreateModel(
            name='LlmCall',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('provider', models.CharField(max_length=50)),
                ('model', models.CharField(max_length=100)),
                ('prompt_tokens', models.PositiveIntegerField()),
                ('completion_tokens', models.PositiveIntegerField()),
                ('cost_usd', models.DecimalField(decimal_places=4, max_digits=10)),
                ('latency_ms', models.PositiveIntegerField(blank=True, null=True)),
                ('called_at', models.DateTimeField(auto_now_add=True)),
                ('session', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='llm_calls', to='conversations.chatsession')),
            ],
            options={
                'db_table': 'llm_calls',
                'indexes': [models.Index(fields=['called_at'], name='idx_llm_called_at')],
            },
        ),
    ]


--- File Index 19: backend/conversations/migrations/0002_checkpoint_checkpointblob_checkpointmigration_and_more.py ---
# Generated by Django 5.2.1 on 2025-06-02 17:18

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('conversations', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Checkpoint',
            fields=[
                ('thread_id', models.TextField(primary_key=True, serialize=False)),
                ('checkpoint_ns', models.TextField(default='')),
                ('checkpoint_id', models.TextField()),
                ('parent_checkpoint_id', models.TextField(blank=True, null=True)),
                ('type', models.TextField(blank=True, null=True)),
                ('checkpoint', models.JSONField()),
                ('metadata', models.JSONField(default=dict)),
            ],
            options={
                'db_table': 'checkpoints',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='CheckpointBlob',
            fields=[
                ('thread_id', models.TextField(primary_key=True, serialize=False)),
                ('checkpoint_ns', models.TextField(default='')),
                ('channel', models.TextField()),
                ('version', models.TextField()),
                ('type', models.TextField()),
                ('blob', models.BinaryField(blank=True, null=True)),
            ],
            options={
                'db_table': 'checkpoint_blobs',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='CheckpointMigration',
            fields=[
                ('v', models.IntegerField(primary_key=True, serialize=False)),
            ],
            options={
                'db_table': 'checkpoint_migrations',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='CheckpointWrite',
            fields=[
                ('thread_id', models.TextField(primary_key=True, serialize=False)),
                ('checkpoint_ns', models.TextField(default='')),
                ('checkpoint_id', models.TextField()),
                ('task_id', models.TextField()),
                ('idx', models.IntegerField()),
                ('channel', models.TextField()),
                ('type', models.TextField(blank=True, null=True)),
                ('blob', models.BinaryField()),
            ],
            options={
                'db_table': 'checkpoint_writes',
                'managed': False,
            },
        ),
        migrations.AddField(
            model_name='chatsession',
            name='title',
            field=models.CharField(default='새 세션', max_length=60),
        ),
    ]


--- File Index 20: backend/conversations/migrations/0003_delete_checkpoint_delete_checkpointblob_and_more.py ---
# Generated by Django 5.2.1 on 2025-06-04 00:45

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('conversations', '0002_checkpoint_checkpointblob_checkpointmigration_and_more'),
    ]

    operations = [
        migrations.DeleteModel(
            name='Checkpoint',
        ),
        migrations.DeleteModel(
            name='CheckpointBlob',
        ),
        migrations.DeleteModel(
            name='CheckpointMigration',
        ),
        migrations.DeleteModel(
            name='CheckpointWrite',
        ),
        migrations.AlterField(
            model_name='chatsession',
            name='agent_type',
            field=models.CharField(choices=[('code', 'Code'), ('rag', 'RAG'), ('analytics', 'Analytics'), ('auto', 'Auto')], max_length=20),
        ),
    ]


--- File Index 21: backend/conversations/migrations/__init__.py ---


--- File Index 22: backend/conversations/models.py ---
"""conversations/models.py  –  채팅·LLM 호출"""

import uuid
from django.db import models
from accounts.models import User


class AgentType(models.TextChoices):
    CODE = "code", "Code"
    RAG = "rag", "RAG"
    ANALYTICS = "analytics", "Analytics"
    AUTO = "auto", "Auto"


class ChatSession(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="chat_sessions")
    agent_type = models.CharField(max_length=20, choices=AgentType.choices)
    started_at = models.DateTimeField(auto_now_add=True)
    ended_at = models.DateTimeField(null=True, blank=True)
    title = models.CharField(max_length=60, default="새 세션")

    class Meta:
        db_table = "chat_sessions"


class ChatMessage(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    session = models.ForeignKey(ChatSession, on_delete=models.CASCADE, related_name="messages")
    role = models.CharField(max_length=20)  # user | assistant | system
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "chat_messages"
        ordering = ["created_at"]


class LlmCall(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    session = models.ForeignKey(ChatSession, on_delete=models.CASCADE, related_name="llm_calls")
    provider = models.CharField(max_length=50)
    model = models.CharField(max_length=100)
    prompt_tokens = models.PositiveIntegerField()
    completion_tokens = models.PositiveIntegerField()
    cost_usd = models.DecimalField(max_digits=10, decimal_places=4)
    latency_ms = models.PositiveIntegerField(null=True, blank=True)
    called_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "llm_calls"
        indexes = [models.Index(fields=["called_at"], name="idx_llm_called_at")]



--- File Index 23: backend/conversations/serializers.py ---
from rest_framework import serializers
from .models import ChatSession, ChatMessage, LlmCall, AgentType


class ChatMessageSerializer(serializers.ModelSerializer):
    """ChatMessage 모델 직렬화를 위한 serializer"""
    
    class Meta:
        model = ChatMessage
        fields = ['id', 'session', 'role', 'content', 'created_at']
        read_only_fields = ['id', 'created_at']


class LlmCallSerializer(serializers.ModelSerializer):
    """LlmCall 모델 직렬화를 위한 serializer"""
    
    class Meta:
        model = LlmCall
        fields = ['id', 'session', 'provider', 'model', 'prompt_tokens', 
                 'completion_tokens', 'cost_usd', 'latency_ms', 'called_at']
        read_only_fields = ['id', 'called_at']


class ChatSessionSerializer(serializers.ModelSerializer):
    """ChatSession 모델 직렬화를 위한 serializer"""
    messages = ChatMessageSerializer(many=True, read_only=True)
    
    class Meta:
        model = ChatSession
        fields = ['id', 'user', 'agent_type', 'started_at', 'ended_at', 'title', 'messages']
        read_only_fields = ['id', 'started_at']

    def validate_agent_type(self, value):
        """agent_type 필드 유효성 검사"""
        if value not in [choice[0] for choice in AgentType.choices]:
            raise serializers.ValidationError(f"유효하지 않은 에이전트 유형입니다. 유효한 값: {AgentType.choices}")
        return value


--- File Index 24: backend/conversations/urls.py ---
from django.urls import path, re_path
from . import views

urlpatterns = [
    # 채팅 세션 관련 URL
    re_path(r'^sessions/?$', views.ChatSessionViewSet.as_view(), name='chat_sessions'),
    re_path(r'^sessions/(?P<pk>[0-9a-f-]+)/?$', views.ChatSessionDetailView.as_view(), name='chat_session_detail'),
    
    # 채팅 메시지 관련 URL
    re_path(r'^sessions/(?P<session_pk>[0-9a-f-]+)/messages/?$', views.ChatMessageView.as_view(), name='chat_messages'),
]


--- File Index 25: backend/conversations/views.py ---
from django.utils import timezone
from django.shortcuts import get_object_or_404
from rest_framework import status, viewsets
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.views import APIView

from .models import ChatSession, ChatMessage
from .serializers import ChatSessionSerializer, ChatMessageSerializer


class ChatSessionViewSet(APIView):
    """채팅 세션을 관리하는 API 뷰셋"""
    permission_classes = [IsAuthenticated]

    def get(self, request):
        """현재 사용자의 모든 채팅 세션 조회"""
        sessions = ChatSession.objects.filter(user=request.user).order_by('-started_at')
        serializer = ChatSessionSerializer(sessions, many=True)
        return Response(serializer.data)

    def post(self, request):
        """새 채팅 세션 생성"""
        # 요청 데이터에 사용자 ID 추가
        data = request.data.copy()
        data['user'] = request.user.id
        
        serializer = ChatSessionSerializer(data=data)
        if serializer.is_valid():
            session = serializer.save()
            
            # 시스템 메시지 생성 (선택적)
            welcome_message = f"Welcome to your new {session.agent_type} session. How can I help you today?"
            ChatMessage.objects.create(
                session=session,
                role="system",
                content=welcome_message
            )
            
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class ChatSessionDetailView(APIView):
    """특정 채팅 세션을 관리하는 API 뷰"""
    permission_classes = [IsAuthenticated]

    def get(self, request, pk):
        """특정 채팅 세션 조회"""
        session = get_object_or_404(ChatSession, pk=pk, user=request.user)
        serializer = ChatSessionSerializer(session)
        return Response(serializer.data)

    def patch(self, request, pk):
        """채팅 세션 업데이트 (주로 종료 시간)"""
        session = get_object_or_404(ChatSession, pk=pk, user=request.user)
        serializer = ChatSessionSerializer(session, data=request.data, partial=True)
        
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class ChatMessageView(APIView):
    """채팅 메시지를 관리하는 API 뷰"""
    permission_classes = [IsAuthenticated]

    def get(self, request, session_pk):
        """특정 세션의 모든 메시지 조회"""
        # 해당 세션이 현재 사용자의 것인지 확인
        session = get_object_or_404(ChatSession, pk=session_pk, user=request.user)
        messages = ChatMessage.objects.filter(session=session).order_by('created_at')
        serializer = ChatMessageSerializer(messages, many=True)
        return Response(serializer.data)

    def post(self, request, session_pk):
        """새 메시지 생성 및 AI 응답 생성"""
        # 해당 세션이 현재 사용자의 것인지 확인
        session = get_object_or_404(ChatSession, pk=session_pk, user=request.user)
        
        # 사용자 메시지 생성
        data = request.data.copy()
        data['session'] = session.pk
        data['role'] = 'user'
        
        serializer = ChatMessageSerializer(data=data)
        if serializer.is_valid():
            user_message = serializer.save()
            
            # 여기서 AI 응답을 생성하는 로직을 추가할 수 있습니다
            # 지금은 간단한 예시 응답을 생성합니다
            ai_response_content = f"This is a mock response to your message: {user_message.content}"
            
            # AI 응답 메시지 생성
            ai_message = ChatMessage.objects.create(
                session=session,
                role="assistant",
                content=ai_response_content
            )
            
            # 사용자 메시지와 AI 응답을 모두 포함하여 반환
            both_messages = ChatMessage.objects.filter(id__in=[user_message.id, ai_message.id])
            messages_serializer = ChatMessageSerializer(both_messages, many=True)
            return Response(messages_serializer.data, status=status.HTTP_201_CREATED)
        
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


--- File Index 26: backend/knowledge/__init__.py ---


--- File Index 27: backend/knowledge/admin.py ---
from django.contrib import admin
from django.utils.html import format_html
from .models import Document, GitRepository, CodeFile, EmbedChunk, TelecomCustomers, SummaryNewsKeywords


@admin.register(Document)
class DocumentAdmin(admin.ModelAdmin):
    list_display = ('title', 'doc_type', 'org', 'version', 'created_at')
    list_filter = ('doc_type', 'org')
    search_fields = ('title', 's3_key')
    list_select_related = ('org', 'uploaded_by')
    readonly_fields = ('created_at',)
    date_hierarchy = 'created_at'


@admin.register(GitRepository)
class GitRepositoryAdmin(admin.ModelAdmin):
    list_display = ('repo_url', 'org', 'default_branch', 'fetched_at')
    list_filter = ('org',)
    search_fields = ('repo_url',)
    readonly_fields = ('fetched_at',)


@admin.register(CodeFile)
class CodeFileAdmin(admin.ModelAdmin):
    list_display = ('file_path', 'repo', 'language', 'loc')
    list_filter = ('repo', 'language')
    search_fields = ('file_path', 'latest_commit')
    list_select_related = ('repo',)
    readonly_fields = ('id',)


@admin.register(EmbedChunk)
class EmbedChunkAdmin(admin.ModelAdmin):
    list_display = ('id', 'chunk_index', 'document', 'file', 'hash_short')
    list_filter = ('document', 'file')
    search_fields = ('hash', 'pinecone_id')
    readonly_fields = ('id',)
    list_select_related = ('document', 'file')
    
    def hash_short(self, obj):
        return f"{obj.hash[:10]}..." if obj.hash else ""
    hash_short.short_description = 'Hash'





@admin.register(TelecomCustomers)
class TelecomCustomersAdmin(admin.ModelAdmin) :
    list_display = ('id', 'customer_id', 'gender', 'partner', 'dependents' ,'churn')
    list_filter = ('dependents','churn', 'gender')
    search_fields = ('id','customer_id')
    readonly_fields = ('id', 'customer_id')


@admin.register(SummaryNewsKeywords)
class SummaryNewsKeywordsAdmin(admin.ModelAdmin):
    list_display = ('date', 'keyword_display', 'title_short', 'url_short')
    list_filter = ('date', 'keyword')
    search_fields = ('title', 'summary', 'keyword')
    list_select_related = ()
    date_hierarchy = 'date'
    ordering = ('-date', 'keyword')
    
    def keyword_display(self, obj):
        return obj.keyword
    keyword_display.short_description = 'Keyword'
    
    def title_short(self, obj):
        return f"{obj.title[:50]}..." if len(obj.title) > 50 else obj.title
    title_short.short_description = 'Title'
    
    def url_short(self, obj):
        return format_html('<a href="{}" target="_blank">Link</a>', obj.url)
    url_short.short_description = 'URL'


--- File Index 28: backend/knowledge/apps.py ---
from django.apps import AppConfig


class KnowledgeConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'knowledge'


--- File Index 29: backend/knowledge/migrations/0001_initial.py ---
# Generated by Django 5.2.1 on 2025-05-29 05:36

import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('accounts', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='CodeFile',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('file_path', models.TextField()),
                ('language', models.CharField(blank=True, max_length=50)),
                ('latest_commit', models.CharField(blank=True, max_length=40)),
                ('loc', models.PositiveIntegerField(blank=True, null=True)),
            ],
            options={
                'db_table': 'code_files',
            },
        ),
        migrations.CreateModel(
            name='TelecomCustomers',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('customer_id', models.CharField(max_length=20)),
                ('gender', models.CharField(max_length=6)),
                ('senior_citizen', models.BooleanField()),
                ('partner', models.BooleanField()),
                ('dependents', models.BooleanField()),
                ('tenure', models.IntegerField()),
                ('phone_service', models.BooleanField()),
                ('multiple_lines', models.CharField(max_length=20)),
                ('internet_serivce', models.CharField(max_length=20)),
                ('online_security', models.CharField(max_length=20)),
                ('online_backup', models.CharField(max_length=20)),
                ('device_protection', models.CharField(max_length=20)),
                ('tech_support', models.CharField(max_length=20)),
                ('streaming_tv', models.CharField(max_length=20)),
                ('streaming_movies', models.CharField(max_length=20)),
                ('contract', models.CharField(max_length=20)),
                ('paperless_billing', models.BooleanField()),
                ('payment_method', models.CharField(max_length=30)),
                ('monthly_charges', models.DecimalField(decimal_places=2, max_digits=10)),
                ('total_charges', models.DecimalField(decimal_places=2, max_digits=14)),
                ('churn', models.BooleanField()),
            ],
            options={
                'db_table': 'telecom_customers',
            },
        ),
        migrations.CreateModel(
            name='Document',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('title', models.CharField(max_length=255)),
                ('doc_type', models.CharField(choices=[('policy', 'Policy'), ('product', 'Product'), ('tech_manual', 'Tech Manual')], max_length=20)),
                ('s3_key', models.TextField(unique=True)),
                ('version', models.CharField(default='v1', max_length=50)),
                ('pinecone_ns', models.CharField(max_length=100)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('org', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='documents', to='accounts.organization')),
                ('uploaded_by', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='uploaded_documents', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'documents',
            },
        ),
        migrations.CreateModel(
            name='EmbedChunk',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('chunk_index', models.PositiveIntegerField()),
                ('pinecone_id', models.CharField(max_length=100)),
                ('hash', models.CharField(max_length=64, unique=True)),
                ('document', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='chunks', to='knowledge.document')),
                ('file', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='chunks', to='knowledge.codefile')),
            ],
            options={
                'db_table': 'embed_chunks',
            },
        ),
        migrations.CreateModel(
            name='GitRepository',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('repo_url', models.TextField(unique=True)),
                ('default_branch', models.CharField(default='main', max_length=100)),
                ('fetched_at', models.DateTimeField(blank=True, null=True)),
                ('org', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='repositories', to='accounts.organization')),
            ],
            options={
                'db_table': 'git_repositories',
            },
        ),
        migrations.AddField(
            model_name='codefile',
            name='repo',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='code_files', to='knowledge.gitrepository'),
        ),
        migrations.CreateModel(
            name='SummaryNewsKeywords',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('date', models.DateField()),
                ('keyword', models.TextField()),
                ('title', models.TextField()),
                ('summary', models.TextField()),
                ('url', models.URLField(max_length=500)),
            ],
            options={
                'db_table': 'summary_news_keywords',
                'ordering': ['-date'],
                'indexes': [models.Index(fields=['date'], name='idx_news_date'), models.Index(fields=['keyword'], name='idx_news_keyword')],
            },
        ),
        migrations.AddIndex(
            model_name='document',
            index=models.Index(fields=['org', 'doc_type'], name='idx_docs_org_type'),
        ),
        migrations.AddIndex(
            model_name='embedchunk',
            index=models.Index(fields=['document', 'file'], name='idx_chunks_source'),
        ),
        migrations.AddConstraint(
            model_name='embedchunk',
            constraint=models.CheckConstraint(condition=models.Q(models.Q(('document__isnull', False), ('file__isnull', True)), models.Q(('document__isnull', True), ('file__isnull', False)), _connector='OR'), name='embed_chunks_one_fk'),
        ),
        migrations.AddIndex(
            model_name='codefile',
            index=models.Index(fields=['repo'], name='idx_files_repo'),
        ),
        migrations.AlterUniqueTogether(
            name='codefile',
            unique_together={('repo', 'file_path')},
        ),
    ]


--- File Index 30: backend/knowledge/migrations/0002_alter_summarynewskeywords_options_and_more.py ---
# Generated by Django 5.2.1 on 2025-05-29 06:30

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('knowledge', '0001_initial'),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='summarynewskeywords',
            options={'verbose_name_plural': 'Summary news keywords'},
        ),
        migrations.AlterModelOptions(
            name='telecomcustomers',
            options={'verbose_name_plural': 'Telecom customers'},
        ),
        migrations.RemoveIndex(
            model_name='summarynewskeywords',
            name='idx_news_date',
        ),
        migrations.RemoveIndex(
            model_name='summarynewskeywords',
            name='idx_news_keyword',
        ),
    ]


--- File Index 31: backend/knowledge/migrations/__init__.py ---


--- File Index 32: backend/knowledge/models.py ---
"""knowledge/models.py  –  문서·레포·임베딩"""

import uuid
from django.db import models
from django.db.models import Q, CheckConstraint
from accounts.models import Organization, User
from pgvector.django import VectorField

class DocType(models.TextChoices):
    POLICY = "policy", "Policy"
    PRODUCT = "product", "Product"
    TECH_MANUAL = "tech_manual", "Tech Manual"


class Document(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    org = models.ForeignKey(Organization, on_delete=models.CASCADE, related_name="documents")
    title = models.CharField(max_length=255)
    doc_type = models.CharField(max_length=20, choices=DocType.choices)
    s3_key = models.TextField(unique=True)
    version = models.CharField(max_length=50, default="v1")
    pinecone_ns = models.CharField(max_length=100)
    uploaded_by = models.ForeignKey(
        User, null=True, blank=True, on_delete=models.SET_NULL, related_name="uploaded_documents"
    )
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "documents"
        indexes = [models.Index(fields=["org", "doc_type"], name="idx_docs_org_type")]

    def __str__(self):
        return self.title


class GitRepository(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    org = models.ForeignKey(Organization, on_delete=models.CASCADE, related_name="repositories")
    repo_url = models.TextField(unique=True)
    default_branch = models.CharField(max_length=100, default="main")
    fetched_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = "git_repositories"

    def __str__(self):
        return self.repo_url


class CodeFile(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    repo = models.ForeignKey(GitRepository, on_delete=models.CASCADE, related_name="code_files")
    file_path = models.TextField()
    language = models.CharField(max_length=50, blank=True)
    latest_commit = models.CharField(max_length=40, blank=True)
    loc = models.PositiveIntegerField(null=True, blank=True)

    class Meta:
        db_table = "code_files"
        unique_together = ("repo", "file_path")
        indexes = [models.Index(fields=["repo"], name="idx_files_repo")]

    def __str__(self):
        return self.file_path


class EmbedChunk(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    document = models.ForeignKey(
        Document, null=True, blank=True, on_delete=models.CASCADE, related_name="chunks"
    )
    file = models.ForeignKey(
        CodeFile, null=True, blank=True, on_delete=models.CASCADE, related_name="chunks"
    )
    chunk_index = models.PositiveIntegerField()
    pinecone_id = models.CharField(max_length=100)
    hash = models.CharField(max_length=64, unique=True)

    class Meta:
        db_table = "embed_chunks"
        constraints = [
            CheckConstraint(
                name="embed_chunks_one_fk",
                check=Q(document__isnull=False, file__isnull=True)
                | Q(document__isnull=True, file__isnull=False),
            )
        ]
        indexes = [models.Index(fields=["document", "file"], name="idx_chunks_source")]

    def __str__(self):
        return self.hash
    



class TelecomCustomers(models.Model) :
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    customer_id = models.CharField(max_length=20, null=False)
    gender = models.CharField(max_length=6)
    senior_citizen = models.BooleanField()
    partner = models.BooleanField()
    dependents = models.BooleanField()
    tenure = models.IntegerField()
    phone_service = models.BooleanField()
    multiple_lines = models.CharField(max_length=20)
    internet_serivce = models.CharField(max_length=20)
    online_security = models.CharField(max_length=20)
    online_backup = models.CharField(max_length=20)
    device_protection = models.CharField(max_length=20)
    tech_support = models.CharField(max_length=20)
    streaming_tv = models.CharField(max_length=20)
    streaming_movies = models.CharField(max_length=20)
    contract = models.CharField(max_length=20)
    paperless_billing = models.BooleanField()
    payment_method = models.CharField(max_length=30)
    monthly_charges = models.DecimalField(max_digits=10, decimal_places=2)
    total_charges = models.DecimalField(max_digits=14, decimal_places=2)
    churn = models.BooleanField()

    class Meta:
        verbose_name_plural = "Telecom customers"  # 복수형 이름 지정
        db_table = 'telecom_customers'  # 테이블 이름도 명시적으로 지정


class SummaryNewsKeywords(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    date = models.DateField()
    keyword = models.TextField()
    title = models.TextField()
    summary = models.TextField()
    url = models.URLField(max_length=500)

    class Meta:
        verbose_name_plural = "Summary news keywords"  # 복수형 이름 지정
        db_table = 'summary_news_keywords'  # 테이블 이름도 명시적으로 지정



    def __str__(self):
        return f"{self.date} - {self.keyword} - {self.title[:50]}..."




--- File Index 33: backend/knowledge/views.py ---
from django.shortcuts import render

# Create your views here.


--- File Index 34: backend/manage.py ---
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()


--- File Index 35: backend/mlops/__init__.py ---


--- File Index 36: backend/mlops/admin.py ---
from django.contrib import admin
from django.utils.html import format_html
from .models import AnalyticsResult, ModelArtifact


@admin.register(AnalyticsResult)
class AnalyticsResultAdmin(admin.ModelAdmin):
    list_display = ('id', 'user', 'result_type', 'created_at', 's3_key_preview')
    list_filter = ('result_type', 'created_at')
    search_fields = ('user__email', 's3_key', 'meta')
    readonly_fields = ('created_at', 'meta_prettified')
    list_select_related = ('user',)
    
    def s3_key_preview(self, obj):
        return obj.s3_key[:50] + '...' if len(obj.s3_key) > 50 else obj.s3_key
    s3_key_preview.short_description = 'S3 Key'
    
    def meta_prettified(self, obj):
        import json
        from pygments import highlight
        from pygments.lexers import JsonLexer
        from pygments.formatters import HtmlFormatter
        from django.utils.safestring import mark_safe
        
        if not obj.meta:
            return ""
            
        response = json.dumps(obj.meta, indent=2, ensure_ascii=False)
        response = response[:5000]  # Limit the size to prevent performance issues
        
        # Truncate and add ellipsis if necessary
        if len(response) > 5000:
            response = response[:5000] + '... (truncated)'
            
        # Format the JSON
        formatter = HtmlFormatter(style='colorful')
        response = highlight(response, JsonLexer(), formatter)
        style = "<style>" + formatter.get_style_defs() + "</style><br>"
        return mark_safe(style + response)
    
    meta_prettified.short_description = 'Metadata'


@admin.register(ModelArtifact)
class ModelArtifactAdmin(admin.ModelAdmin):
    list_display = ('name', 'version', 'stage', 'created_by', 'created_at', 's3_key_preview')
    list_filter = ('stage', 'created_at')
    search_fields = ('name', 'version', 's3_key')
    readonly_fields = ('created_at', 'metrics_prettified')
    list_select_related = ('created_by',)
    
    def s3_key_preview(self, obj):
        return obj.s3_key[:50] + '...' if len(obj.s3_key) > 50 else obj.s3_key
    s3_key_preview.short_description = 'S3 Key'
    
    def metrics_prettified(self, obj):
        if not obj.metrics:
            return ""
            
        import json
        from pygments import highlight
        from pygments.lexers import JsonLexer
        from pygments.formatters import HtmlFormatter
        from django.utils.safestring import mark_safe
        
        response = json.dumps(obj.metrics, indent=2, ensure_ascii=False)
        response = response[:5000]  # Limit the size to prevent performance issues
        
        # Truncate and add ellipsis if necessary
        if len(response) > 5000:
            response = response[:5000] + '... (truncated)'
            
        # Format the JSON
        formatter = HtmlFormatter(style='colorful')
        response = highlight(response, JsonLexer(), formatter)
        style = "<style>" + formatter.get_style_defs() + "</style><br>"
        return mark_safe(style + response)
    
    metrics_prettified.short_description = 'Metrics'


--- File Index 37: backend/mlops/apps.py ---
from django.apps import AppConfig


class MlopsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'mlops'


--- File Index 38: backend/mlops/migrations/0001_initial.py ---
# Generated by Django 5.2.1 on 2025-05-29 05:36

import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='AnalyticsResult',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('result_type', models.CharField(choices=[('churn_pred', 'Churn Prediction'), ('viz_image', 'Visualization Image'), ('timeseries_forecast', 'Time-series Forecast')], max_length=30)),
                ('s3_key', models.TextField()),
                ('meta', models.JSONField(blank=True, null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='analytics_results', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'analytics_results',
                'indexes': [models.Index(fields=['user', 'result_type'], name='idx_analytics_user_type')],
            },
        ),
        migrations.CreateModel(
            name='ModelArtifact',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=120)),
                ('version', models.CharField(default='v1', max_length=50)),
                ('s3_key', models.TextField()),
                ('stage', models.CharField(choices=[('staging', 'Staging'), ('production', 'Production'), ('archived', 'Archived')], default='staging', max_length=20)),
                ('metrics', models.JSONField(blank=True, null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('created_by', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='model_artifacts', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'model_artifacts',
                'ordering': ['-created_at'],
                'indexes': [models.Index(fields=['name', 'stage'], name='idx_model_stage'), models.Index(fields=['created_at'], name='idx_model_created')],
                'unique_together': {('name', 'version')},
            },
        ),
    ]


--- File Index 39: backend/mlops/migrations/__init__.py ---


--- File Index 40: backend/mlops/models.py ---
"""mlops/models.py  –  분석 결과 & 모델 레지스트리"""

import uuid
from django.db import models
from accounts.models import User


class ResultType(models.TextChoices):
    CHURN_PRED = "churn_pred", "Churn Prediction"
    VIZ_IMAGE = "viz_image", "Visualization Image"
    TS_FORECAST = "timeseries_forecast", "Time-series Forecast"


class AnalyticsResult(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="analytics_results")
    result_type = models.CharField(max_length=30, choices=ResultType.choices)
    s3_key = models.TextField()
    meta = models.JSONField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "analytics_results"
        indexes = [models.Index(fields=["user", "result_type"], name="idx_analytics_user_type")]

    def __str__(self):
        return f"{self.result_type} - {self.id}"


class ModelStage(models.TextChoices):
    STAGING = "staging", "Staging"
    PRODUCTION = "production", "Production"
    ARCHIVED = "archived", "Archived"


class ModelArtifact(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=120)
    version = models.CharField(max_length=50, default="v1")
    s3_key = models.TextField()
    stage = models.CharField(max_length=20, choices=ModelStage.choices, default=ModelStage.STAGING)
    metrics = models.JSONField(null=True, blank=True)
    created_by = models.ForeignKey(
        User, null=True, on_delete=models.SET_NULL, related_name="model_artifacts"
    )
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "model_artifacts"
        unique_together = ("name", "version")
        indexes = [
            models.Index(fields=["name", "stage"], name="idx_model_stage"),
            models.Index(fields=["created_at"], name="idx_model_created"),
        ]
        ordering = ["-created_at"]

    def __str__(self):
        return f"{self.name} ({self.version}) - {self.stage}"


--- File Index 41: backend/mlops/modules/nodes/__init__.py ---


--- File Index 42: backend/mlops/views.py ---
from django.shortcuts import render

# Create your views here.


--- File Index 43: backend/path/to/your/app/Makefile ---
.PHONY: all format lint test tests test_watch integration_tests docker_tests help extended_tests

# Default target executed when no arguments are given to make.
all: help

# Define a variable for the test file path.
TEST_FILE ?= tests/unit_tests/

test:
	python -m pytest $(TEST_FILE)

integration_tests:
	python -m pytest tests/integration_tests 

test_watch:
	python -m ptw --snapshot-update --now . -- -vv tests/unit_tests

test_profile:
	python -m pytest -vv tests/unit_tests/ --profile-svg

extended_tests:
	python -m pytest --only-extended $(TEST_FILE)


######################
# LINTING AND FORMATTING
######################

# Define a variable for Python and notebook files.
PYTHON_FILES=src/
MYPY_CACHE=.mypy_cache
lint format: PYTHON_FILES=.
lint_diff format_diff: PYTHON_FILES=$(shell git diff --name-only --diff-filter=d main | grep -E '\.py$$|\.ipynb$$')
lint_package: PYTHON_FILES=src
lint_tests: PYTHON_FILES=tests
lint_tests: MYPY_CACHE=.mypy_cache_test

lint lint_diff lint_package lint_tests:
	python -m ruff check .
	[ "$(PYTHON_FILES)" = "" ] || python -m ruff format $(PYTHON_FILES) --diff
	[ "$(PYTHON_FILES)" = "" ] || python -m ruff check --select I $(PYTHON_FILES)
	[ "$(PYTHON_FILES)" = "" ] || python -m mypy --strict $(PYTHON_FILES)
	[ "$(PYTHON_FILES)" = "" ] || mkdir -p $(MYPY_CACHE) && python -m mypy --strict $(PYTHON_FILES) --cache-dir $(MYPY_CACHE)

format format_diff:
	ruff format $(PYTHON_FILES)
	ruff check --select I --fix $(PYTHON_FILES)

spell_check:
	codespell --toml pyproject.toml

spell_fix:
	codespell --toml pyproject.toml -w

######################
# HELP
######################

help:
	@echo '----'
	@echo 'format                       - run code formatters'
	@echo 'lint                         - run linters'
	@echo 'test                         - run unit tests'
	@echo 'tests                        - run unit tests'
	@echo 'test TEST_FILE=<test_file>   - run all tests in file'
	@echo 'test_watch                   - run unit tests in watch mode'



--- File Index 44: backend/path/to/your/app/README.md ---
# New LangGraph Project

[![CI](https://github.com/langchain-ai/new-langgraph-project/actions/workflows/unit-tests.yml/badge.svg)](https://github.com/langchain-ai/new-langgraph-project/actions/workflows/unit-tests.yml)
[![Integration Tests](https://github.com/langchain-ai/new-langgraph-project/actions/workflows/integration-tests.yml/badge.svg)](https://github.com/langchain-ai/new-langgraph-project/actions/workflows/integration-tests.yml)

This template demonstrates a simple application implemented using [LangGraph](https://github.com/langchain-ai/langgraph), designed for showing how to get started with [LangGraph Server](https://langchain-ai.github.io/langgraph/concepts/langgraph_server/#langgraph-server) and using [LangGraph Studio](https://langchain-ai.github.io/langgraph/concepts/langgraph_studio/), a visual debugging IDE.

<div align="center">
  <img src="./static/studio_ui.png" alt="Graph view in LangGraph studio UI" width="75%" />
</div>

The core logic defined in `src/agent/graph.py`, showcases an single-step application that responds with a fixed string and the configuration provided.

You can extend this graph to orchestrate more complex agentic workflows that can be visualized and debugged in LangGraph Studio.

## Getting Started

<!--
Setup instruction auto-generated by `langgraph template lock`. DO NOT EDIT MANUALLY.
-->

<!--
End setup instructions
-->

1. Install dependencies, along with the [LangGraph CLI](https://langchain-ai.github.io/langgraph/concepts/langgraph_cli/), which will be used to run the server.

```bash
cd path/to/your/app
pip install -e . "langgraph-cli[inmem]"
```

2. (Optional) Customize the code and project as needed. Create a `.env` file if you need to use secrets.

```bash
cp .env.example .env
```

If you want to enable LangSmith tracing, add your LangSmith API key to the `.env` file.

```text
# .env
LANGSMITH_API_KEY=lsv2...
```

3. Start the LangGraph Server.

```shell
langgraph dev
```

For more information on getting started with LangGraph Server, [see here](https://langchain-ai.github.io/langgraph/tutorials/langgraph-platform/local-server/).

## How to customize

1. **Define configurable parameters**: Modify the `Configuration` class in the `graph.py` file to expose the arguments you want to configure. For example, in a chatbot application you may want to define a dynamic system prompt or LLM to use. For more information on configurations in LangGraph, [see here](https://langchain-ai.github.io/langgraph/concepts/low_level/?h=configuration#configuration).

2. **Extend the graph**: The core logic of the application is defined in [graph.py](./src/agent/graph.py). You can modify this file to add new nodes, edges, or change the flow of information.

## Development

While iterating on your graph in LangGraph Studio, you can edit past state and rerun your app from previous states to debug specific nodes. Local changes will be automatically applied via hot reload.

Follow-up requests extend the same thread. You can create an entirely new thread, clearing previous history, using the `+` button in the top right.

For more advanced features and examples, refer to the [LangGraph documentation](https://langchain-ai.github.io/langgraph/). These resources can help you adapt this template for your specific use case and build more sophisticated conversational agents.

LangGraph Studio also integrates with [LangSmith](https://smith.langchain.com/) for more in-depth tracing and collaboration with teammates, allowing you to analyze and optimize your chatbot's performance.

<!--
Configuration auto-generated by `langgraph template lock`. DO NOT EDIT MANUALLY.
{
  "config_schemas": {
    "agent": {
      "type": "object",
      "properties": {}
    }
  }
}
-->


--- File Index 45: backend/path/to/your/app/src/agent/__init__.py ---
"""New LangGraph Agent.

This module defines a custom graph.
"""

from agent.graph import graph

__all__ = ["graph"]


--- File Index 46: backend/path/to/your/app/src/agent/graph.py ---
"""LangGraph single-node graph template.

Returns a predefined response. Replace logic and configuration as needed.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, TypedDict

from langchain_core.runnables import RunnableConfig
from langgraph.graph import StateGraph


class Configuration(TypedDict):
    """Configurable parameters for the agent.

    Set these when creating assistants OR when invoking the graph.
    See: https://langchain-ai.github.io/langgraph/cloud/how-tos/configuration_cloud/
    """

    my_configurable_param: str


@dataclass
class State:
    """Input state for the agent.

    Defines the initial structure of incoming data.
    See: https://langchain-ai.github.io/langgraph/concepts/low_level/#state
    """

    changeme: str = "example"


async def call_model(state: State, config: RunnableConfig) -> Dict[str, Any]:
    """Process input and returns output.

    Can use runtime configuration to alter behavior.
    """
    configuration = config["configurable"]
    return {
        "changeme": "output from call_model. "
        f'Configured with {configuration.get("my_configurable_param")}'
    }


# Define the graph
graph = (
    StateGraph(State, config_schema=Configuration)
    .add_node(call_model)
    .add_edge("__start__", "call_model")
    .compile(name="New Graph")
)


--- File Index 47: fastapi_server/README.md ---
# LangGraph Agent FastAPI Server

이 프로젝트는 LangGraph 기반 멀티 에이전트 시스템을 FastAPI 웹 서버로 서빙하는 어플리케이션입니다.

## 프로젝트 구조

```
fastapi_server/
├── __init__.py          # 패키지 초기화 파일
├── main.py              # FastAPI 애플리케이션 메인 파일
├── agent_service.py     # LangGraph 에이전트와의 인터페이스
├── models.py            # API 요청/응답 모델
├── requirements.txt     # 필요한 의존성
├── start_server.py      # 서버 실행 스크립트
└── README.md            # 이 문서
```

## 설치 및 실행 방법

### 1. 가상 환경 설정

항상 가상 환경을 사용하는 것이 좋습니다. 가상 환경을 생성하고 활성화하세요:

```bash
# 가상 환경 생성
python -m venv venv

# 가상 환경 활성화 (Windows)
venv\Scripts\activate

# 가상 환경 활성화 (Linux/Mac)
source venv/bin/activate
```

### 2. 의존성 설치

필요한 패키지를 설치합니다:

```bash
pip install -r requirements.txt
```

### 3. 환경 변수 설정

프로젝트 루트 디렉토리에 `.env` 파일이 있는지 확인하세요. 다음과 같은 환경 변수가 필요합니다:

```
OPENAI_API_KEY=your_openai_api_key_here
```

### 4. 서버 실행

다음 명령을 사용하여 서버를 시작합니다:

```bash
# 방법 1: start_server.py 스크립트 사용
python start_server.py

# 방법 2: uvicorn 직접 사용
uvicorn fastapi_server.main:app --host 0.0.0.0 --port 8001 --reload
```

서버가 성공적으로 시작되면 http://localhost:8001 에서 접근할 수 있습니다.

## API 엔드포인트

### 1. 상태 확인

- **URL**: GET /
- **응답**: 서버 상태 정보

### 2. 채팅 메시지 전송

- **URL**: POST /api/chat
- **요청 본문**:
  ```json
  {
    "message": "사용자 메시지",
    "thread_id": "선택적_대화_ID"
  }
  ```
- **응답**: 에이전트 응답

### 3. WebSocket 스트리밍 채팅

- **URL**: WebSocket /api/chat/ws/{thread_id}
- **사용법**: 
  - 연결 후, JSON 형식의 메시지 전송: `{"message": "사용자 메시지"}`
  - 서버는 다양한 이벤트 타입을 포함한 JSON 응답을 스트리밍합니다.
  - 이벤트 타입: `token`, `agent_change`, `tool_start`, `tool_end`, `done`, `error`

## 예제 사용 코드

### HTTP API 사용 예제 (Python)

```python
import requests

response = requests.post(
    "http://localhost:8001/api/chat",
    json={"message": "지역별 매출을 분석해줘"}
)
print(response.json())
```

### WebSocket 스트리밍 예제 (JavaScript)

```javascript
const ws = new WebSocket('ws://localhost:8001/api/chat/ws/my-thread-1');

ws.onopen = () => {
  console.log('Connected to server');
  ws.send(JSON.stringify({
    message: '데이터 시각화를 도와줘'
  }));
};

ws.onmessage = (event) => {
  const data = JSON.parse(event.data);
  console.log(data);
  
  if (data.type === 'token') {
    // 토큰 처리 (점진적으로 UI에 텍스트 추가)
    process.stdout.write(data.content);
  } else if (data.type === 'agent_change') {
    console.log(`Agent changed to: ${data.agent}`);
  } else if (data.type === 'done') {
    console.log('\nResponse complete!');
  }
};
```

## 문제 해결

1. **ImportError**: 필요한 모듈을 찾지 못하는 경우, 가상 환경이 활성화되어 있고 모든 의존성이 설치되어 있는지 확인하세요.

2. **API 키 오류**: OPENAI_API_KEY가 올바르게 설정되어 있는지 확인하세요.

3. **포트 충돌**: 8001 포트가 이미 사용 중인 경우, `main.py`에서 포트 번호를 변경하세요.


--- File Index 48: fastapi_server/__init__.py ---
# FastAPI server package for LangGraph Agent


--- File Index 49: fastapi_server/agent/__init__.py ---
# fastapi_server/agent package


--- File Index 50: fastapi_server/agent/agent2.py ---
from __future__ import annotations

import os
from dataclasses import dataclass
from typing import TypedDict, Dict, Sequence, Union, Optional, Any
import asyncio

from asgiref.sync import sync_to_async
from langchain_core.prompts import PromptTemplate, SystemMessagePromptTemplate,HumanMessagePromptTemplate,ChatPromptTemplate
from langchain_openai import ChatOpenAI
from langgraph.graph import END, START, StateGraph
from dotenv import load_dotenv
from openai import OpenAI
from pinecone import Pinecone, ServerlessSpec
from langchain.chat_models import ChatOpenAI
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage
from langgraph.graph.message import add_messages
from fastapi_server.agent.prompt import (
    document_type_system_prompt_agent2,
    proceedings_summary_prompt_agent2,
    internal_policy_summary_prompt_template_agent2,
    product_document_summary_prompt_template_agent2,
    technical_document_summary_prompt_template_agent2,
    unknown_document_type_prompt_agent2,
    rag_answer_generation_prompt_agent2,
    rag_system_message_agent2
)
load_dotenv()

def init_clients():
    # 1-1) OpenAI 클라이언트 생성
    openai_api_key = os.getenv("OPENAI_API_KEY")
    if not openai_api_key:
        raise ValueError("⚠️ 환경변수 OPENAI_API_KEY가 설정되지 않았습니다.")
    # OpenAI 인스턴스를 만듭니다.
    openai_client = OpenAI(api_key=openai_api_key)
    print("✅ OpenAI 클라이언트 생성 완료")

    # 1-2) Pinecone 인스턴스 생성
    pinecone_api_key = os.getenv("PINECONE_API_KEY")
    pinecone_env     = os.getenv("PINECONE_ENVIRONMENT")   # 예: "us-east1-gcp" 또는 "us-west1-gcp" 등
    if not pinecone_api_key or not pinecone_env:
        raise ValueError("⚠️ 환경변수 PINECONE_API_KEY 또는 PINECONE_ENVIRONMENT가 누락되었습니다.")

    pc = Pinecone(api_key=pinecone_api_key, environment=pinecone_env)
    print("✅ Pinecone 클라이언트 생성 완료")

    # 1-3) 인덱스 존재 여부 확인
    index_name = "dense-index"  # 실제 사용 중인 인덱스 이름으로 교체하세요
    existing_indexes = pc.list_indexes().names()
    if index_name not in existing_indexes:
        raise ValueError(f"⚠️ 인덱스 '{index_name}'가 Pinecone에 존재하지 않습니다. 현재 인덱스 목록: {existing_indexes}")

    # 1-4) 해당 인덱스 객체 가져오기
    index = pc.Index(index_name)
    print(f"✅ Pinecone 인덱스 '{index_name}' 연결 완료 (Namespaces: {len(index.describe_index_stats().namespaces)})")

    return openai_client, index


# --------------------------------------------------
# 2) 질문 문장을 임베딩 벡터로 변환
# --------------------------------------------------
def embed_query(openai_client: OpenAI, text: str) -> list:
    """
    최신 OpenAI 클라이언트에서는 resp.data[0].embedding 으로 벡터에 접근해야 합니다.
    """
    resp = openai_client.embeddings.create(
        model="text-embedding-3-large",
        input=text
    )
    return resp.data[0].embedding


# --------------------------------------------------
# 3) 여러 네임스페이스 중 “가장 높은 유사도”를 준 네임스페이스와 매칭 결과 반환
# --------------------------------------------------
def retrieve_best_namespace(index, query_vector: list, top_k: int = 5):
    """
    1) index.describe_index_stats()를 통해 모든 네임스페이스 목록을 얻는다.
    2) 각 네임스페이스별로 query_vector를 index.query()로 검색하고,
       matches[0].score 를 비교해서 “최고 유사도”를 찾는다.
    3) 가장 높은 유사도를 준 네임스페이스(best_ns)와 해당 네임스페이스의 전체 매칭 결과(best_matches)를 반환.
    """
    stats = index.describe_index_stats()
    available_namespaces = list(stats.namespaces.keys())
    if not available_namespaces:
        raise ValueError("⚠️ 인덱스에 네임스페이스가 없습니다.")

    best_ns = None
    best_score = -1.0
    best_matches = None

    for ns in available_namespaces:
        count = stats.namespaces[ns]["vector_count"]
        if count == 0:
            # 비어 있는 네임스페이스 건너뛰기
            continue

        res = index.query(
            vector=query_vector,
            namespace=ns,
            top_k=top_k,
            include_metadata=True
        )
        if not res.matches:
            continue

        top_score = res.matches[0].score
        if top_score > best_score:
            best_score = top_score
            best_ns = ns
            best_matches = res.matches

    if best_ns is None:
        raise ValueError("⚠️ 어떤 네임스페이스에서도 매칭 결과를 찾을 수 없습니다.")
    
    print(f"🔍 선택된 네임스페이스: '{best_ns}' (최고 유사도: {best_score:.4f})")
    return best_ns, best_matches


# --------------------------------------------------
# 4) 검색된 매칭 결과에서 실제 텍스트(메타데이터)를 꺼내 Context 로 결합
# --------------------------------------------------
def build_context_from_matches(matches):
    """
    res.matches 리스트 안의 각 item.metadata 에 들어 있는 텍스트 필드를 추출합니다.
    업로드 시 metadata 키가 "text"였다고 가정했습니다.
    """
    contexts = []
    for m in matches:
        chunk_text = m.metadata.get("text", "")
        if chunk_text:
            contexts.append(chunk_text)

    return "\n---\n".join(contexts)


# --------------------------------------------------
# 5) LLM ChatCompletion 호출하여 답변 생성
# --------------------------------------------------
def generate_answer_with_context(openai_client: OpenAI, question: str, context: str) -> str:
    """
    최신 OpenAI 클라이언트에서는 client.chat.completions.create(...) 형태를 씁니다.
    """
    formatted_prompt = rag_answer_generation_prompt_agent2.format(context=context, question=question)
    resp = openai_client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {"role": "system", "content": rag_system_message_agent2},
            {"role": "user", "content": formatted_prompt}
        ],
        temperature=0.0,
        max_tokens=1024
    )
    # resp.choices[0].message.content 으로 답변 추출
    return resp.choices[0].message.content.strip()



@dataclass
class State:
    # Compatible with both direct user_input and messages-based interface
    user_input: str = ""
    document_type: str = ""
    result: str = ""
    messages: Sequence[BaseMessage] = None
    
    def __post_init__(self):
        # If initialized from supervisor with messages but no user_input, extract user_input
        if not self.user_input and self.messages:
            # Extract user input from the last human message
            user_messages = [msg for msg in self.messages if isinstance(msg, HumanMessage)]
            if user_messages:
                self.user_input = user_messages[-1].content
    
    def dict(self):
        """Return dict representation with messages if present"""
        result = {
            "result": self.result,
            "document_type": self.document_type,
            "user_input": self.user_input
        }
        # If this was called with messages, return updated messages too
        if self.messages is not None:
            result["messages"] = self.messages + [AIMessage(content=self.result)] if self.result else self.messages
        return result  # 챗봇 결과


def choose_document_type(message):
    """
    OpenAI 클라이언트를 사용하여 문서 타입을 분류합니다. 리턴 데이터 형식은 기존과 동일하게 유지합니다.
    """
    client = OpenAI()
    formatted_prompt = document_type_system_prompt_agent2.format(user_input=message)
    
    resp = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {"role": "system", "content": formatted_prompt}
        ],
        temperature=0,
        max_tokens=100
    )
    
    classified_type = resp.choices[0].message.content.strip()
    print(f"문서 타입 분류 결과: {classified_type}")
    return classified_type

def choose_node(state: State):
    # Extract the user input from the state
    user_input = state.user_input

    # Choose document type
    document_type = choose_document_type(user_input)
    
    # Update state with document type
    state.document_type = document_type
    
    # Print document type for debugging
    # print(f"Document Type: {document_type}")
    
    return state.dict()

def choose_one(state: State) -> str:
    choice = state.document_type
    # Use logging instead of print to avoid output being captured in response
    # print(f"(choice_one) Choice: {choice}")
    # This must return the string key for conditional edge routing
    if choice in ["internal_policy", "product_document", "technical_document", "proceedings"]:
        return choice
    else:
        return "product_document"  # Default fallback

def execute_rag(state: State):
    # print(f"\n📄 RAG 노드 실행: 문서 타입 = '{state.document_type}', 질문 = '{state.user_input}'")
    openai_client, pinecone_index = init_clients()
    # print("   - 클라이언트 초기화 완료")

    query_vector = embed_query(openai_client, state.user_input)
    # print(f"   - 질문 임베딩 완료 (벡터 크기: {len(query_vector)})")

    namespace_to_search = state.document_type
    if not namespace_to_search or namespace_to_search == "unknown":
        message = f"문서 타입이 '{namespace_to_search}'(으)로 분류되어 Pinecone 검색을 수행하지 않습니다."
        # print(f"   - 정보: {message}")
        # 'unknown'일 경우, unknown_handler_node에서 이미 메시지를 설정했을 수 있으므로, 여기서는 덮어쓰지 않거나
        # 혹은 여기서 다른 메시지를 설정할 수 있습니다. 여기서는 검색 불가 메시지만 남깁니다.
        # 실제로는 'unknown' 타입은 이 노드로 오지 않고 unknown_handler_node로 가야 합니다.
        # 이 코드는 execute_rag_node가 'unknown' 타입으로 호출될 경우를 대비한 방어 코드입니다.
        state.result = "적절한 문서 저장소를 찾을 수 없어 검색을 수행할 수 없습니다."
        return state.dict()

    # print(f"   - Pinecone 네임스페이스 '{namespace_to_search}'에서 검색 시작...")
    index_stats = pinecone_index.describe_index_stats()
    if namespace_to_search not in index_stats.namespaces or \
        index_stats.namespaces[namespace_to_search].vector_count == 0:
        message = f"'{namespace_to_search}' 네임스페이스를 Pinecone에서 찾을 수 없거나, 해당 네임스페이스에 데이터가 없습니다. Pinecone 대시보드에서 네임스페이스 이름과 데이터 존재 여부를 확인해주세요."
        # print(f"   - 경고: {message}")
        state.result = message
        return state.dict()

    res = pinecone_index.query(
        vector=query_vector,
        namespace=namespace_to_search,
        top_k=5, # 검색할 문서 수
        include_metadata=True
    )
    matches = res.matches
    # print(f"   - Pinecone 검색 완료: {len(matches)}개 결과 수신")

    if not matches:
        message = f"'{namespace_to_search}' 네임스페이스에서 '{state.user_input}' 질문과 관련된 정보를 찾지 못했습니다."
        # print(f"   - 정보 없음: {message}")
        state.result = message
        return state.dict()
    
    context = build_context_from_matches(matches)
    if not context:
        message = "검색된 정보에서 답변을 생성할 컨텍스트를 추출하지 못했습니다."
        print(f"   - 컨텍스트 구축 실패: {message}")
        state.result = message
        return state.dict()
    print(f"   - 컨텍스트 구축 완료 (길이: {len(context)})")

    state.result = context
    return state.dict()
    

def summarize_node(state: State):
    text = state.result
    document_type = state.document_type
    user_input = state.user_input

    if state.document_type == "proceedings":
        system_message = proceedings_summary_prompt_agent2
    elif state.document_type == "internal_policy":
        system_message = internal_policy_summary_prompt_template_agent2.format(user_input=user_input)
    elif state.document_type == "product_document":
        system_message = product_document_summary_prompt_template_agent2.format(user_input=user_input)
    elif state.document_type == "technical_document":
        system_message = technical_document_summary_prompt_template_agent2.format(user_input=user_input)
    else: # unknown or fallback
        system_message = unknown_document_type_prompt_agent2
    
    system_message = SystemMessagePromptTemplate.from_template(system_message)
    human_message = HumanMessagePromptTemplate.from_template("{text}")

    chat_prompt = ChatPromptTemplate.from_messages([system_message, human_message])

    # 2. LLM 생성
    llm = ChatOpenAI(model="gpt-4o")

    # 3. Prompt와 LLM 결합
    chatbot = chat_prompt | llm

    # 4. 실행
    response = chatbot.invoke({"text": text})
    result = response.content
    # print(result)  # 디버깅용 출력 제거
    state.result = result
    
    # 문서 타입이 최종 결과에 포함되지 않도록, document_type을 제외한 상태만 반환
    result_state = state.dict()
    if "document_type" in result_state:
        # document_type 값이 최종 출력에 포함되지 않도록 제거
        del result_state["document_type"]
    
    return result_state

# 비동기 노드 래퍼 함수들 정의
async def async_choose_node(state: State):
    return await sync_to_async(choose_node)(state)

async def async_execute_rag(state: State):
    return await sync_to_async(execute_rag)(state)

async def async_summarize_node(state: State):
    return await sync_to_async(summarize_node)(state)

async def async_choose_one(state: State):
    return await sync_to_async(choose_one)(state)

# Define the graph with async nodes
graph = (
    StateGraph(State)
    # (1) choose_node 분기 노드 등록 (outputs에 리턴 키 명시)
    .add_node("choose_node", async_choose_node)
    # (2) RAG 실행 노드들 등록
    .add_node("product_node", async_execute_rag)
    .add_node("proceedings_node", async_execute_rag)
    .add_node("hr_policy_node", async_execute_rag)
    .add_node("technical_document_node", async_execute_rag)
    # (3) summarize_node 등록 (최종 노드)
    .add_node("summarize_node", async_summarize_node)
    # (4) START → 분기 노드(choose_node) → (next_node 값에 따라) 분기
    .add_edge(START,"choose_node")
    .add_conditional_edges(
        "choose_node",
        async_choose_one,
        {
            "product_document": "product_node",
            "proceedings": "proceedings_node",
            "internal_policy": "hr_policy_node",
            "technical_document": "technical_document_node"
        }
    )
    # (5) 각 RAG 노드 → summarize_node 연결
    .add_edge("product_node", "summarize_node")
    .add_edge("proceedings_node", "summarize_node")
    .add_edge("hr_policy_node", "summarize_node")
    .add_edge("technical_document_node", "summarize_node")
    .add_edge("summarize_node", END)
    # (6) 최종 컴파일
    .compile(name="New Graph")
)



Based on the provided codebase, identify the key abstractions that are central to understanding this project. 
These abstractions should represent the core components, modules, or concepts.

Desired output format is a YAML list of objects, where each object has:
- 'name': A concise name for the abstraction (in korean).
- 'description': A brief explanation of what this abstraction represents and its role (in korean).
- 'file_indices': A list of integer file indices that are most relevant to this abstraction. Choose from the file list above.

Return at most 10 key abstractions.

Example for a different project (simple web server):
```yaml
- name: "HTTP 요청 핸들러 (HTTP Request Handler)"
  description: "수신 HTTP 요청을 처리하고 적절한 응답을 생성하는 구성 요소입니다. (Component that processes incoming HTTP requests and generates appropriate responses.)"
  file_indices: [0, 2]
- name: "라우팅 설정 (Routing Configuration)"
  description: "URL 경로를 특정 요청 핸들러 함수에 매핑하는 규칙을 정의합니다. (Defines rules for mapping URL paths to specific request handler functions.)"
  file_indices: [1]
```

Your response should be only the YAML list, enclosed in triple backticks (```yaml ... ```).
Ensure the output is valid YAML.

2025-06-30 00:17:17,458 - INFO - RESPONSE (from cache): ```yaml
- name: "AI 에이전트 총괄 시스템 (LangGraph Supervisor)"
  description: "사용자의 자연어 요청을 분석하여 적합한 전문 에이전트에 작업을 분배하는 시스템입니다. (System that analyzes user natural language requests and routes tasks to appropriate specialized agents.)"
  file_indices: [0, 44, 46, 50]

- name: "문서 검색 전문 에이전트 (RAG Agent)"
  description: "사용자의 질문에 대해 회사 내부 문서를 검색하고 답변을 생성하는 에이전트입니다. (Agent that retrieves and generates answers based on company internal documents in response to user queries.)"
  file_indices: [46, 50]

- name: "데이터 분석 전문 에이전트 (Analytics Agent)"
  description: "사용자의 질문을 바탕으로 데이터베이스를 검색, 분석하여 정보를 제공하는 에이전트입니다. (Agent that analyzes and provides insights from the database based on user queries.)"
  file_indices: [0, 40, 46]

- name: "FastAPI 서버"
  description: "실시간 AI 통신을 처리하며, 사용자와 AI 시스템 간의 데이터 교환을 담당하는 서버입니다. (Server that handles real-time AI communication and exchanges data between users and AI systems.)"
  file_indices: [47, 50]

- name: "계정 관리 모듈 (Accounts Module)"
  description: "사용자와 조직 정보를 관리하고 인증 처리 기능을 제공하는 모듈입니다. (Module that manages user and organization information and provides authentication functions.)"
  file_indices: [1, 2, 3, 6, 7, 9]

- name: "챗봇 세션 관리 (Chat Session Management)"
  description: "사용자의 대화 세션과 메시지를 관리하고 저장하는 구성 요소입니다. (Component that manages and stores user chat sessions and messages.)"
  file_indices: [22, 25, 23]

- name: "지식베이스 관리 (Knowledge Management)"
  description: "조직의 문서와 임베딩 데이터를 관리하며, 문서 검색을 지원합니다. (Management of organization documents and embedding data, supporting document retrieval.)"
  file_indices: [26, 27, 32]

- name: "MLOps 관리 (MLOps Management)"
  description: "분석 결과와 모델 아티팩트를 관리하고 추적하는 시스템입니다. (System that manages and tracks analytics results and model artifacts.)"
  file_indices: [36, 40]

- name: "환경 설정 및 배포 (Environment Setup and Deployment)"
  description: "프로젝트의 환경 설정과 관련된 파일 및 배포 절차를 정의합니다. (Defines environment setup files and deployment procedures.)"
  file_indices: [12, 34, 43]

- name: "백엔드 라우팅 (Backend Routing)"
  description: "Django를 통해 백엔드 API 경로와 뷰를 설정하고 관리합니다. (Configures and manages backend API routes and views using Django.)"
  file_indices: [13, 8, 24]
```
2025-06-30 00:17:17,825 - INFO - PROMPT: 
Based on the following abstractions and relevant code snippets from the project `SKN10-FINAL-1Team`:

List of Abstraction Indices and Names (Names might be in Korean):
0 # AI 에이전트 총괄 시스템 (LangGraph Supervisor)
1 # 문서 검색 전문 에이전트 (RAG Agent)
2 # 데이터 분석 전문 에이전트 (Analytics Agent)
3 # FastAPI 서버
4 # 계정 관리 모듈 (Accounts Module)
5 # 챗봇 세션 관리 (Chat Session Management)
6 # 지식베이스 관리 (Knowledge Management)
7 # MLOps 관리 (MLOps Management)
8 # 환경 설정 및 배포 (Environment Setup and Deployment)
9 # 백엔드 라우팅 (Backend Routing)

Context (Abstractions, Descriptions, Code):
Identified Abstractions:
- Index 0: AI 에이전트 총괄 시스템 (LangGraph Supervisor) (Relevant file indices: [0, 44, 46, 50])
  Description: 사용자의 자연어 요청을 분석하여 적합한 전문 에이전트에 작업을 분배하는 시스템입니다. (System that analyzes user natural language requests and routes tasks to appropriate specialized agents.)
- Index 1: 문서 검색 전문 에이전트 (RAG Agent) (Relevant file indices: [46, 50])
  Description: 사용자의 질문에 대해 회사 내부 문서를 검색하고 답변을 생성하는 에이전트입니다. (Agent that retrieves and generates answers based on company internal documents in response to user queries.)
- Index 2: 데이터 분석 전문 에이전트 (Analytics Agent) (Relevant file indices: [0, 40, 46])
  Description: 사용자의 질문을 바탕으로 데이터베이스를 검색, 분석하여 정보를 제공하는 에이전트입니다. (Agent that analyzes and provides insights from the database based on user queries.)
- Index 3: FastAPI 서버 (Relevant file indices: [47, 50])
  Description: 실시간 AI 통신을 처리하며, 사용자와 AI 시스템 간의 데이터 교환을 담당하는 서버입니다. (Server that handles real-time AI communication and exchanges data between users and AI systems.)
- Index 4: 계정 관리 모듈 (Accounts Module) (Relevant file indices: [1, 2, 3, 6, 7, 9])
  Description: 사용자와 조직 정보를 관리하고 인증 처리 기능을 제공하는 모듈입니다. (Module that manages user and organization information and provides authentication functions.)
- Index 5: 챗봇 세션 관리 (Chat Session Management) (Relevant file indices: [22, 25, 23])
  Description: 사용자의 대화 세션과 메시지를 관리하고 저장하는 구성 요소입니다. (Component that manages and stores user chat sessions and messages.)
- Index 6: 지식베이스 관리 (Knowledge Management) (Relevant file indices: [26, 27, 32])
  Description: 조직의 문서와 임베딩 데이터를 관리하며, 문서 검색을 지원합니다. (Management of organization documents and embedding data, supporting document retrieval.)
- Index 7: MLOps 관리 (MLOps Management) (Relevant file indices: [36, 40])
  Description: 분석 결과와 모델 아티팩트를 관리하고 추적하는 시스템입니다. (System that manages and tracks analytics results and model artifacts.)
- Index 8: 환경 설정 및 배포 (Environment Setup and Deployment) (Relevant file indices: [12, 34, 43])
  Description: 프로젝트의 환경 설정과 관련된 파일 및 배포 절차를 정의합니다. (Defines environment setup files and deployment procedures.)
- Index 9: 백엔드 라우팅 (Backend Routing) (Relevant file indices: [13, 8, 24])
  Description: Django를 통해 백엔드 API 경로와 뷰를 설정하고 관리합니다. (Configures and manages backend API routes and views using Django.)

Relevant File Snippets (Referenced by Index and Path):
--- File: 0 # README.md ---
## TSKN10-FINAL-1Team

## 프로젝트 개요
이 프로젝트는 사용자가 채팅으로 업무를 요청할 수 있는 **지능형 사내 업무 보조 챗봇 시스템**입니다. 사용자의 질문 의도를 **AI 에이전트 총괄 시스템 LangGraph Supervisor**이 파악하여 적절한 전문 에이전트에게 작업을 분배합니다. 마치 오케스트라의 지휘자처럼, 슈퍼바이저는 전체적인 요청을 보고 적임자(에이전트)를 찾아 지시를 내립니다. 예를 들어, 회사 규정 관련 질문은 **문서 검색 전문 에이전트 RAG Agent**에게, 데이터 분석 요청은 **데이터 분석 전문 에이전트 Analytics Agent**에게 전달됩니다. 코드 관련 질문은 **코드 분석 에이전트**가 담당할 수 있습니다. 모든 데이터는 **애플리케이션 데이터 설계도 Django 모델**에 따라 체계적으로 저장되며, 프론트엔드는 **실시간 AI 통신 게이트웨이 FastAPI & WebSocket**를 통해 AI 시스템과 매끄럽게 연결되어 AI 답변 생성 과정을 실시간으로 보여줍니다 (스트리밍). 이 시스템은 복잡한 내부 구조를 몰라도 사용자가 AI를 사람과 대화하듯 편안하게 사용할 수 있도록 설계되었습니다.

## 핵심 기능
*   **AI 에이전트 총괄 시스템 LangGraph Supervisor**: 사용자의 자연어 요청을 분석하여 가장 적합한 전문 에이전트 노드에게 작업을 라우팅하는 역할을 합니다. 슈퍼바이저는 특정 '업무 지침서'(Prompt)를 바탕으로 다음 에이전트를 결정합니다.
*   **문서 검색 전문 에이전트 RAG Agent**: 회사 내부 문서(정책, 매뉴얼, 회의록 등)에 대한 사용자의 질문에 답변합니다. Retrieval-Augmented Generation (RAG) 기술을 사용하며, 질문과 관련 있는 문서 조각을 **임베딩**과 **벡터 데이터베이스 Pinecone**를 통해 먼저 검색한 뒤(Retrieval), 그 내용을 바탕으로 답변을 생성합니다(Generation).
*   **데이터 분석 전문 에이전트 Analytics Agent**: 데이터베이스에 저장된 데이터를 분석하고 통찰력을 제공합니다. 사용자의 자연어 질문을 컴퓨터가 이해하는 SQL 쿼리로 변환하고 데이터베이스에서 실행하여 결과를 가져옵니다. 결과는 텍스트로 요약되거나 **Mermaid 차트** 코드로 시각화됩니다. (논의를 통해 시계열 예측보다는 이상치 모델링 방향으로 고려되었습니다).
*   **코드 분석 에이전트 Code Agent** (논의 중): GitHub 저장소나 사내 코드 베이스의 내용을 분석하고 질의응답하는 것을 목표로 합니다. 코드의 오류 부분을 파악하거나, 특정 함수의 사용 위치나 상호작용하는 파일을 알려주고, 도큐멘테이션을 참고하여 질문에 답변할 수 있습니다. 필요에 따라 코드 변환 기능도 포함될 수 있습니다. 사용자의 코드 언어 버전 탐지 및 해당 버전에 맞는 답변 제공이 중요하게 고려됩니다.
*   **실시간 AI 통신 게이트웨이 FastAPI & WebSocket**: 사용자의 브라우저과 AI 시스템을 연결하는 통신 다리 역할을 합니다. **WebSocket**을 통해 한 번 연결되면 끊기지 않는 '전화 통화'처럼 실시간으로 데이터를 주고받으며, **FastAPI**가 이 통신을 효율적으로 처리합니다. 이를 통해 AI 답변 생성 과정을 실시간 스트리밍으로 사용자에게 보여줍니다.
*   **외부 데이터 수집 및 처리 ETL**: AI 에이전트가 사용할 데이터(고객 정보, 뉴스, 문서 등)를 외부에서 가져와(Extract) 시스템이 사용하기 좋은 형태로 가공한 뒤(Transform), 데이터베이스나 벡터 저장소에 저장하는(Load) 자동화된 스크립트(파이프라인)를 의미합니다. tools 및 lambda 폴더의 파이썬 스크립트가 이 역할을 수행합니다. (CSV 파일의 고객 데이터, 최신 뉴스, 문서 파일(PDF, HTML) 텍스트 및 벡터 변환 등을 처리합니다).
*   **프론트엔드 채팅 UI**: 사용자가 AI와 직접 소통하고 눈으로 볼 수 있는 '얼굴'입니다. 메시지 입력창, 대화 내용이 보이는 말풍선(메시지 목록), 과거 대화 목록을 보여주는 사이드바 등으로 구성됩니다. React(Next.js)의 useState 기능을 사용하여 UI 상태를 관리하고, 서버로부터 받은 메시지를 화면에 그려줍니다.

## 기술 스택
*   **백엔드/AI**:
    *   웹 프레임워크: ![Django](https://img.shields.io/badge/Django-092E20?style=flat-square&logo=django&logoColor=white) (애플리케이션 데이터 설계 및 전통적인 API 연동)
    *   AI 통신 게이트웨이: ![FastAPI](https://img.shields.io/badge/FastAPI-009688?style=flat-square&logo=fastapi&logoColor=white) (실시간 통신 처리 및 에이전트 시스템 연동)
    *   실시간 통신: ![WebSocket](https://img.shields.io/badge/WebSocket-4353FF?style=flat-square&logo=socketdotio&logoColor=white)
    *   AI 오케스트레이션: ![LangGraph](https://img.shields.io/badge/LangGraph-FF5A5F?style=flat-square&logo=langchain&logoColor=white) (다양한 에이전트들의 작업 흐름 및 협업 설계)
    *   LLM: ![GPT](https://img.shields.io/badge/GPT-74aa9c?style=flat-square&logo=openai&logoColor=white) (주요 모델), 필요에 따라 ![Local LLM](https://img.shields.io/badge/Local_LLM-4B32C3?style=flat-square&logo=artificial-intelligence&logoColor=white) (Qwen3 32B 등) 서빙 (Runpod 활용), 다른 오픈소스 모델 (Mistral 등) 및 상용 모델 (Claude, Gemini) 고려.
    *   임베딩 모델: ![OpenAI Embeddings](https://img.shields.io/badge/OpenAI_Embeddings-74aa9c?style=flat-square&logo=openai&logoColor=white) (문서 및 쿼리 벡터 생성)
    *   벡터 데이터베이스: ![Pinecone](https://img.shields.io/badge/Pinecone-000000?style=flat-square&logo=pinecone&logoColor=white) (문서 임베딩 저장 및 검색), ![PostgreSQL](https://img.shields.io/badge/PostgreSQL_pgvector-4169E1?style=flat-square&logo=postgresql&logoColor=white) (논의됨). 하이브리드 서치 및 리랭킹 기능 고려.
    *   관계형 데이터베이스: ![PostgreSQL](https://img.shields.io/badge/PostgreSQL-4169E1?style=flat-square&logo=postgresql&logoColor=white) (사용자 정보, 채팅 내용, 분석 결과, 정형 데이터셋 등 저장).
    *   객체 스토리지: ![AWS S3](https://img.shields.io/badge/AWS_S3-569A31?style=flat-square&logo=amazons3&logoColor=white) (업로드 파일, 원본 문서, 모델 저장 등).
    *   ETL 스크립트: ![Python](https://img.shields.io/badge/Python-3776AB?style=flat-square&logo=python&logoColor=white) ![AWS Lambda](https://img.shields.io/badge/AWS_Lambda-FF9900?style=flat-square&logo=awslambda&logoColor=white) (requests, psycopg2, tqdm, pdfplumber, beautifulsoup, OpenAI API 등 활용).
    *   배포: ![AWS EC2](https://img.shields.io/badge/AWS_EC2-FF9900?style=flat-square&logo=amazonec2&logoColor=white), ![Runpod](https://img.shields.io/badge/Runpod-6C47FF?style=flat-square&logo=runpod&logoColor=white) (VLLM 서빙).
    *   툴 호출 표준: ![MCP](https://img.shields.io/badge/MCP-007ACC?style=flat-square&logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAqFBMVEX///8AAP8AgP8AgIAAgIBVVaoAYIBAgIBAYGBAYIBJbYBJbXFJbW1Nc21NbnZNbnFNbm1QcXFQcXZQcW1SdG1SdHFSdG1VVXFVVXZVVXFVVWpVVW1VVW1VVW1VVW1VVW1VVW1VVW1VVW1VVW1VVW1VVW1VVW1VVW1VVW1)

## 팀원 및 역할 (Roles and Responsibilities)
| 이름 | 이미지 | 역할 |
| ------ | ------ | ------ |
| **신정우** (PM) | <img src="./img/신정우.png" width="150"> | 데이터 분석 에이전트 개발 및 머신러닝 모델링 (프로젝트 기획 및 일정/이슈 관리 포함) |
| **경규휘** | <img src="./img/경규희.png" width="150"> | 문서 검색 전문 에이전트 (RAG) 개발 및 데이터 검색 (Product 문서 데이터 수집 및 RAG 테스트 포함) |
| **남궁승원** | <img src="./img/남궁승원.png" width="150"> | 데이터 분석 에이전트 개발 및 머신러닝 모델링 (ML 부분 포함) (기술 문서 및 사내 정책 문서 데이터 수집 포함) |
| **이태수** | <img src="./img/이태수.png" width="150"> | 시장 조사 및 문서 검색 전문 에이전트 (RAG) 개발 (뉴스 수집 API 개발 및 이슈/동향 수집 포함) |
| **황인호** | <img src="./img/인호.jpeg" width="150"> | AI 에이전트 총괄 시스템 (LangGraph Supervisor), 코드 에이전트, 프론트엔드 개발 (ERD, 배포, 데이터 조회 프로그램 개발 포함) |

## 문서 구조 (Chapters)
프로젝트의 핵심 구성 요소 및 개발 과정에 대한 자세한 내용은 다음 장에서 확인할 수 있습니다.
1.  [애플리케이션 데이터 설계도 (Django 모델)](docs/01_애플리케이션_데이터_설계도__django_모델__.md)
2.  [프론트엔드 채팅 UI](docs/02_프론트엔드_채팅_ui_.md)
3.  [실시간 AI 통신 게이트웨이 (FastAPI & WebSocket)](docs/03_실시간_ai_통신_게이트웨이__fastapi___websocket__.md)
4.  [AI 에이전트 총괄 시스템 (LangGraph Supervisor)](docs/04_ai_에이전트_총괄_시스템__langgraph_supervisor__.md)
5.  [데이터 분석 전문 에이전트 (Analytics Agent)](docs/05_데이터_분석_전문_에이전트__analytics_agent__.md)
6.  [문서 검색 전문 에이전트 (RAG Agent)](docs/06_문서_검색_전문_에이전트__rag_agent__.md)
7.  [외부 데이터 수집 및 처리 (ETL)](docs/07_외부_데이터_수집_및_처리__etl__.md)
8.  [프론트엔드-데이터베이스 연동](docs/08_프론트엔드_데이터베이스_연동_.md)

## 협업 및 일정 관리
*   **회의**: 정기적인 팀 회의를 통해 프로젝트 진행 상황 공유 및 다음 업무 논의.
*   **회의록**: Notion, ClovaNote 등을 활용하여 회의 내용, 결정 사항, 개별 업무 내용 기록 및 공유.
*   **코드 관리**: Git Repository를 사용하여 코드 버전 관리 및 협업.
*   **일정/이슈 관리**: GitHub Project를 활용하여 업무 이슈 등록, 담당자 배정, 진행 상황 추적.
*   **커뮤니케이션**: Discord, KakaoTalk 등을 활용하여 실시간 소통.
*   **기술 스터디**: LangGraph, LangSmith, Pinecone 사용법 등 핵심 기술에 대한 팀원 간 스터디 진행.


--- File: 1 # backend/accounts/__init__.py ---


--- File: 2 # backend/accounts/admin.py ---
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.utils.translation import gettext_lazy as _

from .models import Organization, User


@admin.register(Organization)
class OrganizationAdmin(admin.ModelAdmin):
    list_display = ('name', 'created_at')
    search_fields = ('name',)
    ordering = ('name',)


@admin.register(User)
class UserAdmin(BaseUserAdmin):
    list_display = ('email', 'name', 'org', 'role', 'is_staff', 'is_active')
    list_filter = ('is_staff', 'is_superuser', 'is_active', 'role', 'org')
    search_fields = ('email', 'name')
    ordering = ('email',)
    
    fieldsets = (
        (None, {'fields': ('email', 'password')}),
        (_('Personal info'), {'fields': ('name', 'org', 'role')}),
        (_('Permissions'), {
            'fields': ('is_active', 'is_staff', 'is_superuser', 'groups', 'user_permissions'),
        }),
        (_('Important dates'), {'fields': ('last_login', 'created_at')}),
    )
    add_fieldsets = (
        (None, {
            'classes': ('wide',),
            'fields': ('email', 'password1', 'password2', 'org', 'role'),
        }),
    )
    readonly_fields = ('created_at',)


--- File: 3 # backend/accounts/apps.py ---
from django.apps import AppConfig


class AccountsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'accounts'


--- File: 6 # backend/accounts/models.py ---
"""accounts/models.py  –  조직·사용자"""

import uuid
from django.db import models
from django.contrib.auth.models import AbstractBaseUser, PermissionsMixin, BaseUserManager


class UserRole(models.TextChoices):
    ADMIN = "admin", "Admin"
    ENGINEER = "engineer", "Engineer"
    ANALYST = "analyst", "Analyst"
    GUEST = "guest", "Guest"


class Organization(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=255, unique=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "organizations"
        ordering = ["name"]

    def __str__(self):
        return self.name


class UserManager(BaseUserManager):
    def create_user(self, email: str, password: str | None = None, **extra):
        if not email:
            raise ValueError("Email is required")
        user = self.model(email=self.normalize_email(email), **extra)
        user.set_password(password)
        user.save()
        return user

    def create_superuser(self, email: str, password: str | None = None, **extra):
        extra.setdefault("role", UserRole.ADMIN)
        extra.setdefault("is_staff", True)
        extra.setdefault("is_superuser", True)
        
        # Organization이 제공되지 않은 경우 기본 Organization 생성 또는 사용
        if 'org' not in extra:
            # 기본 조직이 있는지 확인
            default_org, created = Organization.objects.get_or_create(
                name="Default Organization"
            )
            extra["org"] = default_org
            
        return self.create_user(email, password, **extra)


class User(AbstractBaseUser, PermissionsMixin):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    org = models.ForeignKey(Organization, on_delete=models.CASCADE, related_name="users")
    email = models.EmailField(unique=True)
    name = models.CharField(max_length=100, blank=True)
    role = models.CharField(max_length=20, choices=UserRole.choices, default=UserRole.GUEST)
    created_at = models.DateTimeField(auto_now_add=True)
    last_login = models.DateTimeField(null=True, blank=True)

    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)

    objects = UserManager()
    USERNAME_FIELD = "email"

    class Meta:
        db_table = "users"
        ordering = ["email"]

    def __str__(self):
        return self.email


--- File: 7 # backend/accounts/serializers.py ---
from rest_framework import serializers
from .models import User, Organization

class OrganizationSerializer(serializers.ModelSerializer):
    class Meta:
        model = Organization
        fields = ['id', 'name']

class UserSerializer(serializers.ModelSerializer):
    org = OrganizationSerializer(read_only=True)
    
    class Meta:
        model = User
        fields = ['id', 'email', 'name', 'org', 'role', 'created_at', 'last_login', 'is_active', 'is_staff']
        read_only_fields = ['id', 'email', 'created_at', 'last_login', 'is_active', 'is_staff']


--- File: 8 # backend/accounts/urls.py ---
from django.urls import path, re_path
from rest_framework_simplejwt.views import TokenRefreshView
from . import views

urlpatterns = [
    # 유연한 URL 패턴 사용 - 슬래시 유무 상관없이 처리
    re_path(r'^login/?$', views.login_view, name='login'),
    re_path(r'^logout/?$', views.logout_view, name='logout'),
    re_path(r'^me/?$', views.user_detail, name='user-detail'),
    re_path(r'^profile/?$', views.update_profile, name='update-profile'),
    re_path(r'^token/refresh/?$', TokenRefreshView.as_view(), name='token-refresh'),
]


--- File: 9 # backend/accounts/views.py ---
from django.contrib.auth import authenticate
from rest_framework import status
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated, AllowAny
from rest_framework.response import Response
from rest_framework_simplejwt.tokens import RefreshToken
from rest_framework_simplejwt.views import TokenRefreshView
from .serializers import UserSerializer

@api_view(['POST'])
@permission_classes([AllowAny])
def login_view(request):
    email = request.data.get('email')
    password = request.data.get('password')
    
    if not email or not password:
        return Response({'detail': 'Email and password are required'}, status=status.HTTP_400_BAD_REQUEST)
    
    # Debugging info - remove in production
    print(f"Login attempt with email: {email}")
    
    # Check if the user exists in the database
    from django.contrib.auth import get_user_model
    User = get_user_model()
    
    try:
        user_exists = User.objects.filter(email=email).exists()
        print(f"User exists in database: {user_exists}")
        
        if not user_exists:
            # Create a test user for debugging if it doesn't exist
            print("Creating test user for debugging...")
            from django.contrib.auth.hashers import make_password
            from .models import Organization
            
            # Get or create default organization
            default_org, _ = Organization.objects.get_or_create(name="Default Organization")
            
            # Create test user
            User.objects.create(
                email=email,
                password=make_password(password),  # Properly hash the password
                name="Test User",
                org=default_org,
                role="admin",
                is_active=True,
                is_staff=True
            )
            print(f"Test user created with email: {email}")
    except Exception as e:
        print(f"Error checking/creating user: {e}")
    
    # Django's authenticate expects the USERNAME_FIELD value in the 'username' parameter
    # Since our User model has USERNAME_FIELD = 'email', we pass email to username parameter
    user = authenticate(username=email, password=password)
    print(f"Authentication result: {'Success' if user else 'Failed'}")
    
    if user:
        refresh = RefreshToken.for_user(user)
        return Response({
            'refresh': str(refresh),
            'access': str(refresh.access_token),
            'user': UserSerializer(user).data
        })
    
    # More detailed error for debugging
    return Response({'detail': 'Invalid credentials. Please check your email and password.'}, 
                    status=status.HTTP_401_UNAUTHORIZED)

@api_view(['POST'])
@permission_classes([AllowAny])
def logout_view(request):
    # JWT doesn't really need server-side logout, but we keep the endpoint for API consistency
    return Response({"detail": "Successfully logged out."})

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def user_detail(request):
    serializer = UserSerializer(request.user)
    return Response(serializer.data)

@api_view(['PATCH'])
@permission_classes([IsAuthenticated])
def update_profile(request):
    user = request.user
    serializer = UserSerializer(user, data=request.data, partial=True)
    
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data)
    
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


--- File: 12 # backend/config/settings.py ---
"""
Django settings for config project.

Generated by 'django-admin startproject' using Django 5.2.1.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""
import os
from dotenv import load_dotenv
from pathlib import Path

load_dotenv()

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.getenv('SECRET_KEY')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework', 'rest_framework_simplejwt', 'corsheaders',
    'accounts', 'knowledge', 'conversations', 'mlops',
    'pgvector.django'
]

# Custom user model
AUTH_USER_MODEL = 'accounts.User'

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',  # CORS 미들웨어는 가장 앞에 위치해야 함
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'config.urls'

# URL configuration
APPEND_SLASH = False  # Do not force appending slashes to URLs

# CORS settings
CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",  # Next.js 개발 서버
]
CORS_ALLOW_CREDENTIALS = True

# Add CORS_ALLOWED_METHODS
CORS_ALLOWED_METHODS = [
    'DELETE',
    'GET',
    'OPTIONS',
    'PATCH',
    'POST',
    'PUT',
]

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

# DATABASES = {
#     'default': {
#         'ENGINE': 'django.db.backends.sqlite3',
#         'NAME': BASE_DIR / 'db.sqlite3',
#     }
# }

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.getenv('DB_NAME'),
        'USER': os.getenv('DB_USER'),
        'PASSWORD': os.getenv('DB_PASSWORD'),
        'HOST': os.getenv('DB_HOST'),
        'PORT': os.getenv('DB_PORT', '5432'),
    }
}
#print(DATABASES)


# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# REST Framework settings
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
}

# JWT settings
from datetime import timedelta
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(hours=1),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=7),
    'ROTATE_REFRESH_TOKENS': False,
    'BLACKLIST_AFTER_ROTATION': True,
    'ALGORITHM': 'HS256',
    'SIGNING_KEY': SECRET_KEY,
    'VERIFYING_KEY': None,
    'AUTH_HEADER_TYPES': ('Bearer',),
    'USER_ID_FIELD': 'id',
    'USER_ID_CLAIM': 'user_id',
    'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),
    'TOKEN_TYPE_CLAIM': 'token_type',
}

# CORS settings
CORS_ALLOWED_ORIGINS = [
    'http://localhost:3000',  # Next.js frontend
]
CORS_ALLOW_CREDENTIALS = True


--- File: 13 # backend/config/urls.py ---
"""
URL configuration for config project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include, re_path
from django.http import JsonResponse

def health_check(request):
    return JsonResponse({'status': 'ok'})

urlpatterns = [
    path('admin/', admin.site.urls),
    # 유연한 URL 패턴 사용 - 슬래시 유무 상관없이 처리
    re_path(r'^api/auth/?', include('accounts.urls')),
    re_path(r'^api/chat/?', include('conversations.urls')),
    re_path(r'^api/health-check/?$', health_check, name='health-check'),
]


--- File: 22 # backend/conversations/models.py ---
"""conversations/models.py  –  채팅·LLM 호출"""

import uuid
from django.db import models
from accounts.models import User


class AgentType(models.TextChoices):
    CODE = "code", "Code"
    RAG = "rag", "RAG"
    ANALYTICS = "analytics", "Analytics"
    AUTO = "auto", "Auto"


class ChatSession(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="chat_sessions")
    agent_type = models.CharField(max_length=20, choices=AgentType.choices)
    started_at = models.DateTimeField(auto_now_add=True)
    ended_at = models.DateTimeField(null=True, blank=True)
    title = models.CharField(max_length=60, default="새 세션")

    class Meta:
        db_table = "chat_sessions"


class ChatMessage(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    session = models.ForeignKey(ChatSession, on_delete=models.CASCADE, related_name="messages")
    role = models.CharField(max_length=20)  # user | assistant | system
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "chat_messages"
        ordering = ["created_at"]


class LlmCall(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    session = models.ForeignKey(ChatSession, on_delete=models.CASCADE, related_name="llm_calls")
    provider = models.CharField(max_length=50)
    model = models.CharField(max_length=100)
    prompt_tokens = models.PositiveIntegerField()
    completion_tokens = models.PositiveIntegerField()
    cost_usd = models.DecimalField(max_digits=10, decimal_places=4)
    latency_ms = models.PositiveIntegerField(null=True, blank=True)
    called_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "llm_calls"
        indexes = [models.Index(fields=["called_at"], name="idx_llm_called_at")]



--- File: 23 # backend/conversations/serializers.py ---
from rest_framework import serializers
from .models import ChatSession, ChatMessage, LlmCall, AgentType


class ChatMessageSerializer(serializers.ModelSerializer):
    """ChatMessage 모델 직렬화를 위한 serializer"""
    
    class Meta:
        model = ChatMessage
        fields = ['id', 'session', 'role', 'content', 'created_at']
        read_only_fields = ['id', 'created_at']


class LlmCallSerializer(serializers.ModelSerializer):
    """LlmCall 모델 직렬화를 위한 serializer"""
    
    class Meta:
        model = LlmCall
        fields = ['id', 'session', 'provider', 'model', 'prompt_tokens', 
                 'completion_tokens', 'cost_usd', 'latency_ms', 'called_at']
        read_only_fields = ['id', 'called_at']


class ChatSessionSerializer(serializers.ModelSerializer):
    """ChatSession 모델 직렬화를 위한 serializer"""
    messages = ChatMessageSerializer(many=True, read_only=True)
    
    class Meta:
        model = ChatSession
        fields = ['id', 'user', 'agent_type', 'started_at', 'ended_at', 'title', 'messages']
        read_only_fields = ['id', 'started_at']

    def validate_agent_type(self, value):
        """agent_type 필드 유효성 검사"""
        if value not in [choice[0] for choice in AgentType.choices]:
            raise serializers.ValidationError(f"유효하지 않은 에이전트 유형입니다. 유효한 값: {AgentType.choices}")
        return value


--- File: 24 # backend/conversations/urls.py ---
from django.urls import path, re_path
from . import views

urlpatterns = [
    # 채팅 세션 관련 URL
    re_path(r'^sessions/?$', views.ChatSessionViewSet.as_view(), name='chat_sessions'),
    re_path(r'^sessions/(?P<pk>[0-9a-f-]+)/?$', views.ChatSessionDetailView.as_view(), name='chat_session_detail'),
    
    # 채팅 메시지 관련 URL
    re_path(r'^sessions/(?P<session_pk>[0-9a-f-]+)/messages/?$', views.ChatMessageView.as_view(), name='chat_messages'),
]


--- File: 25 # backend/conversations/views.py ---
from django.utils import timezone
from django.shortcuts import get_object_or_404
from rest_framework import status, viewsets
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.views import APIView

from .models import ChatSession, ChatMessage
from .serializers import ChatSessionSerializer, ChatMessageSerializer


class ChatSessionViewSet(APIView):
    """채팅 세션을 관리하는 API 뷰셋"""
    permission_classes = [IsAuthenticated]

    def get(self, request):
        """현재 사용자의 모든 채팅 세션 조회"""
        sessions = ChatSession.objects.filter(user=request.user).order_by('-started_at')
        serializer = ChatSessionSerializer(sessions, many=True)
        return Response(serializer.data)

    def post(self, request):
        """새 채팅 세션 생성"""
        # 요청 데이터에 사용자 ID 추가
        data = request.data.copy()
        data['user'] = request.user.id
        
        serializer = ChatSessionSerializer(data=data)
        if serializer.is_valid():
            session = serializer.save()
            
            # 시스템 메시지 생성 (선택적)
            welcome_message = f"Welcome to your new {session.agent_type} session. How can I help you today?"
            ChatMessage.objects.create(
                session=session,
                role="system",
                content=welcome_message
            )
            
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class ChatSessionDetailView(APIView):
    """특정 채팅 세션을 관리하는 API 뷰"""
    permission_classes = [IsAuthenticated]

    def get(self, request, pk):
        """특정 채팅 세션 조회"""
        session = get_object_or_404(ChatSession, pk=pk, user=request.user)
        serializer = ChatSessionSerializer(session)
        return Response(serializer.data)

    def patch(self, request, pk):
        """채팅 세션 업데이트 (주로 종료 시간)"""
        session = get_object_or_404(ChatSession, pk=pk, user=request.user)
        serializer = ChatSessionSerializer(session, data=request.data, partial=True)
        
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class ChatMessageView(APIView):
    """채팅 메시지를 관리하는 API 뷰"""
    permission_classes = [IsAuthenticated]

    def get(self, request, session_pk):
        """특정 세션의 모든 메시지 조회"""
        # 해당 세션이 현재 사용자의 것인지 확인
        session = get_object_or_404(ChatSession, pk=session_pk, user=request.user)
        messages = ChatMessage.objects.filter(session=session).order_by('created_at')
        serializer = ChatMessageSerializer(messages, many=True)
        return Response(serializer.data)

    def post(self, request, session_pk):
        """새 메시지 생성 및 AI 응답 생성"""
        # 해당 세션이 현재 사용자의 것인지 확인
        session = get_object_or_404(ChatSession, pk=session_pk, user=request.user)
        
        # 사용자 메시지 생성
        data = request.data.copy()
        data['session'] = session.pk
        data['role'] = 'user'
        
        serializer = ChatMessageSerializer(data=data)
        if serializer.is_valid():
            user_message = serializer.save()
            
            # 여기서 AI 응답을 생성하는 로직을 추가할 수 있습니다
            # 지금은 간단한 예시 응답을 생성합니다
            ai_response_content = f"This is a mock response to your message: {user_message.content}"
            
            # AI 응답 메시지 생성
            ai_message = ChatMessage.objects.create(
                session=session,
                role="assistant",
                content=ai_response_content
            )
            
            # 사용자 메시지와 AI 응답을 모두 포함하여 반환
            both_messages = ChatMessage.objects.filter(id__in=[user_message.id, ai_message.id])
            messages_serializer = ChatMessageSerializer(both_messages, many=True)
            return Response(messages_serializer.data, status=status.HTTP_201_CREATED)
        
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


--- File: 26 # backend/knowledge/__init__.py ---


--- File: 27 # backend/knowledge/admin.py ---
from django.contrib import admin
from django.utils.html import format_html
from .models import Document, GitRepository, CodeFile, EmbedChunk, TelecomCustomers, SummaryNewsKeywords


@admin.register(Document)
class DocumentAdmin(admin.ModelAdmin):
    list_display = ('title', 'doc_type', 'org', 'version', 'created_at')
    list_filter = ('doc_type', 'org')
    search_fields = ('title', 's3_key')
    list_select_related = ('org', 'uploaded_by')
    readonly_fields = ('created_at',)
    date_hierarchy = 'created_at'


@admin.register(GitRepository)
class GitRepositoryAdmin(admin.ModelAdmin):
    list_display = ('repo_url', 'org', 'default_branch', 'fetched_at')
    list_filter = ('org',)
    search_fields = ('repo_url',)
    readonly_fields = ('fetched_at',)


@admin.register(CodeFile)
class CodeFileAdmin(admin.ModelAdmin):
    list_display = ('file_path', 'repo', 'language', 'loc')
    list_filter = ('repo', 'language')
    search_fields = ('file_path', 'latest_commit')
    list_select_related = ('repo',)
    readonly_fields = ('id',)


@admin.register(EmbedChunk)
class EmbedChunkAdmin(admin.ModelAdmin):
    list_display = ('id', 'chunk_index', 'document', 'file', 'hash_short')
    list_filter = ('document', 'file')
    search_fields = ('hash', 'pinecone_id')
    readonly_fields = ('id',)
    list_select_related = ('document', 'file')
    
    def hash_short(self, obj):
        return f"{obj.hash[:10]}..." if obj.hash else ""
    hash_short.short_description = 'Hash'





@admin.register(TelecomCustomers)
class TelecomCustomersAdmin(admin.ModelAdmin) :
    list_display = ('id', 'customer_id', 'gender', 'partner', 'dependents' ,'churn')
    list_filter = ('dependents','churn', 'gender')
    search_fields = ('id','customer_id')
    readonly_fields = ('id', 'customer_id')


@admin.register(SummaryNewsKeywords)
class SummaryNewsKeywordsAdmin(admin.ModelAdmin):
    list_display = ('date', 'keyword_display', 'title_short', 'url_short')
    list_filter = ('date', 'keyword')
    search_fields = ('title', 'summary', 'keyword')
    list_select_related = ()
    date_hierarchy = 'date'
    ordering = ('-date', 'keyword')
    
    def keyword_display(self, obj):
        return obj.keyword
    keyword_display.short_description = 'Keyword'
    
    def title_short(self, obj):
        return f"{obj.title[:50]}..." if len(obj.title) > 50 else obj.title
    title_short.short_description = 'Title'
    
    def url_short(self, obj):
        return format_html('<a href="{}" target="_blank">Link</a>', obj.url)
    url_short.short_description = 'URL'


--- File: 32 # backend/knowledge/models.py ---
"""knowledge/models.py  –  문서·레포·임베딩"""

import uuid
from django.db import models
from django.db.models import Q, CheckConstraint
from accounts.models import Organization, User
from pgvector.django import VectorField

class DocType(models.TextChoices):
    POLICY = "policy", "Policy"
    PRODUCT = "product", "Product"
    TECH_MANUAL = "tech_manual", "Tech Manual"


class Document(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    org = models.ForeignKey(Organization, on_delete=models.CASCADE, related_name="documents")
    title = models.CharField(max_length=255)
    doc_type = models.CharField(max_length=20, choices=DocType.choices)
    s3_key = models.TextField(unique=True)
    version = models.CharField(max_length=50, default="v1")
    pinecone_ns = models.CharField(max_length=100)
    uploaded_by = models.ForeignKey(
        User, null=True, blank=True, on_delete=models.SET_NULL, related_name="uploaded_documents"
    )
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "documents"
        indexes = [models.Index(fields=["org", "doc_type"], name="idx_docs_org_type")]

    def __str__(self):
        return self.title


class GitRepository(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    org = models.ForeignKey(Organization, on_delete=models.CASCADE, related_name="repositories")
    repo_url = models.TextField(unique=True)
    default_branch = models.CharField(max_length=100, default="main")
    fetched_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = "git_repositories"

    def __str__(self):
        return self.repo_url


class CodeFile(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    repo = models.ForeignKey(GitRepository, on_delete=models.CASCADE, related_name="code_files")
    file_path = models.TextField()
    language = models.CharField(max_length=50, blank=True)
    latest_commit = models.CharField(max_length=40, blank=True)
    loc = models.PositiveIntegerField(null=True, blank=True)

    class Meta:
        db_table = "code_files"
        unique_together = ("repo", "file_path")
        indexes = [models.Index(fields=["repo"], name="idx_files_repo")]

    def __str__(self):
        return self.file_path


class EmbedChunk(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    document = models.ForeignKey(
        Document, null=True, blank=True, on_delete=models.CASCADE, related_name="chunks"
    )
    file = models.ForeignKey(
        CodeFile, null=True, blank=True, on_delete=models.CASCADE, related_name="chunks"
    )
    chunk_index = models.PositiveIntegerField()
    pinecone_id = models.CharField(max_length=100)
    hash = models.CharField(max_length=64, unique=True)

    class Meta:
        db_table = "embed_chunks"
        constraints = [
            CheckConstraint(
                name="embed_chunks_one_fk",
                check=Q(document__isnull=False, file__isnull=True)
                | Q(document__isnull=True, file__isnull=False),
            )
        ]
        indexes = [models.Index(fields=["document", "file"], name="idx_chunks_source")]

    def __str__(self):
        return self.hash
    



class TelecomCustomers(models.Model) :
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    customer_id = models.CharField(max_length=20, null=False)
    gender = models.CharField(max_length=6)
    senior_citizen = models.BooleanField()
    partner = models.BooleanField()
    dependents = models.BooleanField()
    tenure = models.IntegerField()
    phone_service = models.BooleanField()
    multiple_lines = models.CharField(max_length=20)
    internet_serivce = models.CharField(max_length=20)
    online_security = models.CharField(max_length=20)
    online_backup = models.CharField(max_length=20)
    device_protection = models.CharField(max_length=20)
    tech_support = models.CharField(max_length=20)
    streaming_tv = models.CharField(max_length=20)
    streaming_movies = models.CharField(max_length=20)
    contract = models.CharField(max_length=20)
    paperless_billing = models.BooleanField()
    payment_method = models.CharField(max_length=30)
    monthly_charges = models.DecimalField(max_digits=10, decimal_places=2)
    total_charges = models.DecimalField(max_digits=14, decimal_places=2)
    churn = models.BooleanField()

    class Meta:
        verbose_name_plural = "Telecom customers"  # 복수형 이름 지정
        db_table = 'telecom_customers'  # 테이블 이름도 명시적으로 지정


class SummaryNewsKeywords(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    date = models.DateField()
    keyword = models.TextField()
    title = models.TextField()
    summary = models.TextField()
    url = models.URLField(max_length=500)

    class Meta:
        verbose_name_plural = "Summary news keywords"  # 복수형 이름 지정
        db_table = 'summary_news_keywords'  # 테이블 이름도 명시적으로 지정



    def __str__(self):
        return f"{self.date} - {self.keyword} - {self.title[:50]}..."




--- File: 34 # backend/manage.py ---
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()


--- File: 36 # backend/mlops/admin.py ---
from django.contrib import admin
from django.utils.html import format_html
from .models import AnalyticsResult, ModelArtifact


@admin.register(AnalyticsResult)
class AnalyticsResultAdmin(admin.ModelAdmin):
    list_display = ('id', 'user', 'result_type', 'created_at', 's3_key_preview')
    list_filter = ('result_type', 'created_at')
    search_fields = ('user__email', 's3_key', 'meta')
    readonly_fields = ('created_at', 'meta_prettified')
    list_select_related = ('user',)
    
    def s3_key_preview(self, obj):
        return obj.s3_key[:50] + '...' if len(obj.s3_key) > 50 else obj.s3_key
    s3_key_preview.short_description = 'S3 Key'
    
    def meta_prettified(self, obj):
        import json
        from pygments import highlight
        from pygments.lexers import JsonLexer
        from pygments.formatters import HtmlFormatter
        from django.utils.safestring import mark_safe
        
        if not obj.meta:
            return ""
            
        response = json.dumps(obj.meta, indent=2, ensure_ascii=False)
        response = response[:5000]  # Limit the size to prevent performance issues
        
        # Truncate and add ellipsis if necessary
        if len(response) > 5000:
            response = response[:5000] + '... (truncated)'
            
        # Format the JSON
        formatter = HtmlFormatter(style='colorful')
        response = highlight(response, JsonLexer(), formatter)
        style = "<style>" + formatter.get_style_defs() + "</style><br>"
        return mark_safe(style + response)
    
    meta_prettified.short_description = 'Metadata'


@admin.register(ModelArtifact)
class ModelArtifactAdmin(admin.ModelAdmin):
    list_display = ('name', 'version', 'stage', 'created_by', 'created_at', 's3_key_preview')
    list_filter = ('stage', 'created_at')
    search_fields = ('name', 'version', 's3_key')
    readonly_fields = ('created_at', 'metrics_prettified')
    list_select_related = ('created_by',)
    
    def s3_key_preview(self, obj):
        return obj.s3_key[:50] + '...' if len(obj.s3_key) > 50 else obj.s3_key
    s3_key_preview.short_description = 'S3 Key'
    
    def metrics_prettified(self, obj):
        if not obj.metrics:
            return ""
            
        import json
        from pygments import highlight
        from pygments.lexers import JsonLexer
        from pygments.formatters import HtmlFormatter
        from django.utils.safestring import mark_safe
        
        response = json.dumps(obj.metrics, indent=2, ensure_ascii=False)
        response = response[:5000]  # Limit the size to prevent performance issues
        
        # Truncate and add ellipsis if necessary
        if len(response) > 5000:
            response = response[:5000] + '... (truncated)'
            
        # Format the JSON
        formatter = HtmlFormatter(style='colorful')
        response = highlight(response, JsonLexer(), formatter)
        style = "<style>" + formatter.get_style_defs() + "</style><br>"
        return mark_safe(style + response)
    
    metrics_prettified.short_description = 'Metrics'


--- File: 40 # backend/mlops/models.py ---
"""mlops/models.py  –  분석 결과 & 모델 레지스트리"""

import uuid
from django.db import models
from accounts.models import User


class ResultType(models.TextChoices):
    CHURN_PRED = "churn_pred", "Churn Prediction"
    VIZ_IMAGE = "viz_image", "Visualization Image"
    TS_FORECAST = "timeseries_forecast", "Time-series Forecast"


class AnalyticsResult(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="analytics_results")
    result_type = models.CharField(max_length=30, choices=ResultType.choices)
    s3_key = models.TextField()
    meta = models.JSONField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "analytics_results"
        indexes = [models.Index(fields=["user", "result_type"], name="idx_analytics_user_type")]

    def __str__(self):
        return f"{self.result_type} - {self.id}"


class ModelStage(models.TextChoices):
    STAGING = "staging", "Staging"
    PRODUCTION = "production", "Production"
    ARCHIVED = "archived", "Archived"


class ModelArtifact(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=120)
    version = models.CharField(max_length=50, default="v1")
    s3_key = models.TextField()
    stage = models.CharField(max_length=20, choices=ModelStage.choices, default=ModelStage.STAGING)
    metrics = models.JSONField(null=True, blank=True)
    created_by = models.ForeignKey(
        User, null=True, on_delete=models.SET_NULL, related_name="model_artifacts"
    )
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "model_artifacts"
        unique_together = ("name", "version")
        indexes = [
            models.Index(fields=["name", "stage"], name="idx_model_stage"),
            models.Index(fields=["created_at"], name="idx_model_created"),
        ]
        ordering = ["-created_at"]

    def __str__(self):
        return f"{self.name} ({self.version}) - {self.stage}"


--- File: 43 # backend/path/to/your/app/Makefile ---
.PHONY: all format lint test tests test_watch integration_tests docker_tests help extended_tests

# Default target executed when no arguments are given to make.
all: help

# Define a variable for the test file path.
TEST_FILE ?= tests/unit_tests/

test:
	python -m pytest $(TEST_FILE)

integration_tests:
	python -m pytest tests/integration_tests 

test_watch:
	python -m ptw --snapshot-update --now . -- -vv tests/unit_tests

test_profile:
	python -m pytest -vv tests/unit_tests/ --profile-svg

extended_tests:
	python -m pytest --only-extended $(TEST_FILE)


######################
# LINTING AND FORMATTING
######################

# Define a variable for Python and notebook files.
PYTHON_FILES=src/
MYPY_CACHE=.mypy_cache
lint format: PYTHON_FILES=.
lint_diff format_diff: PYTHON_FILES=$(shell git diff --name-only --diff-filter=d main | grep -E '\.py$$|\.ipynb$$')
lint_package: PYTHON_FILES=src
lint_tests: PYTHON_FILES=tests
lint_tests: MYPY_CACHE=.mypy_cache_test

lint lint_diff lint_package lint_tests:
	python -m ruff check .
	[ "$(PYTHON_FILES)" = "" ] || python -m ruff format $(PYTHON_FILES) --diff
	[ "$(PYTHON_FILES)" = "" ] || python -m ruff check --select I $(PYTHON_FILES)
	[ "$(PYTHON_FILES)" = "" ] || python -m mypy --strict $(PYTHON_FILES)
	[ "$(PYTHON_FILES)" = "" ] || mkdir -p $(MYPY_CACHE) && python -m mypy --strict $(PYTHON_FILES) --cache-dir $(MYPY_CACHE)

format format_diff:
	ruff format $(PYTHON_FILES)
	ruff check --select I --fix $(PYTHON_FILES)

spell_check:
	codespell --toml pyproject.toml

spell_fix:
	codespell --toml pyproject.toml -w

######################
# HELP
######################

help:
	@echo '----'
	@echo 'format                       - run code formatters'
	@echo 'lint                         - run linters'
	@echo 'test                         - run unit tests'
	@echo 'tests                        - run unit tests'
	@echo 'test TEST_FILE=<test_file>   - run all tests in file'
	@echo 'test_watch                   - run unit tests in watch mode'



--- File: 44 # backend/path/to/your/app/README.md ---
# New LangGraph Project

[![CI](https://github.com/langchain-ai/new-langgraph-project/actions/workflows/unit-tests.yml/badge.svg)](https://github.com/langchain-ai/new-langgraph-project/actions/workflows/unit-tests.yml)
[![Integration Tests](https://github.com/langchain-ai/new-langgraph-project/actions/workflows/integration-tests.yml/badge.svg)](https://github.com/langchain-ai/new-langgraph-project/actions/workflows/integration-tests.yml)

This template demonstrates a simple application implemented using [LangGraph](https://github.com/langchain-ai/langgraph), designed for showing how to get started with [LangGraph Server](https://langchain-ai.github.io/langgraph/concepts/langgraph_server/#langgraph-server) and using [LangGraph Studio](https://langchain-ai.github.io/langgraph/concepts/langgraph_studio/), a visual debugging IDE.

<div align="center">
  <img src="./static/studio_ui.png" alt="Graph view in LangGraph studio UI" width="75%" />
</div>

The core logic defined in `src/agent/graph.py`, showcases an single-step application that responds with a fixed string and the configuration provided.

You can extend this graph to orchestrate more complex agentic workflows that can be visualized and debugged in LangGraph Studio.

## Getting Started

<!--
Setup instruction auto-generated by `langgraph template lock`. DO NOT EDIT MANUALLY.
-->

<!--
End setup instructions
-->

1. Install dependencies, along with the [LangGraph CLI](https://langchain-ai.github.io/langgraph/concepts/langgraph_cli/), which will be used to run the server.

```bash
cd path/to/your/app
pip install -e . "langgraph-cli[inmem]"
```

2. (Optional) Customize the code and project as needed. Create a `.env` file if you need to use secrets.

```bash
cp .env.example .env
```

If you want to enable LangSmith tracing, add your LangSmith API key to the `.env` file.

```text
# .env
LANGSMITH_API_KEY=lsv2...
```

3. Start the LangGraph Server.

```shell
langgraph dev
```

For more information on getting started with LangGraph Server, [see here](https://langchain-ai.github.io/langgraph/tutorials/langgraph-platform/local-server/).

## How to customize

1. **Define configurable parameters**: Modify the `Configuration` class in the `graph.py` file to expose the arguments you want to configure. For example, in a chatbot application you may want to define a dynamic system prompt or LLM to use. For more information on configurations in LangGraph, [see here](https://langchain-ai.github.io/langgraph/concepts/low_level/?h=configuration#configuration).

2. **Extend the graph**: The core logic of the application is defined in [graph.py](./src/agent/graph.py). You can modify this file to add new nodes, edges, or change the flow of information.

## Development

While iterating on your graph in LangGraph Studio, you can edit past state and rerun your app from previous states to debug specific nodes. Local changes will be automatically applied via hot reload.

Follow-up requests extend the same thread. You can create an entirely new thread, clearing previous history, using the `+` button in the top right.

For more advanced features and examples, refer to the [LangGraph documentation](https://langchain-ai.github.io/langgraph/). These resources can help you adapt this template for your specific use case and build more sophisticated conversational agents.

LangGraph Studio also integrates with [LangSmith](https://smith.langchain.com/) for more in-depth tracing and collaboration with teammates, allowing you to analyze and optimize your chatbot's performance.

<!--
Configuration auto-generated by `langgraph template lock`. DO NOT EDIT MANUALLY.
{
  "config_schemas": {
    "agent": {
      "type": "object",
      "properties": {}
    }
  }
}
-->


--- File: 46 # backend/path/to/your/app/src/agent/graph.py ---
"""LangGraph single-node graph template.

Returns a predefined response. Replace logic and configuration as needed.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, TypedDict

from langchain_core.runnables import RunnableConfig
from langgraph.graph import StateGraph


class Configuration(TypedDict):
    """Configurable parameters for the agent.

    Set these when creating assistants OR when invoking the graph.
    See: https://langchain-ai.github.io/langgraph/cloud/how-tos/configuration_cloud/
    """

    my_configurable_param: str


@dataclass
class State:
    """Input state for the agent.

    Defines the initial structure of incoming data.
    See: https://langchain-ai.github.io/langgraph/concepts/low_level/#state
    """

    changeme: str = "example"


async def call_model(state: State, config: RunnableConfig) -> Dict[str, Any]:
    """Process input and returns output.

    Can use runtime configuration to alter behavior.
    """
    configuration = config["configurable"]
    return {
        "changeme": "output from call_model. "
        f'Configured with {configuration.get("my_configurable_param")}'
    }


# Define the graph
graph = (
    StateGraph(State, config_schema=Configuration)
    .add_node(call_model)
    .add_edge("__start__", "call_model")
    .compile(name="New Graph")
)


--- File: 47 # fastapi_server/README.md ---
# LangGraph Agent FastAPI Server

이 프로젝트는 LangGraph 기반 멀티 에이전트 시스템을 FastAPI 웹 서버로 서빙하는 어플리케이션입니다.

## 프로젝트 구조

```
fastapi_server/
├── __init__.py          # 패키지 초기화 파일
├── main.py              # FastAPI 애플리케이션 메인 파일
├── agent_service.py     # LangGraph 에이전트와의 인터페이스
├── models.py            # API 요청/응답 모델
├── requirements.txt     # 필요한 의존성
├── start_server.py      # 서버 실행 스크립트
└── README.md            # 이 문서
```

## 설치 및 실행 방법

### 1. 가상 환경 설정

항상 가상 환경을 사용하는 것이 좋습니다. 가상 환경을 생성하고 활성화하세요:

```bash
# 가상 환경 생성
python -m venv venv

# 가상 환경 활성화 (Windows)
venv\Scripts\activate

# 가상 환경 활성화 (Linux/Mac)
source venv/bin/activate
```

### 2. 의존성 설치

필요한 패키지를 설치합니다:

```bash
pip install -r requirements.txt
```

### 3. 환경 변수 설정

프로젝트 루트 디렉토리에 `.env` 파일이 있는지 확인하세요. 다음과 같은 환경 변수가 필요합니다:

```
OPENAI_API_KEY=your_openai_api_key_here
```

### 4. 서버 실행

다음 명령을 사용하여 서버를 시작합니다:

```bash
# 방법 1: start_server.py 스크립트 사용
python start_server.py

# 방법 2: uvicorn 직접 사용
uvicorn fastapi_server.main:app --host 0.0.0.0 --port 8001 --reload
```

서버가 성공적으로 시작되면 http://localhost:8001 에서 접근할 수 있습니다.

## API 엔드포인트

### 1. 상태 확인

- **URL**: GET /
- **응답**: 서버 상태 정보

### 2. 채팅 메시지 전송

- **URL**: POST /api/chat
- **요청 본문**:
  ```json
  {
    "message": "사용자 메시지",
    "thread_id": "선택적_대화_ID"
  }
  ```
- **응답**: 에이전트 응답

### 3. WebSocket 스트리밍 채팅

- **URL**: WebSocket /api/chat/ws/{thread_id}
- **사용법**: 
  - 연결 후, JSON 형식의 메시지 전송: `{"message": "사용자 메시지"}`
  - 서버는 다양한 이벤트 타입을 포함한 JSON 응답을 스트리밍합니다.
  - 이벤트 타입: `token`, `agent_change`, `tool_start`, `tool_end`, `done`, `error`

## 예제 사용 코드

### HTTP API 사용 예제 (Python)

```python
import requests

response = requests.post(
    "http://localhost:8001/api/chat",
    json={"message": "지역별 매출을 분석해줘"}
)
print(response.json())
```

### WebSocket 스트리밍 예제 (JavaScript)

```javascript
const ws = new WebSocket('ws://localhost:8001/api/chat/ws/my-thread-1');

ws.onopen = () => {
  console.log('Connected to server');
  ws.send(JSON.stringify({
    message: '데이터 시각화를 도와줘'
  }));
};

ws.onmessage = (event) => {
  const data = JSON.parse(event.data);
  console.log(data);
  
  if (data.type === 'token') {
    // 토큰 처리 (점진적으로 UI에 텍스트 추가)
    process.stdout.write(data.content);
  } else if (data.type === 'agent_change') {
    console.log(`Agent changed to: ${data.agent}`);
  } else if (data.type === 'done') {
    console.log('\nResponse complete!');
  }
};
```

## 문제 해결

1. **ImportError**: 필요한 모듈을 찾지 못하는 경우, 가상 환경이 활성화되어 있고 모든 의존성이 설치되어 있는지 확인하세요.

2. **API 키 오류**: OPENAI_API_KEY가 올바르게 설정되어 있는지 확인하세요.

3. **포트 충돌**: 8001 포트가 이미 사용 중인 경우, `main.py`에서 포트 번호를 변경하세요.


--- File: 50 # fastapi_server/agent/agent2.py ---
from __future__ import annotations

import os
from dataclasses import dataclass
from typing import TypedDict, Dict, Sequence, Union, Optional, Any
import asyncio

from asgiref.sync import sync_to_async
from langchain_core.prompts import PromptTemplate, SystemMessagePromptTemplate,HumanMessagePromptTemplate,ChatPromptTemplate
from langchain_openai import ChatOpenAI
from langgraph.graph import END, START, StateGraph
from dotenv import load_dotenv
from openai import OpenAI
from pinecone import Pinecone, ServerlessSpec
from langchain.chat_models import ChatOpenAI
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage
from langgraph.graph.message import add_messages
from fastapi_server.agent.prompt import (
    document_type_system_prompt_agent2,
    proceedings_summary_prompt_agent2,
    internal_policy_summary_prompt_template_agent2,
    product_document_summary_prompt_template_agent2,
    technical_document_summary_prompt_template_agent2,
    unknown_document_type_prompt_agent2,
    rag_answer_generation_prompt_agent2,
    rag_system_message_agent2
)
load_dotenv()

def init_clients():
    # 1-1) OpenAI 클라이언트 생성
    openai_api_key = os.getenv("OPENAI_API_KEY")
    if not openai_api_key:
        raise ValueError("⚠️ 환경변수 OPENAI_API_KEY가 설정되지 않았습니다.")
    # OpenAI 인스턴스를 만듭니다.
    openai_client = OpenAI(api_key=openai_api_key)
    print("✅ OpenAI 클라이언트 생성 완료")

    # 1-2) Pinecone 인스턴스 생성
    pinecone_api_key = os.getenv("PINECONE_API_KEY")
    pinecone_env     = os.getenv("PINECONE_ENVIRONMENT")   # 예: "us-east1-gcp" 또는 "us-west1-gcp" 등
    if not pinecone_api_key or not pinecone_env:
        raise ValueError("⚠️ 환경변수 PINECONE_API_KEY 또는 PINECONE_ENVIRONMENT가 누락되었습니다.")

    pc = Pinecone(api_key=pinecone_api_key, environment=pinecone_env)
    print("✅ Pinecone 클라이언트 생성 완료")

    # 1-3) 인덱스 존재 여부 확인
    index_name = "dense-index"  # 실제 사용 중인 인덱스 이름으로 교체하세요
    existing_indexes = pc.list_indexes().names()
    if index_name not in existing_indexes:
        raise ValueError(f"⚠️ 인덱스 '{index_name}'가 Pinecone에 존재하지 않습니다. 현재 인덱스 목록: {existing_indexes}")

    # 1-4) 해당 인덱스 객체 가져오기
    index = pc.Index(index_name)
    print(f"✅ Pinecone 인덱스 '{index_name}' 연결 완료 (Namespaces: {len(index.describe_index_stats().namespaces)})")

    return openai_client, index


# --------------------------------------------------
# 2) 질문 문장을 임베딩 벡터로 변환
# --------------------------------------------------
def embed_query(openai_client: OpenAI, text: str) -> list:
    """
    최신 OpenAI 클라이언트에서는 resp.data[0].embedding 으로 벡터에 접근해야 합니다.
    """
    resp = openai_client.embeddings.create(
        model="text-embedding-3-large",
        input=text
    )
    return resp.data[0].embedding


# --------------------------------------------------
# 3) 여러 네임스페이스 중 “가장 높은 유사도”를 준 네임스페이스와 매칭 결과 반환
# --------------------------------------------------
def retrieve_best_namespace(index, query_vector: list, top_k: int = 5):
    """
    1) index.describe_index_stats()를 통해 모든 네임스페이스 목록을 얻는다.
    2) 각 네임스페이스별로 query_vector를 index.query()로 검색하고,
       matches[0].score 를 비교해서 “최고 유사도”를 찾는다.
    3) 가장 높은 유사도를 준 네임스페이스(best_ns)와 해당 네임스페이스의 전체 매칭 결과(best_matches)를 반환.
    """
    stats = index.describe_index_stats()
    available_namespaces = list(stats.namespaces.keys())
    if not available_namespaces:
        raise ValueError("⚠️ 인덱스에 네임스페이스가 없습니다.")

    best_ns = None
    best_score = -1.0
    best_matches = None

    for ns in available_namespaces:
        count = stats.namespaces[ns]["vector_count"]
        if count == 0:
            # 비어 있는 네임스페이스 건너뛰기
            continue

        res = index.query(
            vector=query_vector,
            namespace=ns,
            top_k=top_k,
            include_metadata=True
        )
        if not res.matches:
            continue

        top_score = res.matches[0].score
        if top_score > best_score:
            best_score = top_score
            best_ns = ns
            best_matches = res.matches

    if best_ns is None:
        raise ValueError("⚠️ 어떤 네임스페이스에서도 매칭 결과를 찾을 수 없습니다.")
    
    print(f"🔍 선택된 네임스페이스: '{best_ns}' (최고 유사도: {best_score:.4f})")
    return best_ns, best_matches


# --------------------------------------------------
# 4) 검색된 매칭 결과에서 실제 텍스트(메타데이터)를 꺼내 Context 로 결합
# --------------------------------------------------
def build_context_from_matches(matches):
    """
    res.matches 리스트 안의 각 item.metadata 에 들어 있는 텍스트 필드를 추출합니다.
    업로드 시 metadata 키가 "text"였다고 가정했습니다.
    """
    contexts = []
    for m in matches:
        chunk_text = m.metadata.get("text", "")
        if chunk_text:
            contexts.append(chunk_text)

    return "\n---\n".join(contexts)


# --------------------------------------------------
# 5) LLM ChatCompletion 호출하여 답변 생성
# --------------------------------------------------
def generate_answer_with_context(openai_client: OpenAI, question: str, context: str) -> str:
    """
    최신 OpenAI 클라이언트에서는 client.chat.completions.create(...) 형태를 씁니다.
    """
    formatted_prompt = rag_answer_generation_prompt_agent2.format(context=context, question=question)
    resp = openai_client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {"role": "system", "content": rag_system_message_agent2},
            {"role": "user", "content": formatted_prompt}
        ],
        temperature=0.0,
        max_tokens=1024
    )
    # resp.choices[0].message.content 으로 답변 추출
    return resp.choices[0].message.content.strip()



@dataclass
class State:
    # Compatible with both direct user_input and messages-based interface
    user_input: str = ""
    document_type: str = ""
    result: str = ""
    messages: Sequence[BaseMessage] = None
    
    def __post_init__(self):
        # If initialized from supervisor with messages but no user_input, extract user_input
        if not self.user_input and self.messages:
            # Extract user input from the last human message
            user_messages = [msg for msg in self.messages if isinstance(msg, HumanMessage)]
            if user_messages:
                self.user_input = user_messages[-1].content
    
    def dict(self):
        """Return dict representation with messages if present"""
        result = {
            "result": self.result,
            "document_type": self.document_type,
            "user_input": self.user_input
        }
        # If this was called with messages, return updated messages too
        if self.messages is not None:
            result["messages"] = self.messages + [AIMessage(content=self.result)] if self.result else self.messages
        return result  # 챗봇 결과


def choose_document_type(message):
    """
    OpenAI 클라이언트를 사용하여 문서 타입을 분류합니다. 리턴 데이터 형식은 기존과 동일하게 유지합니다.
    """
    client = OpenAI()
    formatted_prompt = document_type_system_prompt_agent2.format(user_input=message)
    
    resp = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {"role": "system", "content": formatted_prompt}
        ],
        temperature=0,
        max_tokens=100
    )
    
    classified_type = resp.choices[0].message.content.strip()
    print(f"문서 타입 분류 결과: {classified_type}")
    return classified_type

def choose_node(state: State):
    # Extract the user input from the state
    user_input = state.user_input

    # Choose document type
    document_type = choose_document_type(user_input)
    
    # Update state with document type
    state.document_type = document_type
    
    # Print document type for debugging
    # print(f"Document Type: {document_type}")
    
    return state.dict()

def choose_one(state: State) -> str:
    choice = state.document_type
    # Use logging instead of print to avoid output being captured in response
    # print(f"(choice_one) Choice: {choice}")
    # This must return the string key for conditional edge routing
    if choice in ["internal_policy", "product_document", "technical_document", "proceedings"]:
        return choice
    else:
        return "product_document"  # Default fallback

def execute_rag(state: State):
    # print(f"\n📄 RAG 노드 실행: 문서 타입 = '{state.document_type}', 질문 = '{state.user_input}'")
    openai_client, pinecone_index = init_clients()
    # print("   - 클라이언트 초기화 완료")

    query_vector = embed_query(openai_client, state.user_input)
    # print(f"   - 질문 임베딩 완료 (벡터 크기: {len(query_vector)})")

    namespace_to_search = state.document_type
    if not namespace_to_search or namespace_to_search == "unknown":
        message = f"문서 타입이 '{namespace_to_search}'(으)로 분류되어 Pinecone 검색을 수행하지 않습니다."
        # print(f"   - 정보: {message}")
        # 'unknown'일 경우, unknown_handler_node에서 이미 메시지를 설정했을 수 있으므로, 여기서는 덮어쓰지 않거나
        # 혹은 여기서 다른 메시지를 설정할 수 있습니다. 여기서는 검색 불가 메시지만 남깁니다.
        # 실제로는 'unknown' 타입은 이 노드로 오지 않고 unknown_handler_node로 가야 합니다.
        # 이 코드는 execute_rag_node가 'unknown' 타입으로 호출될 경우를 대비한 방어 코드입니다.
        state.result = "적절한 문서 저장소를 찾을 수 없어 검색을 수행할 수 없습니다."
        return state.dict()

    # print(f"   - Pinecone 네임스페이스 '{namespace_to_search}'에서 검색 시작...")
    index_stats = pinecone_index.describe_index_stats()
    if namespace_to_search not in index_stats.namespaces or \
        index_stats.namespaces[namespace_to_search].vector_count == 0:
        message = f"'{namespace_to_search}' 네임스페이스를 Pinecone에서 찾을 수 없거나, 해당 네임스페이스에 데이터가 없습니다. Pinecone 대시보드에서 네임스페이스 이름과 데이터 존재 여부를 확인해주세요."
        # print(f"   - 경고: {message}")
        state.result = message
        return state.dict()

    res = pinecone_index.query(
        vector=query_vector,
        namespace=namespace_to_search,
        top_k=5, # 검색할 문서 수
        include_metadata=True
    )
    matches = res.matches
    # print(f"   - Pinecone 검색 완료: {len(matches)}개 결과 수신")

    if not matches:
        message = f"'{namespace_to_search}' 네임스페이스에서 '{state.user_input}' 질문과 관련된 정보를 찾지 못했습니다."
        # print(f"   - 정보 없음: {message}")
        state.result = message
        return state.dict()
    
    context = build_context_from_matches(matches)
    if not context:
        message = "검색된 정보에서 답변을 생성할 컨텍스트를 추출하지 못했습니다."
        print(f"   - 컨텍스트 구축 실패: {message}")
        state.result = message
        return state.dict()
    print(f"   - 컨텍스트 구축 완료 (길이: {len(context)})")

    state.result = context
    return state.dict()
    

def summarize_node(state: State):
    text = state.result
    document_type = state.document_type
    user_input = state.user_input

    if state.document_type == "proceedings":
        system_message = proceedings_summary_prompt_agent2
    elif state.document_type == "internal_policy":
        system_message = internal_policy_summary_prompt_template_agent2.format(user_input=user_input)
    elif state.document_type == "product_document":
        system_message = product_document_summary_prompt_template_agent2.format(user_input=user_input)
    elif state.document_type == "technical_document":
        system_message = technical_document_summary_prompt_template_agent2.format(user_input=user_input)
    else: # unknown or fallback
        system_message = unknown_document_type_prompt_agent2
    
    system_message = SystemMessagePromptTemplate.from_template(system_message)
    human_message = HumanMessagePromptTemplate.from_template("{text}")

    chat_prompt = ChatPromptTemplate.from_messages([system_message, human_message])

    # 2. LLM 생성
    llm = ChatOpenAI(model="gpt-4o")

    # 3. Prompt와 LLM 결합
    chatbot = chat_prompt | llm

    # 4. 실행
    response = chatbot.invoke({"text": text})
    result = response.content
    # print(result)  # 디버깅용 출력 제거
    state.result = result
    
    # 문서 타입이 최종 결과에 포함되지 않도록, document_type을 제외한 상태만 반환
    result_state = state.dict()
    if "document_type" in result_state:
        # document_type 값이 최종 출력에 포함되지 않도록 제거
        del result_state["document_type"]
    
    return result_state

# 비동기 노드 래퍼 함수들 정의
async def async_choose_node(state: State):
    return await sync_to_async(choose_node)(state)

async def async_execute_rag(state: State):
    return await sync_to_async(execute_rag)(state)

async def async_summarize_node(state: State):
    return await sync_to_async(summarize_node)(state)

async def async_choose_one(state: State):
    return await sync_to_async(choose_one)(state)

# Define the graph with async nodes
graph = (
    StateGraph(State)
    # (1) choose_node 분기 노드 등록 (outputs에 리턴 키 명시)
    .add_node("choose_node", async_choose_node)
    # (2) RAG 실행 노드들 등록
    .add_node("product_node", async_execute_rag)
    .add_node("proceedings_node", async_execute_rag)
    .add_node("hr_policy_node", async_execute_rag)
    .add_node("technical_document_node", async_execute_rag)
    # (3) summarize_node 등록 (최종 노드)
    .add_node("summarize_node", async_summarize_node)
    # (4) START → 분기 노드(choose_node) → (next_node 값에 따라) 분기
    .add_edge(START,"choose_node")
    .add_conditional_edges(
        "choose_node",
        async_choose_one,
        {
            "product_document": "product_node",
            "proceedings": "proceedings_node",
            "internal_policy": "hr_policy_node",
            "technical_document": "technical_document_node"
        }
    )
    # (5) 각 RAG 노드 → summarize_node 연결
    .add_edge("product_node", "summarize_node")
    .add_edge("proceedings_node", "summarize_node")
    .add_edge("hr_policy_node", "summarize_node")
    .add_edge("technical_document_node", "summarize_node")
    .add_edge("summarize_node", END)
    # (6) 최종 컴파일
    .compile(name="New Graph")
)

IMPORTANT: Generate the `summary` and relationship `label` fields in **Korean** language. Do NOT use English for these fields.

Please provide:
1. A high-level `summary` of the project's main purpose and functionality in a few beginner-friendly sentences (in Korean). Use markdown formatting with **bold** and *italic* text to highlight important concepts.
2. A list (`relationships`) describing the key interactions between these abstractions. For each relationship, specify:
    - `from_abstraction`: Index of the source abstraction (e.g., `0 # AbstractionName1`)
    - `to_abstraction`: Index of the target abstraction (e.g., `1 # AbstractionName2`)
    - `label`: A brief label for the interaction **in just a few words** (in Korean) (e.g., "Manages", "Inherits", "Uses").
    Ideally the relationship should be backed by one abstraction calling or passing parameters to another.
    Simplify the relationship and exclude those non-important ones.

IMPORTANT: Make sure EVERY abstraction is involved in at least ONE relationship (either as source or target). Each abstraction index must appear at least once across all relationships.

Format the output as YAML:

```yaml
summary: |
  A brief, simple explanation of the project (in Korean).
  Can span multiple lines with **bold** and *italic* for emphasis.
relationships:
  - from_abstraction: 0 # AbstractionName1
    to_abstraction: 1 # AbstractionName2
    label: "Manages" (in Korean)
  - from_abstraction: 2 # AbstractionName3
    to_abstraction: 0 # AbstractionName1
    label: "Provides config" (in Korean)
  # ... other relationships
```

Now, provide the YAML output:

2025-06-30 00:17:17,836 - INFO - RESPONSE (from cache): ```yaml
summary: |
  이 프로젝트는 사용자가 자연어로 업무 요청을 하면, **AI 에이전트 총괄 시스템**이 *적절한 전문 에이전트*에 작업을 분배하여 처리하는 **지능형 사내 업무 보조 챗봇 시스템**입니다.
  FastAPI를 통한 **실시간 AI 통신 게이트웨이**를 통해 사용자와 AI 시스템 간의 데이터를 교환하며, 문서 검색, 데이터 분석 등의 기능을 제공합니다.

relationships:
  - from_abstraction: 0 # AI 에이전트 총괄 시스템 (LangGraph Supervisor)
    to_abstraction: 1 # 문서 검색 전문 에이전트 (RAG Agent)
    label: "작업 분배"
  - from_abstraction: 0 # AI 에이전트 총괄 시스템 (LangGraph Supervisor)
    to_abstraction: 2 # 데이터 분석 전문 에이전트 (Analytics Agent)
    label: "작업 분배"
  - from_abstraction: 0 # AI 에이전트 총괄 시스템 (LangGraph Supervisor)
    to_abstraction: 3 # FastAPI 서버
    label: "통신"
  - from_abstraction: 2 # 데이터 분석 전문 에이전트 (Analytics Agent)
    to_abstraction: 7 # MLOps 관리 (MLOps Management)
    label: "모델 결과 저장"
  - from_abstraction: 1 # 문서 검색 전문 에이전트 (RAG Agent)
    to_abstraction: 6 # 지식베이스 관리 (Knowledge Management)
    label: "문서 검색"
  - from_abstraction: 4 # 계정 관리 모듈 (Accounts Module)
    to_abstraction: 5 # 챗봇 세션 관리 (Chat Session Management)
    label: "사용자 관리"
  - from_abstraction: 5 # 챗봇 세션 관리 (Chat Session Management)
    to_abstraction: 9 # 백엔드 라우팅 (Backend Routing)
    label: "요청 처리"
  - from_abstraction: 3 # FastAPI 서버
    to_abstraction: 8 # 환경 설정 및 배포 (Environment Setup and Deployment)
    label: "배포"
  - from_abstraction: 3 # FastAPI 서버
    to_abstraction: 0 # AI 에이전트 총괄 시스템 (LangGraph Supervisor)
    label: "연동"
```
2025-06-30 00:17:18,196 - INFO - PROMPT: 
Given the following project abstractions and their relationships for the project ```` SKN10-FINAL-1Team ````:

Abstractions (Index # Name) (Names might be in Korean):
- 0 # AI 에이전트 총괄 시스템 (LangGraph Supervisor)
- 1 # 문서 검색 전문 에이전트 (RAG Agent)
- 2 # 데이터 분석 전문 에이전트 (Analytics Agent)
- 3 # FastAPI 서버
- 4 # 계정 관리 모듈 (Accounts Module)
- 5 # 챗봇 세션 관리 (Chat Session Management)
- 6 # 지식베이스 관리 (Knowledge Management)
- 7 # MLOps 관리 (MLOps Management)
- 8 # 환경 설정 및 배포 (Environment Setup and Deployment)
- 9 # 백엔드 라우팅 (Backend Routing)

Context about relationships and project summary:
Project Summary (Note: Project Summary might be in Korean):
이 프로젝트는 사용자가 자연어로 업무 요청을 하면, **AI 에이전트 총괄 시스템**이 *적절한 전문 에이전트*에 작업을 분배하여 처리하는 **지능형 사내 업무 보조 챗봇 시스템**입니다.
FastAPI를 통한 **실시간 AI 통신 게이트웨이**를 통해 사용자와 AI 시스템 간의 데이터를 교환하며, 문서 검색, 데이터 분석 등의 기능을 제공합니다.


Relationships (Indices refer to abstractions above):
- From 0 (AI 에이전트 총괄 시스템 (LangGraph Supervisor)) to 1 (문서 검색 전문 에이전트 (RAG Agent)): 작업 분배
- From 0 (AI 에이전트 총괄 시스템 (LangGraph Supervisor)) to 2 (데이터 분석 전문 에이전트 (Analytics Agent)): 작업 분배
- From 0 (AI 에이전트 총괄 시스템 (LangGraph Supervisor)) to 3 (FastAPI 서버): 통신
- From 2 (데이터 분석 전문 에이전트 (Analytics Agent)) to 7 (MLOps 관리 (MLOps Management)): 모델 결과 저장
- From 1 (문서 검색 전문 에이전트 (RAG Agent)) to 6 (지식베이스 관리 (Knowledge Management)): 문서 검색
- From 4 (계정 관리 모듈 (Accounts Module)) to 5 (챗봇 세션 관리 (Chat Session Management)): 사용자 관리
- From 5 (챗봇 세션 관리 (Chat Session Management)) to 9 (백엔드 라우팅 (Backend Routing)): 요청 처리
- From 3 (FastAPI 서버) to 8 (환경 설정 및 배포 (Environment Setup and Deployment)): 배포
- From 3 (FastAPI 서버) to 0 (AI 에이전트 총괄 시스템 (LangGraph Supervisor)): 연동


If you are going to make a tutorial for ```` SKN10-FINAL-1Team ````, what is the best order to explain these abstractions, from first to last?
Ideally, first explain those that are the most important or foundational, perhaps user-facing concepts or entry points. Then move to more detailed, lower-level implementation details or supporting concepts.

Output the ordered list of abstraction indices, including the name in a comment for clarity. Use the format `idx # AbstractionName`.

```yaml
- 2 # FoundationalConcept
- 0 # CoreClassA
- 1 # CoreClassB (uses CoreClassA)
- ...
```

Now, provide the YAML output:

2025-06-30 00:17:18,205 - INFO - RESPONSE (from cache): ```yaml
- 0 # AI 에이전트 총괄 시스템 (LangGraph Supervisor)
- 3 # FastAPI 서버
- 4 # 계정 관리 모듈 (Accounts Module)
- 5 # 챗봇 세션 관리 (Chat Session Management)
- 9 # 백엔드 라우팅 (Backend Routing)
- 1 # 문서 검색 전문 에이전트 (RAG Agent)
- 6 # 지식베이스 관리 (Knowledge Management)
- 2 # 데이터 분석 전문 에이전트 (Analytics Agent)
- 7 # MLOps 관리 (MLOps Management)
- 8 # 환경 설정 및 배포 (Environment Setup and Deployment)
```
2025-06-30 00:17:18,565 - INFO - PROMPT: 
IMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.

Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `SKN10-FINAL-1Team` about the concept: "AI 에이전트 총괄 시스템 (LangGraph Supervisor)". This is Chapter 1.

Concept Details (Note: Provided in Korean):
- Name: AI 에이전트 총괄 시스템 (LangGraph Supervisor)
- Description:
사용자의 자연어 요청을 분석하여 적합한 전문 에이전트에 작업을 분배하는 시스템입니다. (System that analyzes user natural language requests and routes tasks to appropriate specialized agents.)

Complete Tutorial Structure (Note: Chapter names might be in Korean):
1. [AI 에이전트 총괄 시스템 (LangGraph Supervisor)](01_ai_에이전트_총괄_시스템__langgraph_supervisor_.md)
2. [FastAPI 서버](02_fastapi_서버.md)
3. [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)
4. [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)
5. [백엔드 라우팅 (Backend Routing)](05_백엔드_라우팅__backend_routing_.md)
6. [문서 검색 전문 에이전트 (RAG Agent)](06_문서_검색_전문_에이전트__rag_agent_.md)
7. [지식베이스 관리 (Knowledge Management)](07_지식베이스_관리__knowledge_management_.md)
8. [데이터 분석 전문 에이전트 (Analytics Agent)](08_데이터_분석_전문_에이전트__analytics_agent_.md)
9. [MLOps 관리 (MLOps Management)](09_mlops_관리__mlops_management_.md)
10. [환경 설정 및 배포 (Environment Setup and Deployment)](10_환경_설정_및_배포__environment_setup_and_deployment_.md)

Context from previous chapters (Note: This summary might be in Korean):
This is the first chapter.

Relevant Code Snippets (Code itself remains unchanged):
No specific code snippets provided for this abstraction.

Instructions for the chapter (Generate content in Korean unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 1: AI 에이전트 총괄 시스템 (LangGraph Supervisor)`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).

- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).

- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).

- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).

- Heavily use analogies and examples throughout (in Korean) to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).

- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-06-30 00:17:18,791 - INFO - Using OpenAI model: gpt-4o
2025-06-30 00:17:33,189 - INFO - RESPONSE: # Chapter 1: AI 에이전트 총괄 시스템 (LangGraph Supervisor)

## 소개

우리가 상상하는 미래의 세계에서는 다양한 AI 에이전트가 우리의 일상 속에서 많은 역할을 하게 될 것입니다. 이 장에서는 사용자의 자연어 요청을 신속하고 정확하게 분석하여 적합한 전문 에이전트에게 작업을 분배하는 시스템인 **AI 에이전트 총괄 시스템 (LangGraph Supervisor)**를 소개합니다.

## 왜 AI 에이전트 총괄 시스템이 필요한가요?

### 문제에 대한 개요

어느 날, 당신은 다수의 AI 전문 에이전트를 관리하는 프로젝트의 관리자입니다. 고객이 다양한 요구를 AI에게 요청하지만 그 요청마다 다른 전문 에이전트로 보내야 합니다. 예를 들어, 문서 검색이 필요한 경우에는 '문서 검색 전문 에이전트', 데이터 분석이 필요한 경우에는 '데이터 분석 전문 에이전트'가 필요합니다.

AI 에이전트 총괄 시스템은 이러한 문제를 해결하기 위해 만들어졌습니다. 사용자가 보내는 자연어 요청을 효과적으로 해석하고, 적합한 에이전트로 작업을 분배합니다.

### 핵심 개념 설명

1. **자연어 처리 (Natural Language Processing)**: 사용자의 요청을 분석하기 위해 사용됩니다. 텍스트를 이해하고 그 의미를 파악합니다.

2. **에이전트 라우팅**: 각 에이전트는 서로 다른 전문 분야를 가지고 있으며, 요청에 가장 적합한 에이전트에게 작업을 보내기 위한 과정입니다.

## AI 에이전트 총괄 시스템 사용 방법

이 시스템을 이해하는 것을 용이하게 하기 위해, 우리는 간단한 예제를 통해 따라가 볼 것입니다.

### 간단한 구현 예제

```python
def 언어_분석(요청):
    # 요청의 내용을 분석하여 필요한 에이전트를 결정함
    if "데이터 분석" in 요청:
        return "데이터 분석 전문 에이전트"
    elif "문서 검색" in 요청:
        return "문서 검색 전문 에이전트"
    else:
        return "일반 에이전트"

결정된_에이전트 = 언어_분석("문서 검색을 원해요")
print(결정된_에이전트)  # 출력: 문서 검색 전문 에이전트
```

위의 코드는 사용자의 요청을 간단히 분석하고, 해당 요청을 가장 잘 수행할 에이전트를 선정하는 프로세스를 보여줍니다.

### 내부 구현

시스템이 어떻게 내부적으로 작동하는지 더 잘 이해하기 위해, 몇 가지 과정을 단계별로 나누어 설명하겠습니다.

#### 시스템 작동 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 시스템 as LangGraph Supervisor
    participant 에이전트1 as 문서 검색 전문 에이전트
    participant 에이전트2 as 데이터 분석 전문 에이전트
    사용자->>시스템: 자연어 요청 전송
    시스템->>사용자: 요청 분석
    시스템->>에이전트1: 적합한 에이전트로 요청 전달
    에이전트1->>시스템: 작업 수행 후 결과 반환
    시스템->>사용자: 결과 전송
```

1. 사용자는 자연어 요청을 시스템에 보냅니다.
2. 시스템은 요청을 분석하여 필요한 에이전트를 결정합니다.
3. 적합한 에이전트에게 요청을 보냅니다.
4. 에이전트는 작업을 수행 후 시스템에 결과를 반환합니다.
5. 시스템은 결과를 사용자에게 전달합니다.

#### 코드 예제

이제, 시스템 내부에서 언어 분석과 라우팅이 어떻게 이루어지는지 코드 레벨에서 예를 들어 보겠습니다.

```python
class LangGraphSupervisor:
    def __init__(self):
        self.agents = {
            "문서 검색": "문서 검색 전문 에이전트",
            "데이터 분석": "데이터 분석 전문 에이전트"
        }

    def 분석후_라우팅(self, 요청):
        for 키워드, 에이전트 in self.agents.items():
            if 키워드 in 요청:
                return 에이전트
        return "일반 에이전트"

supervisor = LangGraphSupervisor()
에이전트 = supervisor.분석후_라우팅("데이터 분석을 요청합니다")
print(에이전트)  # 출력: 데이터 분석 전문 에이전트
```

이 코드에서는 요청을 처리 및 분배하는 `LangGraphSupervisor` 클래스의 구조를 보여줍니다.

## 결론

이 장에서는 AI 에이전트 총괄 시스템의 핵심 개념과 사용 방법을 배웠습니다. 이 시스템은 사용자의 자연어 요청을 분석하고 적절한 에이전트로 작업을 분배하는 것을 목표로 합니다. 다음 장에서는 이 시스템을 구동할 서버 [FastAPI 서버](02_fastapi_서버.md)에 대해 알아봅니다.
2025-06-30 00:17:33,206 - INFO - PROMPT: 
IMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.

Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `SKN10-FINAL-1Team` about the concept: "FastAPI 서버". This is Chapter 2.

Concept Details (Note: Provided in Korean):
- Name: FastAPI 서버
- Description:
실시간 AI 통신을 처리하며, 사용자와 AI 시스템 간의 데이터 교환을 담당하는 서버입니다. (Server that handles real-time AI communication and exchanges data between users and AI systems.)

Complete Tutorial Structure (Note: Chapter names might be in Korean):
1. [AI 에이전트 총괄 시스템 (LangGraph Supervisor)](01_ai_에이전트_총괄_시스템__langgraph_supervisor_.md)
2. [FastAPI 서버](02_fastapi_서버.md)
3. [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)
4. [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)
5. [백엔드 라우팅 (Backend Routing)](05_백엔드_라우팅__backend_routing_.md)
6. [문서 검색 전문 에이전트 (RAG Agent)](06_문서_검색_전문_에이전트__rag_agent_.md)
7. [지식베이스 관리 (Knowledge Management)](07_지식베이스_관리__knowledge_management_.md)
8. [데이터 분석 전문 에이전트 (Analytics Agent)](08_데이터_분석_전문_에이전트__analytics_agent_.md)
9. [MLOps 관리 (MLOps Management)](09_mlops_관리__mlops_management_.md)
10. [환경 설정 및 배포 (Environment Setup and Deployment)](10_환경_설정_및_배포__environment_setup_and_deployment_.md)

Context from previous chapters (Note: This summary might be in Korean):
# Chapter 1: AI 에이전트 총괄 시스템 (LangGraph Supervisor)

## 소개

우리가 상상하는 미래의 세계에서는 다양한 AI 에이전트가 우리의 일상 속에서 많은 역할을 하게 될 것입니다. 이 장에서는 사용자의 자연어 요청을 신속하고 정확하게 분석하여 적합한 전문 에이전트에게 작업을 분배하는 시스템인 **AI 에이전트 총괄 시스템 (LangGraph Supervisor)**를 소개합니다.

## 왜 AI 에이전트 총괄 시스템이 필요한가요?

### 문제에 대한 개요

어느 날, 당신은 다수의 AI 전문 에이전트를 관리하는 프로젝트의 관리자입니다. 고객이 다양한 요구를 AI에게 요청하지만 그 요청마다 다른 전문 에이전트로 보내야 합니다. 예를 들어, 문서 검색이 필요한 경우에는 '문서 검색 전문 에이전트', 데이터 분석이 필요한 경우에는 '데이터 분석 전문 에이전트'가 필요합니다.

AI 에이전트 총괄 시스템은 이러한 문제를 해결하기 위해 만들어졌습니다. 사용자가 보내는 자연어 요청을 효과적으로 해석하고, 적합한 에이전트로 작업을 분배합니다.

### 핵심 개념 설명

1. **자연어 처리 (Natural Language Processing)**: 사용자의 요청을 분석하기 위해 사용됩니다. 텍스트를 이해하고 그 의미를 파악합니다.

2. **에이전트 라우팅**: 각 에이전트는 서로 다른 전문 분야를 가지고 있으며, 요청에 가장 적합한 에이전트에게 작업을 보내기 위한 과정입니다.

## AI 에이전트 총괄 시스템 사용 방법

이 시스템을 이해하는 것을 용이하게 하기 위해, 우리는 간단한 예제를 통해 따라가 볼 것입니다.

### 간단한 구현 예제

```python
def 언어_분석(요청):
    # 요청의 내용을 분석하여 필요한 에이전트를 결정함
    if "데이터 분석" in 요청:
        return "데이터 분석 전문 에이전트"
    elif "문서 검색" in 요청:
        return "문서 검색 전문 에이전트"
    else:
        return "일반 에이전트"

결정된_에이전트 = 언어_분석("문서 검색을 원해요")
print(결정된_에이전트)  # 출력: 문서 검색 전문 에이전트
```

위의 코드는 사용자의 요청을 간단히 분석하고, 해당 요청을 가장 잘 수행할 에이전트를 선정하는 프로세스를 보여줍니다.

### 내부 구현

시스템이 어떻게 내부적으로 작동하는지 더 잘 이해하기 위해, 몇 가지 과정을 단계별로 나누어 설명하겠습니다.

#### 시스템 작동 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 시스템 as LangGraph Supervisor
    participant 에이전트1 as 문서 검색 전문 에이전트
    participant 에이전트2 as 데이터 분석 전문 에이전트
    사용자->>시스템: 자연어 요청 전송
    시스템->>사용자: 요청 분석
    시스템->>에이전트1: 적합한 에이전트로 요청 전달
    에이전트1->>시스템: 작업 수행 후 결과 반환
    시스템->>사용자: 결과 전송
```

1. 사용자는 자연어 요청을 시스템에 보냅니다.
2. 시스템은 요청을 분석하여 필요한 에이전트를 결정합니다.
3. 적합한 에이전트에게 요청을 보냅니다.
4. 에이전트는 작업을 수행 후 시스템에 결과를 반환합니다.
5. 시스템은 결과를 사용자에게 전달합니다.

#### 코드 예제

이제, 시스템 내부에서 언어 분석과 라우팅이 어떻게 이루어지는지 코드 레벨에서 예를 들어 보겠습니다.

```python
class LangGraphSupervisor:
    def __init__(self):
        self.agents = {
            "문서 검색": "문서 검색 전문 에이전트",
            "데이터 분석": "데이터 분석 전문 에이전트"
        }

    def 분석후_라우팅(self, 요청):
        for 키워드, 에이전트 in self.agents.items():
            if 키워드 in 요청:
                return 에이전트
        return "일반 에이전트"

supervisor = LangGraphSupervisor()
에이전트 = supervisor.분석후_라우팅("데이터 분석을 요청합니다")
print(에이전트)  # 출력: 데이터 분석 전문 에이전트
```

이 코드에서는 요청을 처리 및 분배하는 `LangGraphSupervisor` 클래스의 구조를 보여줍니다.

## 결론

이 장에서는 AI 에이전트 총괄 시스템의 핵심 개념과 사용 방법을 배웠습니다. 이 시스템은 사용자의 자연어 요청을 분석하고 적절한 에이전트로 작업을 분배하는 것을 목표로 합니다. 다음 장에서는 이 시스템을 구동할 서버 [FastAPI 서버](02_fastapi_서버.md)에 대해 알아봅니다.

Relevant Code Snippets (Code itself remains unchanged):
No specific code snippets provided for this abstraction.

Instructions for the chapter (Generate content in Korean unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 2: FastAPI 서버`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).

- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).

- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).

- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).

- Heavily use analogies and examples throughout (in Korean) to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).

- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-06-30 00:17:33,396 - INFO - Using OpenAI model: gpt-4o
2025-06-30 00:17:47,869 - INFO - RESPONSE: 
# Chapter 2: FastAPI 서버

이전 장에서는 [AI 에이전트 총괄 시스템 (LangGraph Supervisor)](01_ai_에이전트_총괄_시스템__langgraph_supervisor_.md)에 대해 알아보았습니다. 이번 장에서는 이러한 시스템이 원활하게 작동하기 위해 필요한 서버 기술인 **FastAPI 서버**에 대해 설명하겠습니다.

FastAPI 서버는 실시간 AI 통신을 처리하며, 사용자와 AI 시스템 간의 데이터 교환을 담당하는 중요한 역할을 합니다. 이 장에서는 FastAPI 서버의 기본적인 개념과 구현 방법을 이해하고, 실제로 간단한 서버를 만들어 보는 것을 목표로 합니다.

## FastAPI 서버의 동기

FastAPI 서버는 왜 필요한 걸까요? FastAPI는 Python 기반의 웹 프레임워크로, 빠르고 효율적인 API를 구축하는 데 사용됩니다. 이것은 특히 AI 시스템과의 빠른 데이터 교환에 최적화되어 있습니다. 예를 들어, 사용자가 챗봇에게 질문을 하거나 AI 분석 결과를 요청하는 시나리오에서 실시간으로 응답을 받아야 합니다. FastAPI는 이러한 요구 사항을 충족시킬 수 있는 솔루션입니다.

### 주요 개념 설명

#### 1. 경량 웹 프레임워크

- FastAPI는 경량 프레임워크로, 쉽고 빠르게 서버를 구축할 수 있습니다.
- 비동기식 처리(Asynchronous Handling)를 통해 높은 처리 성능을 제공합니다.

#### 2. 자동 문서화

- FastAPI는 API 엔드포인트에 대한 자동 문서화 기능을 제공합니다.
- 이는 개발자가 API를 쉽게 이해하고 사용할 수 있도록 돕습니다.

## FastAPI 서버 사용 방법

이제 FastAPI를 사용하여 간단한 서버를 구축하는 방법을 따라해보겠습니다.

### FastAPI 설치

우선 FastAPI를 설치해야 합니다. Python 패키지 매니저인 pip를 통해 설치할 수 있습니다.

```bash
pip install fastapi
pip install uvicorn
```

- `fastapi`: FastAPI 프레임워크 설치
- `uvicorn`: FastAPI 애플리케이션을 실행하기 위한 ASGI 서버

### 간단한 FastAPI 서버 구현

아래는 FastAPI를 사용하여 간단한 서버를 구축하는 코드입니다.

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def 읽기_루트():
    return {"메시지": "Hello World!"}
```

- `FastAPI()`: 새로운 FastAPI 애플리케이션 인스턴스를 생성합니다.
- `@app.get("/")`: 루트 URL에서 GET 요청을 처리합니다.
- `읽기_루트()`: 루트 URL에 접근할 때 반환할 메시지를 정의합니다.

### 서버 실행

FastAPI 애플리케이션을 실행하려면 Uvicorn을 사용합니다.

```bash
uvicorn main:app --reload
```

- `main:app`: main.py 파일의 `app` 객체를 실행합니다.
- `--reload`: 코드 변경 시 서버를 자동으로 다시 시작합니다.

## FastAPI 서버의 내부 구현

FastAPI 서버가 어떻게 내부적으로 작동하는지 알아보겠습니다. FastAPI는 비동기 처리 방식으로 요청을 처리합니다. 아래의 시퀀스 다이어그램은 간단한 HTTP 요청 프로세스를 보여줍니다.

```mermaid
sequenceDiagram
    participant 고객 as 고객
    participant 서버 as FastAPI 서버
    고객->>서버: HTTP 요청 전송
    서버->>고객: 응답 전달
```

1. 고객이 서버로 HTTP 요청을 보냅니다.
2. FastAPI 서버는 요청을 처리하고 적절한 응답을 생성합니다.
3. 응답이 고객에게 전달됩니다.

이제 FastAPI의 코드 구조를 통해 더 깊이 들어가 보겠습니다.

```python
from fastapi import FastAPI, HTTPException

app = FastAPI()

@app.get("/items/{item_id}")
def 읽기_아이템(item_id: int):
    # 데이터베이스에서 항목 찾기 (예시를 위한 간단한 로직)
    if item_id not in [1, 2, 3]:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"item_id": item_id, "값": "여기에 데이터가 들어갑니다"}
```

- `HTTPException`: FastAPI에서 에러 응답을 생성할 때 사용합니다.
- `@app.get("/items/{item_id}")`: 경로 매개변수 `item_id`를 사용하여 특정 아이템에 대한 정보를 요청할 수 있습니다.

## 결론

이번 장에서는 FastAPI 서버의 기본 개념과 이를 사용하여 간단한 웹 애플리케이션을 구축하는 방법을 배웠습니다. FastAPI는 실시간으로 AI 및 사용자의 데이터 교환을 처리하는 데 최적화되어 있습니다. 이제 다음 장에서는 [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)로 이동해 보겠습니다. 이는 사용자의 계정 및 인증 관리를 담당하는 중요한 모듈입니다.
2025-06-30 00:17:47,886 - INFO - PROMPT: 
IMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.

Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `SKN10-FINAL-1Team` about the concept: "계정 관리 모듈 (Accounts Module)". This is Chapter 3.

Concept Details (Note: Provided in Korean):
- Name: 계정 관리 모듈 (Accounts Module)
- Description:
사용자와 조직 정보를 관리하고 인증 처리 기능을 제공하는 모듈입니다. (Module that manages user and organization information and provides authentication functions.)

Complete Tutorial Structure (Note: Chapter names might be in Korean):
1. [AI 에이전트 총괄 시스템 (LangGraph Supervisor)](01_ai_에이전트_총괄_시스템__langgraph_supervisor_.md)
2. [FastAPI 서버](02_fastapi_서버.md)
3. [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)
4. [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)
5. [백엔드 라우팅 (Backend Routing)](05_백엔드_라우팅__backend_routing_.md)
6. [문서 검색 전문 에이전트 (RAG Agent)](06_문서_검색_전문_에이전트__rag_agent_.md)
7. [지식베이스 관리 (Knowledge Management)](07_지식베이스_관리__knowledge_management_.md)
8. [데이터 분석 전문 에이전트 (Analytics Agent)](08_데이터_분석_전문_에이전트__analytics_agent_.md)
9. [MLOps 관리 (MLOps Management)](09_mlops_관리__mlops_management_.md)
10. [환경 설정 및 배포 (Environment Setup and Deployment)](10_환경_설정_및_배포__environment_setup_and_deployment_.md)

Context from previous chapters (Note: This summary might be in Korean):
# Chapter 1: AI 에이전트 총괄 시스템 (LangGraph Supervisor)

## 소개

우리가 상상하는 미래의 세계에서는 다양한 AI 에이전트가 우리의 일상 속에서 많은 역할을 하게 될 것입니다. 이 장에서는 사용자의 자연어 요청을 신속하고 정확하게 분석하여 적합한 전문 에이전트에게 작업을 분배하는 시스템인 **AI 에이전트 총괄 시스템 (LangGraph Supervisor)**를 소개합니다.

## 왜 AI 에이전트 총괄 시스템이 필요한가요?

### 문제에 대한 개요

어느 날, 당신은 다수의 AI 전문 에이전트를 관리하는 프로젝트의 관리자입니다. 고객이 다양한 요구를 AI에게 요청하지만 그 요청마다 다른 전문 에이전트로 보내야 합니다. 예를 들어, 문서 검색이 필요한 경우에는 '문서 검색 전문 에이전트', 데이터 분석이 필요한 경우에는 '데이터 분석 전문 에이전트'가 필요합니다.

AI 에이전트 총괄 시스템은 이러한 문제를 해결하기 위해 만들어졌습니다. 사용자가 보내는 자연어 요청을 효과적으로 해석하고, 적합한 에이전트로 작업을 분배합니다.

### 핵심 개념 설명

1. **자연어 처리 (Natural Language Processing)**: 사용자의 요청을 분석하기 위해 사용됩니다. 텍스트를 이해하고 그 의미를 파악합니다.

2. **에이전트 라우팅**: 각 에이전트는 서로 다른 전문 분야를 가지고 있으며, 요청에 가장 적합한 에이전트에게 작업을 보내기 위한 과정입니다.

## AI 에이전트 총괄 시스템 사용 방법

이 시스템을 이해하는 것을 용이하게 하기 위해, 우리는 간단한 예제를 통해 따라가 볼 것입니다.

### 간단한 구현 예제

```python
def 언어_분석(요청):
    # 요청의 내용을 분석하여 필요한 에이전트를 결정함
    if "데이터 분석" in 요청:
        return "데이터 분석 전문 에이전트"
    elif "문서 검색" in 요청:
        return "문서 검색 전문 에이전트"
    else:
        return "일반 에이전트"

결정된_에이전트 = 언어_분석("문서 검색을 원해요")
print(결정된_에이전트)  # 출력: 문서 검색 전문 에이전트
```

위의 코드는 사용자의 요청을 간단히 분석하고, 해당 요청을 가장 잘 수행할 에이전트를 선정하는 프로세스를 보여줍니다.

### 내부 구현

시스템이 어떻게 내부적으로 작동하는지 더 잘 이해하기 위해, 몇 가지 과정을 단계별로 나누어 설명하겠습니다.

#### 시스템 작동 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 시스템 as LangGraph Supervisor
    participant 에이전트1 as 문서 검색 전문 에이전트
    participant 에이전트2 as 데이터 분석 전문 에이전트
    사용자->>시스템: 자연어 요청 전송
    시스템->>사용자: 요청 분석
    시스템->>에이전트1: 적합한 에이전트로 요청 전달
    에이전트1->>시스템: 작업 수행 후 결과 반환
    시스템->>사용자: 결과 전송
```

1. 사용자는 자연어 요청을 시스템에 보냅니다.
2. 시스템은 요청을 분석하여 필요한 에이전트를 결정합니다.
3. 적합한 에이전트에게 요청을 보냅니다.
4. 에이전트는 작업을 수행 후 시스템에 결과를 반환합니다.
5. 시스템은 결과를 사용자에게 전달합니다.

#### 코드 예제

이제, 시스템 내부에서 언어 분석과 라우팅이 어떻게 이루어지는지 코드 레벨에서 예를 들어 보겠습니다.

```python
class LangGraphSupervisor:
    def __init__(self):
        self.agents = {
            "문서 검색": "문서 검색 전문 에이전트",
            "데이터 분석": "데이터 분석 전문 에이전트"
        }

    def 분석후_라우팅(self, 요청):
        for 키워드, 에이전트 in self.agents.items():
            if 키워드 in 요청:
                return 에이전트
        return "일반 에이전트"

supervisor = LangGraphSupervisor()
에이전트 = supervisor.분석후_라우팅("데이터 분석을 요청합니다")
print(에이전트)  # 출력: 데이터 분석 전문 에이전트
```

이 코드에서는 요청을 처리 및 분배하는 `LangGraphSupervisor` 클래스의 구조를 보여줍니다.

## 결론

이 장에서는 AI 에이전트 총괄 시스템의 핵심 개념과 사용 방법을 배웠습니다. 이 시스템은 사용자의 자연어 요청을 분석하고 적절한 에이전트로 작업을 분배하는 것을 목표로 합니다. 다음 장에서는 이 시스템을 구동할 서버 [FastAPI 서버](02_fastapi_서버.md)에 대해 알아봅니다.
---

# Chapter 2: FastAPI 서버

이전 장에서는 [AI 에이전트 총괄 시스템 (LangGraph Supervisor)](01_ai_에이전트_총괄_시스템__langgraph_supervisor_.md)에 대해 알아보았습니다. 이번 장에서는 이러한 시스템이 원활하게 작동하기 위해 필요한 서버 기술인 **FastAPI 서버**에 대해 설명하겠습니다.

FastAPI 서버는 실시간 AI 통신을 처리하며, 사용자와 AI 시스템 간의 데이터 교환을 담당하는 중요한 역할을 합니다. 이 장에서는 FastAPI 서버의 기본적인 개념과 구현 방법을 이해하고, 실제로 간단한 서버를 만들어 보는 것을 목표로 합니다.

## FastAPI 서버의 동기

FastAPI 서버는 왜 필요한 걸까요? FastAPI는 Python 기반의 웹 프레임워크로, 빠르고 효율적인 API를 구축하는 데 사용됩니다. 이것은 특히 AI 시스템과의 빠른 데이터 교환에 최적화되어 있습니다. 예를 들어, 사용자가 챗봇에게 질문을 하거나 AI 분석 결과를 요청하는 시나리오에서 실시간으로 응답을 받아야 합니다. FastAPI는 이러한 요구 사항을 충족시킬 수 있는 솔루션입니다.

### 주요 개념 설명

#### 1. 경량 웹 프레임워크

- FastAPI는 경량 프레임워크로, 쉽고 빠르게 서버를 구축할 수 있습니다.
- 비동기식 처리(Asynchronous Handling)를 통해 높은 처리 성능을 제공합니다.

#### 2. 자동 문서화

- FastAPI는 API 엔드포인트에 대한 자동 문서화 기능을 제공합니다.
- 이는 개발자가 API를 쉽게 이해하고 사용할 수 있도록 돕습니다.

## FastAPI 서버 사용 방법

이제 FastAPI를 사용하여 간단한 서버를 구축하는 방법을 따라해보겠습니다.

### FastAPI 설치

우선 FastAPI를 설치해야 합니다. Python 패키지 매니저인 pip를 통해 설치할 수 있습니다.

```bash
pip install fastapi
pip install uvicorn
```

- `fastapi`: FastAPI 프레임워크 설치
- `uvicorn`: FastAPI 애플리케이션을 실행하기 위한 ASGI 서버

### 간단한 FastAPI 서버 구현

아래는 FastAPI를 사용하여 간단한 서버를 구축하는 코드입니다.

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def 읽기_루트():
    return {"메시지": "Hello World!"}
```

- `FastAPI()`: 새로운 FastAPI 애플리케이션 인스턴스를 생성합니다.
- `@app.get("/")`: 루트 URL에서 GET 요청을 처리합니다.
- `읽기_루트()`: 루트 URL에 접근할 때 반환할 메시지를 정의합니다.

### 서버 실행

FastAPI 애플리케이션을 실행하려면 Uvicorn을 사용합니다.

```bash
uvicorn main:app --reload
```

- `main:app`: main.py 파일의 `app` 객체를 실행합니다.
- `--reload`: 코드 변경 시 서버를 자동으로 다시 시작합니다.

## FastAPI 서버의 내부 구현

FastAPI 서버가 어떻게 내부적으로 작동하는지 알아보겠습니다. FastAPI는 비동기 처리 방식으로 요청을 처리합니다. 아래의 시퀀스 다이어그램은 간단한 HTTP 요청 프로세스를 보여줍니다.

```mermaid
sequenceDiagram
    participant 고객 as 고객
    participant 서버 as FastAPI 서버
    고객->>서버: HTTP 요청 전송
    서버->>고객: 응답 전달
```

1. 고객이 서버로 HTTP 요청을 보냅니다.
2. FastAPI 서버는 요청을 처리하고 적절한 응답을 생성합니다.
3. 응답이 고객에게 전달됩니다.

이제 FastAPI의 코드 구조를 통해 더 깊이 들어가 보겠습니다.

```python
from fastapi import FastAPI, HTTPException

app = FastAPI()

@app.get("/items/{item_id}")
def 읽기_아이템(item_id: int):
    # 데이터베이스에서 항목 찾기 (예시를 위한 간단한 로직)
    if item_id not in [1, 2, 3]:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"item_id": item_id, "값": "여기에 데이터가 들어갑니다"}
```

- `HTTPException`: FastAPI에서 에러 응답을 생성할 때 사용합니다.
- `@app.get("/items/{item_id}")`: 경로 매개변수 `item_id`를 사용하여 특정 아이템에 대한 정보를 요청할 수 있습니다.

## 결론

이번 장에서는 FastAPI 서버의 기본 개념과 이를 사용하여 간단한 웹 애플리케이션을 구축하는 방법을 배웠습니다. FastAPI는 실시간으로 AI 및 사용자의 데이터 교환을 처리하는 데 최적화되어 있습니다. 이제 다음 장에서는 [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)로 이동해 보겠습니다. 이는 사용자의 계정 및 인증 관리를 담당하는 중요한 모듈입니다.

Relevant Code Snippets (Code itself remains unchanged):
No specific code snippets provided for this abstraction.

Instructions for the chapter (Generate content in Korean unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 3: 계정 관리 모듈 (Accounts Module)`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).

- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).

- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).

- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).

- Heavily use analogies and examples throughout (in Korean) to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).

- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-06-30 00:17:48,156 - INFO - Using OpenAI model: gpt-4o
2025-06-30 00:18:06,465 - INFO - RESPONSE: # Chapter 3: 계정 관리 모듈 (Accounts Module)

이전 장에서는 [FastAPI 서버](02_fastapi_서버.md)에 대해 알아보았습니다. 이번 장에서는 시스템 사용자와 조직의 정보를 관리하고 인증 처리 기능을 제공하는 중요한 모듈, **계정 관리 모듈 (Accounts Module)**에 대해 설명하겠습니다.

## 계정 관리 모듈의 필요성

현대의 많은 웹 애플리케이션들은 개별 사용자에게 개인화된 경험을 제공하기 위해 사용자 정보와 인증 기능을 필요로 합니다. 예를 들어, 사용자가 앱에 로그인하여 자신의 정보를 확인하고 개인화된 서비스를 받으려면 적절한 계정 관리 시스템이 필수적입니다. 본 모듈은 이러한 요구를 만족시키기 위해 설계되었습니다.

### 주요 개념 설명

#### 1. 사용자 관리

- **사용자 정보**: 사용자의 이름, 이메일, 가입 날짜 등의 정보를 저장합니다.
- **비밀번호 관리**: 사용자 비밀번호를 안전하게 저장하고 변경하는 기능을 포함합니다.

#### 2. 조직 관리

- **조직 정보**: 조직 이름, 구성원 목록을 관리합니다.
- 조직 내 사용자의 역할을 부여하는 기능도 포함됩니다.

#### 3. 인증 처리

- 사용자의 신원을 확인하기 위해 로그인 기능과 토큰 기반 인증을 제공합니다.

## 계정 관리 모듈 사용 방법

이제 계정 관리 모듈을 사용하여 사용자를 생성하고 인증하는 방법을 알아보겠습니다.

### 새로운 사용자 생성

```python
def 사용자_생성(사용자_이름, 비밀번호):
    # 이곳에서 사용자 정보를 데이터베이스에 저장
    return {"메시지": f"{사용자_이름}가 성공적으로 생성되었습니다."}
```

- `사용자_생성`: 사용자 이름과 비밀번호를 사용해 새로운 사용자를 생성하는 함수입니다.
- 출력 메시지를 통해 사용자가 성공적으로 생성되었음을 볼 수 있습니다.

### 로그인 처리

```python
def 로그인(사용자_이름, 비밀번호):
    # 사용자 이름과 비밀번호가 맞는지 확인
    if 올바른_비밀번호(사용자_이름, 비밀번호):
        return {"메시지": "인증 성공"}
    else:
        return {"메시지": "인증 실패"}
```

- `로그인`: 사용자의 이름과 비밀번호를 확인하여 인증 처리 결과를 제공합니다.
- 비밀번호가 맞으면 "인증 성공" 메시지를, 그렇지 않으면 "인증 실패" 메시지를 반환합니다.

## 계정 관리 모듈의 내부 구현

계정 관리 모듈이 실제로 어떻게 작동하는지 이해하기 위해 대략적인 처리 과정을 살펴봅시다.

### 인증 처리 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 서버 as 계정 관리 모듈
    사용자->>서버: 로그인 요청 (사용자 이름, 비밀번호)
    서버->>서버: 비밀번호 확인
    alt 비밀번호가 맞을 때
        서버->>사용자: 인증 성공
    else 비밀번호가 틀릴 때
        서버->>사용자: 인증 실패
    end
```

1. 사용자가 계정 관리 모듈에 로그인 요청을 보냅니다.
2. 모듈은 비밀번호를 확인합니다.
3. 비밀번호가 맞으면 "인증 성공" 메시지를, 틀리면 "인증 실패" 메시지를 반환합니다.

### 내부 코드 구현

기본적인 계정 관리 시스템에는 사용자 정보를 저장하고 인증을 처리하는 클래스 또는 데이터베이스 연결이 필요합니다. 아래는 이러한 기능을 간단히 구현한 예입니다.

```python
class 계정관리:
    def __init__(self):
        self.사용자들 = {}

    def 사용자_추가(self, 이름, 비밀번호):
        self.사용자들[이름] = 비밀번호

    def 로그인_처리(self, 이름, 비밀번호):
        # 사용자 정보 및 비밀번호 일치 여부 확인
        if 이름 in self.사용자들 and self.사용자들[이름] == 비밀번호:
            return "인증 성공"
        return "인증 실패"

계정 = 계정관리()
계정.사용자_추가("홍길동", "비밀번호123")
인증_결과 = 계정.로그인_처리("홍길동", "비밀번호123")
print(인증_결과)  # 출력: 인증 성공
```

- `계정관리`: 사용자 정보를 저장하고 인증을 처리하는 클래스입니다.
- `로그인_처리`: 사용자 이름과 비밀번호가 올바른지 확인합니다.

## 결론

이번 장에서는 계정 관리 모듈을 이용해 사용자를 생성하고 인증하는 방법, 그리고 그 내부 구현을 통해 이 모듈이 어떻게 작동하는지 배웠습니다. 다음 장에서는 사용자와 AI 에이전트 간의 상호작용을 관리하는 [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)에 대해 알아보겠습니다.
2025-06-30 00:18:06,483 - INFO - PROMPT: 
IMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.

Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `SKN10-FINAL-1Team` about the concept: "챗봇 세션 관리 (Chat Session Management)". This is Chapter 4.

Concept Details (Note: Provided in Korean):
- Name: 챗봇 세션 관리 (Chat Session Management)
- Description:
사용자의 대화 세션과 메시지를 관리하고 저장하는 구성 요소입니다. (Component that manages and stores user chat sessions and messages.)

Complete Tutorial Structure (Note: Chapter names might be in Korean):
1. [AI 에이전트 총괄 시스템 (LangGraph Supervisor)](01_ai_에이전트_총괄_시스템__langgraph_supervisor_.md)
2. [FastAPI 서버](02_fastapi_서버.md)
3. [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)
4. [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)
5. [백엔드 라우팅 (Backend Routing)](05_백엔드_라우팅__backend_routing_.md)
6. [문서 검색 전문 에이전트 (RAG Agent)](06_문서_검색_전문_에이전트__rag_agent_.md)
7. [지식베이스 관리 (Knowledge Management)](07_지식베이스_관리__knowledge_management_.md)
8. [데이터 분석 전문 에이전트 (Analytics Agent)](08_데이터_분석_전문_에이전트__analytics_agent_.md)
9. [MLOps 관리 (MLOps Management)](09_mlops_관리__mlops_management_.md)
10. [환경 설정 및 배포 (Environment Setup and Deployment)](10_환경_설정_및_배포__environment_setup_and_deployment_.md)

Context from previous chapters (Note: This summary might be in Korean):
# Chapter 1: AI 에이전트 총괄 시스템 (LangGraph Supervisor)

## 소개

우리가 상상하는 미래의 세계에서는 다양한 AI 에이전트가 우리의 일상 속에서 많은 역할을 하게 될 것입니다. 이 장에서는 사용자의 자연어 요청을 신속하고 정확하게 분석하여 적합한 전문 에이전트에게 작업을 분배하는 시스템인 **AI 에이전트 총괄 시스템 (LangGraph Supervisor)**를 소개합니다.

## 왜 AI 에이전트 총괄 시스템이 필요한가요?

### 문제에 대한 개요

어느 날, 당신은 다수의 AI 전문 에이전트를 관리하는 프로젝트의 관리자입니다. 고객이 다양한 요구를 AI에게 요청하지만 그 요청마다 다른 전문 에이전트로 보내야 합니다. 예를 들어, 문서 검색이 필요한 경우에는 '문서 검색 전문 에이전트', 데이터 분석이 필요한 경우에는 '데이터 분석 전문 에이전트'가 필요합니다.

AI 에이전트 총괄 시스템은 이러한 문제를 해결하기 위해 만들어졌습니다. 사용자가 보내는 자연어 요청을 효과적으로 해석하고, 적합한 에이전트로 작업을 분배합니다.

### 핵심 개념 설명

1. **자연어 처리 (Natural Language Processing)**: 사용자의 요청을 분석하기 위해 사용됩니다. 텍스트를 이해하고 그 의미를 파악합니다.

2. **에이전트 라우팅**: 각 에이전트는 서로 다른 전문 분야를 가지고 있으며, 요청에 가장 적합한 에이전트에게 작업을 보내기 위한 과정입니다.

## AI 에이전트 총괄 시스템 사용 방법

이 시스템을 이해하는 것을 용이하게 하기 위해, 우리는 간단한 예제를 통해 따라가 볼 것입니다.

### 간단한 구현 예제

```python
def 언어_분석(요청):
    # 요청의 내용을 분석하여 필요한 에이전트를 결정함
    if "데이터 분석" in 요청:
        return "데이터 분석 전문 에이전트"
    elif "문서 검색" in 요청:
        return "문서 검색 전문 에이전트"
    else:
        return "일반 에이전트"

결정된_에이전트 = 언어_분석("문서 검색을 원해요")
print(결정된_에이전트)  # 출력: 문서 검색 전문 에이전트
```

위의 코드는 사용자의 요청을 간단히 분석하고, 해당 요청을 가장 잘 수행할 에이전트를 선정하는 프로세스를 보여줍니다.

### 내부 구현

시스템이 어떻게 내부적으로 작동하는지 더 잘 이해하기 위해, 몇 가지 과정을 단계별로 나누어 설명하겠습니다.

#### 시스템 작동 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 시스템 as LangGraph Supervisor
    participant 에이전트1 as 문서 검색 전문 에이전트
    participant 에이전트2 as 데이터 분석 전문 에이전트
    사용자->>시스템: 자연어 요청 전송
    시스템->>사용자: 요청 분석
    시스템->>에이전트1: 적합한 에이전트로 요청 전달
    에이전트1->>시스템: 작업 수행 후 결과 반환
    시스템->>사용자: 결과 전송
```

1. 사용자는 자연어 요청을 시스템에 보냅니다.
2. 시스템은 요청을 분석하여 필요한 에이전트를 결정합니다.
3. 적합한 에이전트에게 요청을 보냅니다.
4. 에이전트는 작업을 수행 후 시스템에 결과를 반환합니다.
5. 시스템은 결과를 사용자에게 전달합니다.

#### 코드 예제

이제, 시스템 내부에서 언어 분석과 라우팅이 어떻게 이루어지는지 코드 레벨에서 예를 들어 보겠습니다.

```python
class LangGraphSupervisor:
    def __init__(self):
        self.agents = {
            "문서 검색": "문서 검색 전문 에이전트",
            "데이터 분석": "데이터 분석 전문 에이전트"
        }

    def 분석후_라우팅(self, 요청):
        for 키워드, 에이전트 in self.agents.items():
            if 키워드 in 요청:
                return 에이전트
        return "일반 에이전트"

supervisor = LangGraphSupervisor()
에이전트 = supervisor.분석후_라우팅("데이터 분석을 요청합니다")
print(에이전트)  # 출력: 데이터 분석 전문 에이전트
```

이 코드에서는 요청을 처리 및 분배하는 `LangGraphSupervisor` 클래스의 구조를 보여줍니다.

## 결론

이 장에서는 AI 에이전트 총괄 시스템의 핵심 개념과 사용 방법을 배웠습니다. 이 시스템은 사용자의 자연어 요청을 분석하고 적절한 에이전트로 작업을 분배하는 것을 목표로 합니다. 다음 장에서는 이 시스템을 구동할 서버 [FastAPI 서버](02_fastapi_서버.md)에 대해 알아봅니다.
---

# Chapter 2: FastAPI 서버

이전 장에서는 [AI 에이전트 총괄 시스템 (LangGraph Supervisor)](01_ai_에이전트_총괄_시스템__langgraph_supervisor_.md)에 대해 알아보았습니다. 이번 장에서는 이러한 시스템이 원활하게 작동하기 위해 필요한 서버 기술인 **FastAPI 서버**에 대해 설명하겠습니다.

FastAPI 서버는 실시간 AI 통신을 처리하며, 사용자와 AI 시스템 간의 데이터 교환을 담당하는 중요한 역할을 합니다. 이 장에서는 FastAPI 서버의 기본적인 개념과 구현 방법을 이해하고, 실제로 간단한 서버를 만들어 보는 것을 목표로 합니다.

## FastAPI 서버의 동기

FastAPI 서버는 왜 필요한 걸까요? FastAPI는 Python 기반의 웹 프레임워크로, 빠르고 효율적인 API를 구축하는 데 사용됩니다. 이것은 특히 AI 시스템과의 빠른 데이터 교환에 최적화되어 있습니다. 예를 들어, 사용자가 챗봇에게 질문을 하거나 AI 분석 결과를 요청하는 시나리오에서 실시간으로 응답을 받아야 합니다. FastAPI는 이러한 요구 사항을 충족시킬 수 있는 솔루션입니다.

### 주요 개념 설명

#### 1. 경량 웹 프레임워크

- FastAPI는 경량 프레임워크로, 쉽고 빠르게 서버를 구축할 수 있습니다.
- 비동기식 처리(Asynchronous Handling)를 통해 높은 처리 성능을 제공합니다.

#### 2. 자동 문서화

- FastAPI는 API 엔드포인트에 대한 자동 문서화 기능을 제공합니다.
- 이는 개발자가 API를 쉽게 이해하고 사용할 수 있도록 돕습니다.

## FastAPI 서버 사용 방법

이제 FastAPI를 사용하여 간단한 서버를 구축하는 방법을 따라해보겠습니다.

### FastAPI 설치

우선 FastAPI를 설치해야 합니다. Python 패키지 매니저인 pip를 통해 설치할 수 있습니다.

```bash
pip install fastapi
pip install uvicorn
```

- `fastapi`: FastAPI 프레임워크 설치
- `uvicorn`: FastAPI 애플리케이션을 실행하기 위한 ASGI 서버

### 간단한 FastAPI 서버 구현

아래는 FastAPI를 사용하여 간단한 서버를 구축하는 코드입니다.

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def 읽기_루트():
    return {"메시지": "Hello World!"}
```

- `FastAPI()`: 새로운 FastAPI 애플리케이션 인스턴스를 생성합니다.
- `@app.get("/")`: 루트 URL에서 GET 요청을 처리합니다.
- `읽기_루트()`: 루트 URL에 접근할 때 반환할 메시지를 정의합니다.

### 서버 실행

FastAPI 애플리케이션을 실행하려면 Uvicorn을 사용합니다.

```bash
uvicorn main:app --reload
```

- `main:app`: main.py 파일의 `app` 객체를 실행합니다.
- `--reload`: 코드 변경 시 서버를 자동으로 다시 시작합니다.

## FastAPI 서버의 내부 구현

FastAPI 서버가 어떻게 내부적으로 작동하는지 알아보겠습니다. FastAPI는 비동기 처리 방식으로 요청을 처리합니다. 아래의 시퀀스 다이어그램은 간단한 HTTP 요청 프로세스를 보여줍니다.

```mermaid
sequenceDiagram
    participant 고객 as 고객
    participant 서버 as FastAPI 서버
    고객->>서버: HTTP 요청 전송
    서버->>고객: 응답 전달
```

1. 고객이 서버로 HTTP 요청을 보냅니다.
2. FastAPI 서버는 요청을 처리하고 적절한 응답을 생성합니다.
3. 응답이 고객에게 전달됩니다.

이제 FastAPI의 코드 구조를 통해 더 깊이 들어가 보겠습니다.

```python
from fastapi import FastAPI, HTTPException

app = FastAPI()

@app.get("/items/{item_id}")
def 읽기_아이템(item_id: int):
    # 데이터베이스에서 항목 찾기 (예시를 위한 간단한 로직)
    if item_id not in [1, 2, 3]:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"item_id": item_id, "값": "여기에 데이터가 들어갑니다"}
```

- `HTTPException`: FastAPI에서 에러 응답을 생성할 때 사용합니다.
- `@app.get("/items/{item_id}")`: 경로 매개변수 `item_id`를 사용하여 특정 아이템에 대한 정보를 요청할 수 있습니다.

## 결론

이번 장에서는 FastAPI 서버의 기본 개념과 이를 사용하여 간단한 웹 애플리케이션을 구축하는 방법을 배웠습니다. FastAPI는 실시간으로 AI 및 사용자의 데이터 교환을 처리하는 데 최적화되어 있습니다. 이제 다음 장에서는 [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)로 이동해 보겠습니다. 이는 사용자의 계정 및 인증 관리를 담당하는 중요한 모듈입니다.
---
# Chapter 3: 계정 관리 모듈 (Accounts Module)

이전 장에서는 [FastAPI 서버](02_fastapi_서버.md)에 대해 알아보았습니다. 이번 장에서는 시스템 사용자와 조직의 정보를 관리하고 인증 처리 기능을 제공하는 중요한 모듈, **계정 관리 모듈 (Accounts Module)**에 대해 설명하겠습니다.

## 계정 관리 모듈의 필요성

현대의 많은 웹 애플리케이션들은 개별 사용자에게 개인화된 경험을 제공하기 위해 사용자 정보와 인증 기능을 필요로 합니다. 예를 들어, 사용자가 앱에 로그인하여 자신의 정보를 확인하고 개인화된 서비스를 받으려면 적절한 계정 관리 시스템이 필수적입니다. 본 모듈은 이러한 요구를 만족시키기 위해 설계되었습니다.

### 주요 개념 설명

#### 1. 사용자 관리

- **사용자 정보**: 사용자의 이름, 이메일, 가입 날짜 등의 정보를 저장합니다.
- **비밀번호 관리**: 사용자 비밀번호를 안전하게 저장하고 변경하는 기능을 포함합니다.

#### 2. 조직 관리

- **조직 정보**: 조직 이름, 구성원 목록을 관리합니다.
- 조직 내 사용자의 역할을 부여하는 기능도 포함됩니다.

#### 3. 인증 처리

- 사용자의 신원을 확인하기 위해 로그인 기능과 토큰 기반 인증을 제공합니다.

## 계정 관리 모듈 사용 방법

이제 계정 관리 모듈을 사용하여 사용자를 생성하고 인증하는 방법을 알아보겠습니다.

### 새로운 사용자 생성

```python
def 사용자_생성(사용자_이름, 비밀번호):
    # 이곳에서 사용자 정보를 데이터베이스에 저장
    return {"메시지": f"{사용자_이름}가 성공적으로 생성되었습니다."}
```

- `사용자_생성`: 사용자 이름과 비밀번호를 사용해 새로운 사용자를 생성하는 함수입니다.
- 출력 메시지를 통해 사용자가 성공적으로 생성되었음을 볼 수 있습니다.

### 로그인 처리

```python
def 로그인(사용자_이름, 비밀번호):
    # 사용자 이름과 비밀번호가 맞는지 확인
    if 올바른_비밀번호(사용자_이름, 비밀번호):
        return {"메시지": "인증 성공"}
    else:
        return {"메시지": "인증 실패"}
```

- `로그인`: 사용자의 이름과 비밀번호를 확인하여 인증 처리 결과를 제공합니다.
- 비밀번호가 맞으면 "인증 성공" 메시지를, 그렇지 않으면 "인증 실패" 메시지를 반환합니다.

## 계정 관리 모듈의 내부 구현

계정 관리 모듈이 실제로 어떻게 작동하는지 이해하기 위해 대략적인 처리 과정을 살펴봅시다.

### 인증 처리 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 서버 as 계정 관리 모듈
    사용자->>서버: 로그인 요청 (사용자 이름, 비밀번호)
    서버->>서버: 비밀번호 확인
    alt 비밀번호가 맞을 때
        서버->>사용자: 인증 성공
    else 비밀번호가 틀릴 때
        서버->>사용자: 인증 실패
    end
```

1. 사용자가 계정 관리 모듈에 로그인 요청을 보냅니다.
2. 모듈은 비밀번호를 확인합니다.
3. 비밀번호가 맞으면 "인증 성공" 메시지를, 틀리면 "인증 실패" 메시지를 반환합니다.

### 내부 코드 구현

기본적인 계정 관리 시스템에는 사용자 정보를 저장하고 인증을 처리하는 클래스 또는 데이터베이스 연결이 필요합니다. 아래는 이러한 기능을 간단히 구현한 예입니다.

```python
class 계정관리:
    def __init__(self):
        self.사용자들 = {}

    def 사용자_추가(self, 이름, 비밀번호):
        self.사용자들[이름] = 비밀번호

    def 로그인_처리(self, 이름, 비밀번호):
        # 사용자 정보 및 비밀번호 일치 여부 확인
        if 이름 in self.사용자들 and self.사용자들[이름] == 비밀번호:
            return "인증 성공"
        return "인증 실패"

계정 = 계정관리()
계정.사용자_추가("홍길동", "비밀번호123")
인증_결과 = 계정.로그인_처리("홍길동", "비밀번호123")
print(인증_결과)  # 출력: 인증 성공
```

- `계정관리`: 사용자 정보를 저장하고 인증을 처리하는 클래스입니다.
- `로그인_처리`: 사용자 이름과 비밀번호가 올바른지 확인합니다.

## 결론

이번 장에서는 계정 관리 모듈을 이용해 사용자를 생성하고 인증하는 방법, 그리고 그 내부 구현을 통해 이 모듈이 어떻게 작동하는지 배웠습니다. 다음 장에서는 사용자와 AI 에이전트 간의 상호작용을 관리하는 [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)에 대해 알아보겠습니다.

Relevant Code Snippets (Code itself remains unchanged):
No specific code snippets provided for this abstraction.

Instructions for the chapter (Generate content in Korean unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 4: 챗봇 세션 관리 (Chat Session Management)`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).

- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).

- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).

- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).

- Heavily use analogies and examples throughout (in Korean) to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).

- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-06-30 00:18:06,771 - INFO - Using OpenAI model: gpt-4o
2025-06-30 00:18:20,894 - INFO - RESPONSE: # Chapter 4: 챗봇 세션 관리 (Chat Session Management)

이전 장에서는 [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)에 대해 알아보았습니다. 이번 장에서는 사용자의 대화 세션과 메시지를 효과적으로 관리하고 저장하는 **챗봇 세션 관리 (Chat Session Management)**에 대해 살펴보겠습니다.

## 챗봇 세션 관리의 필요성

챗봇은 다양한 사용자와 상호작용하며 많은 메시지를 처리합니다. 이때, 각 사용자와의 대화 세션을 올바르게 관리해야 이전 대화 기록을 사용하여 대화를 이어 나가거나 정보를 추출할 수 있습니다. 예를 들어, 사용자가 "얼마 전 주문했던 상품이 뭐였죠?"라고 묻는 경우, 이전 대화 세션을 통해 지난 주문 내역을 찾아 제공해야 합니다. 이렇게 하려면 세션 관리가 필수적입니다.

## 챗봇 세션 관리의 주요 개념

1. **세션 저장 (Session Storage)**
   - 각 사용자의 대화 세션을 저장합니다. 이를 통해 필요한 정보를 빠르게 조회할 수 있습니다.

2. **세션 유지 (Session Persistence)**
   - 사용자가 언제든 대화를 이어갈 수 있도록 이전 대화를 유지합니다. 사용자가 다시 접속했을 때, 이전 대화 맥락을 기반으로 서비스를 제공할 수 있습니다.

3. **세션 종료 (Session Termination)**
   - 일정 시간이 지나면 대화 세션을 종료하여 리소스를 효율적으로 관리합니다.

## 챗봇 세션 관리 사용 방법

### 사용자의 세션 저장 예제

아래는 사용자의 대화 세션을 저장하는 간단한 코드 예제입니다.

```python
def 세션_저장(사용자_id, 메시지):
    # 이곳에 세션 데이터를 저장하는 로직을 구현
    return {"메시지": f"{사용자_id}의 세션이 성공적으로 저장되었습니다."}
```

- `세션_저장`: 사용자 ID와 메시지를 받아 세션을 저장하는 함수입니다.
- 반환된 메시지를 통해 성공적으로 세션이 저장되었음을 알 수 있습니다.

### 세션 조회 구현

```python
def 세션_조회(사용자_id):
    # 저장된 세션 데이터를 가져오는 로직 구현
    return {"메시지": f"{사용자_id}의 세션 정보입니다."}
```

- `세션_조회`: 사용자 ID를 입력하면 해당 사용자의 저장된 세션 내용을 반환하는 함수입니다.

## 챗봇 세션 관리의 내부 구현

챗봇 세션 관리가 어떻게 이루어지는지 이해하기 위해 과정을 살펴보겠습니다.

### 세션 관리 처리 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 서버 as 챗봇 세션 관리
    사용자->>서버: 메시지 전송
    서버->>서버: 메시지 저장
    서버->>사용자: 세션 저장 완료 메시지
    사용자->>서버: 세션 조회 요청
    서버->>사용자: 세션 데이터 반환
```

1. 사용자가 메시지를 챗봇에 보냅니다.
2. 서버는 메시지를 세션 데이터베이스에 저장합니다.
3. 저장 완료 후 사용자는 저장 완료 확인 메시지를 받습니다.
4. 사용자가 이전 세션 조회를 요청하면, 서버는 저장된 데이터를 반환합니다.

### 코드 구현 예제

간단한 세션 관리 시스템 코드 예제입니다.

```python
class 세션관리:
    def __init__(self):
        self.세션들 = {}  # 세션 저장을 위한 딕셔너리
    
    def 저장(self, 사용자_id, 메시지):
        # 세션 저장 로직
        if 사용자_id not in self.세션들:
            self.세션들[사용자_id] = []
        self.세션들[사용자_id].append(메시지)
        return "세션 저장 완료"
    
    def 조회(self, 사용자_id):
        # 세션 조회 로직
        return self.세션들.get(사용자_id, "세션 없음")

관리자 = 세션관리()
관리자.저장("사용자1", "안녕하세요!")
결과 = 관리자.조회("사용자1")
print(결과)  # 출력: ['안녕하세요!']
```

- `세션관리`: 사용자 세션을 관리하는 클래스입니다.
- `저장`: 사용자 메시지를 세션에 저장합니다.
- `조회`: 저장된 세션을 반환합니다.

## 결론

이번 장에서는 챗봇 세션 관리를 통해 사용자 대화 세션을 어떻게 저장, 유지, 조회할 수 있는지 배웠습니다. 올바른 세션 관리가 가능해야 사용자에게 더 나은 챗봇 경험을 제공할 수 있습니다. 다음 장에서는 백엔드 라우팅을 효과적으로 활용하는 방법에 대해 알아보겠습니다: [백엔드 라우팅 (Backend Routing)](05_백엔드_라우팅__backend_routing_.md).
2025-06-30 00:18:20,911 - INFO - PROMPT: 
IMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.

Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `SKN10-FINAL-1Team` about the concept: "백엔드 라우팅 (Backend Routing)". This is Chapter 5.

Concept Details (Note: Provided in Korean):
- Name: 백엔드 라우팅 (Backend Routing)
- Description:
Django를 통해 백엔드 API 경로와 뷰를 설정하고 관리합니다. (Configures and manages backend API routes and views using Django.)

Complete Tutorial Structure (Note: Chapter names might be in Korean):
1. [AI 에이전트 총괄 시스템 (LangGraph Supervisor)](01_ai_에이전트_총괄_시스템__langgraph_supervisor_.md)
2. [FastAPI 서버](02_fastapi_서버.md)
3. [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)
4. [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)
5. [백엔드 라우팅 (Backend Routing)](05_백엔드_라우팅__backend_routing_.md)
6. [문서 검색 전문 에이전트 (RAG Agent)](06_문서_검색_전문_에이전트__rag_agent_.md)
7. [지식베이스 관리 (Knowledge Management)](07_지식베이스_관리__knowledge_management_.md)
8. [데이터 분석 전문 에이전트 (Analytics Agent)](08_데이터_분석_전문_에이전트__analytics_agent_.md)
9. [MLOps 관리 (MLOps Management)](09_mlops_관리__mlops_management_.md)
10. [환경 설정 및 배포 (Environment Setup and Deployment)](10_환경_설정_및_배포__environment_setup_and_deployment_.md)

Context from previous chapters (Note: This summary might be in Korean):
# Chapter 1: AI 에이전트 총괄 시스템 (LangGraph Supervisor)

## 소개

우리가 상상하는 미래의 세계에서는 다양한 AI 에이전트가 우리의 일상 속에서 많은 역할을 하게 될 것입니다. 이 장에서는 사용자의 자연어 요청을 신속하고 정확하게 분석하여 적합한 전문 에이전트에게 작업을 분배하는 시스템인 **AI 에이전트 총괄 시스템 (LangGraph Supervisor)**를 소개합니다.

## 왜 AI 에이전트 총괄 시스템이 필요한가요?

### 문제에 대한 개요

어느 날, 당신은 다수의 AI 전문 에이전트를 관리하는 프로젝트의 관리자입니다. 고객이 다양한 요구를 AI에게 요청하지만 그 요청마다 다른 전문 에이전트로 보내야 합니다. 예를 들어, 문서 검색이 필요한 경우에는 '문서 검색 전문 에이전트', 데이터 분석이 필요한 경우에는 '데이터 분석 전문 에이전트'가 필요합니다.

AI 에이전트 총괄 시스템은 이러한 문제를 해결하기 위해 만들어졌습니다. 사용자가 보내는 자연어 요청을 효과적으로 해석하고, 적합한 에이전트로 작업을 분배합니다.

### 핵심 개념 설명

1. **자연어 처리 (Natural Language Processing)**: 사용자의 요청을 분석하기 위해 사용됩니다. 텍스트를 이해하고 그 의미를 파악합니다.

2. **에이전트 라우팅**: 각 에이전트는 서로 다른 전문 분야를 가지고 있으며, 요청에 가장 적합한 에이전트에게 작업을 보내기 위한 과정입니다.

## AI 에이전트 총괄 시스템 사용 방법

이 시스템을 이해하는 것을 용이하게 하기 위해, 우리는 간단한 예제를 통해 따라가 볼 것입니다.

### 간단한 구현 예제

```python
def 언어_분석(요청):
    # 요청의 내용을 분석하여 필요한 에이전트를 결정함
    if "데이터 분석" in 요청:
        return "데이터 분석 전문 에이전트"
    elif "문서 검색" in 요청:
        return "문서 검색 전문 에이전트"
    else:
        return "일반 에이전트"

결정된_에이전트 = 언어_분석("문서 검색을 원해요")
print(결정된_에이전트)  # 출력: 문서 검색 전문 에이전트
```

위의 코드는 사용자의 요청을 간단히 분석하고, 해당 요청을 가장 잘 수행할 에이전트를 선정하는 프로세스를 보여줍니다.

### 내부 구현

시스템이 어떻게 내부적으로 작동하는지 더 잘 이해하기 위해, 몇 가지 과정을 단계별로 나누어 설명하겠습니다.

#### 시스템 작동 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 시스템 as LangGraph Supervisor
    participant 에이전트1 as 문서 검색 전문 에이전트
    participant 에이전트2 as 데이터 분석 전문 에이전트
    사용자->>시스템: 자연어 요청 전송
    시스템->>사용자: 요청 분석
    시스템->>에이전트1: 적합한 에이전트로 요청 전달
    에이전트1->>시스템: 작업 수행 후 결과 반환
    시스템->>사용자: 결과 전송
```

1. 사용자는 자연어 요청을 시스템에 보냅니다.
2. 시스템은 요청을 분석하여 필요한 에이전트를 결정합니다.
3. 적합한 에이전트에게 요청을 보냅니다.
4. 에이전트는 작업을 수행 후 시스템에 결과를 반환합니다.
5. 시스템은 결과를 사용자에게 전달합니다.

#### 코드 예제

이제, 시스템 내부에서 언어 분석과 라우팅이 어떻게 이루어지는지 코드 레벨에서 예를 들어 보겠습니다.

```python
class LangGraphSupervisor:
    def __init__(self):
        self.agents = {
            "문서 검색": "문서 검색 전문 에이전트",
            "데이터 분석": "데이터 분석 전문 에이전트"
        }

    def 분석후_라우팅(self, 요청):
        for 키워드, 에이전트 in self.agents.items():
            if 키워드 in 요청:
                return 에이전트
        return "일반 에이전트"

supervisor = LangGraphSupervisor()
에이전트 = supervisor.분석후_라우팅("데이터 분석을 요청합니다")
print(에이전트)  # 출력: 데이터 분석 전문 에이전트
```

이 코드에서는 요청을 처리 및 분배하는 `LangGraphSupervisor` 클래스의 구조를 보여줍니다.

## 결론

이 장에서는 AI 에이전트 총괄 시스템의 핵심 개념과 사용 방법을 배웠습니다. 이 시스템은 사용자의 자연어 요청을 분석하고 적절한 에이전트로 작업을 분배하는 것을 목표로 합니다. 다음 장에서는 이 시스템을 구동할 서버 [FastAPI 서버](02_fastapi_서버.md)에 대해 알아봅니다.
---

# Chapter 2: FastAPI 서버

이전 장에서는 [AI 에이전트 총괄 시스템 (LangGraph Supervisor)](01_ai_에이전트_총괄_시스템__langgraph_supervisor_.md)에 대해 알아보았습니다. 이번 장에서는 이러한 시스템이 원활하게 작동하기 위해 필요한 서버 기술인 **FastAPI 서버**에 대해 설명하겠습니다.

FastAPI 서버는 실시간 AI 통신을 처리하며, 사용자와 AI 시스템 간의 데이터 교환을 담당하는 중요한 역할을 합니다. 이 장에서는 FastAPI 서버의 기본적인 개념과 구현 방법을 이해하고, 실제로 간단한 서버를 만들어 보는 것을 목표로 합니다.

## FastAPI 서버의 동기

FastAPI 서버는 왜 필요한 걸까요? FastAPI는 Python 기반의 웹 프레임워크로, 빠르고 효율적인 API를 구축하는 데 사용됩니다. 이것은 특히 AI 시스템과의 빠른 데이터 교환에 최적화되어 있습니다. 예를 들어, 사용자가 챗봇에게 질문을 하거나 AI 분석 결과를 요청하는 시나리오에서 실시간으로 응답을 받아야 합니다. FastAPI는 이러한 요구 사항을 충족시킬 수 있는 솔루션입니다.

### 주요 개념 설명

#### 1. 경량 웹 프레임워크

- FastAPI는 경량 프레임워크로, 쉽고 빠르게 서버를 구축할 수 있습니다.
- 비동기식 처리(Asynchronous Handling)를 통해 높은 처리 성능을 제공합니다.

#### 2. 자동 문서화

- FastAPI는 API 엔드포인트에 대한 자동 문서화 기능을 제공합니다.
- 이는 개발자가 API를 쉽게 이해하고 사용할 수 있도록 돕습니다.

## FastAPI 서버 사용 방법

이제 FastAPI를 사용하여 간단한 서버를 구축하는 방법을 따라해보겠습니다.

### FastAPI 설치

우선 FastAPI를 설치해야 합니다. Python 패키지 매니저인 pip를 통해 설치할 수 있습니다.

```bash
pip install fastapi
pip install uvicorn
```

- `fastapi`: FastAPI 프레임워크 설치
- `uvicorn`: FastAPI 애플리케이션을 실행하기 위한 ASGI 서버

### 간단한 FastAPI 서버 구현

아래는 FastAPI를 사용하여 간단한 서버를 구축하는 코드입니다.

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def 읽기_루트():
    return {"메시지": "Hello World!"}
```

- `FastAPI()`: 새로운 FastAPI 애플리케이션 인스턴스를 생성합니다.
- `@app.get("/")`: 루트 URL에서 GET 요청을 처리합니다.
- `읽기_루트()`: 루트 URL에 접근할 때 반환할 메시지를 정의합니다.

### 서버 실행

FastAPI 애플리케이션을 실행하려면 Uvicorn을 사용합니다.

```bash
uvicorn main:app --reload
```

- `main:app`: main.py 파일의 `app` 객체를 실행합니다.
- `--reload`: 코드 변경 시 서버를 자동으로 다시 시작합니다.

## FastAPI 서버의 내부 구현

FastAPI 서버가 어떻게 내부적으로 작동하는지 알아보겠습니다. FastAPI는 비동기 처리 방식으로 요청을 처리합니다. 아래의 시퀀스 다이어그램은 간단한 HTTP 요청 프로세스를 보여줍니다.

```mermaid
sequenceDiagram
    participant 고객 as 고객
    participant 서버 as FastAPI 서버
    고객->>서버: HTTP 요청 전송
    서버->>고객: 응답 전달
```

1. 고객이 서버로 HTTP 요청을 보냅니다.
2. FastAPI 서버는 요청을 처리하고 적절한 응답을 생성합니다.
3. 응답이 고객에게 전달됩니다.

이제 FastAPI의 코드 구조를 통해 더 깊이 들어가 보겠습니다.

```python
from fastapi import FastAPI, HTTPException

app = FastAPI()

@app.get("/items/{item_id}")
def 읽기_아이템(item_id: int):
    # 데이터베이스에서 항목 찾기 (예시를 위한 간단한 로직)
    if item_id not in [1, 2, 3]:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"item_id": item_id, "값": "여기에 데이터가 들어갑니다"}
```

- `HTTPException`: FastAPI에서 에러 응답을 생성할 때 사용합니다.
- `@app.get("/items/{item_id}")`: 경로 매개변수 `item_id`를 사용하여 특정 아이템에 대한 정보를 요청할 수 있습니다.

## 결론

이번 장에서는 FastAPI 서버의 기본 개념과 이를 사용하여 간단한 웹 애플리케이션을 구축하는 방법을 배웠습니다. FastAPI는 실시간으로 AI 및 사용자의 데이터 교환을 처리하는 데 최적화되어 있습니다. 이제 다음 장에서는 [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)로 이동해 보겠습니다. 이는 사용자의 계정 및 인증 관리를 담당하는 중요한 모듈입니다.
---
# Chapter 3: 계정 관리 모듈 (Accounts Module)

이전 장에서는 [FastAPI 서버](02_fastapi_서버.md)에 대해 알아보았습니다. 이번 장에서는 시스템 사용자와 조직의 정보를 관리하고 인증 처리 기능을 제공하는 중요한 모듈, **계정 관리 모듈 (Accounts Module)**에 대해 설명하겠습니다.

## 계정 관리 모듈의 필요성

현대의 많은 웹 애플리케이션들은 개별 사용자에게 개인화된 경험을 제공하기 위해 사용자 정보와 인증 기능을 필요로 합니다. 예를 들어, 사용자가 앱에 로그인하여 자신의 정보를 확인하고 개인화된 서비스를 받으려면 적절한 계정 관리 시스템이 필수적입니다. 본 모듈은 이러한 요구를 만족시키기 위해 설계되었습니다.

### 주요 개념 설명

#### 1. 사용자 관리

- **사용자 정보**: 사용자의 이름, 이메일, 가입 날짜 등의 정보를 저장합니다.
- **비밀번호 관리**: 사용자 비밀번호를 안전하게 저장하고 변경하는 기능을 포함합니다.

#### 2. 조직 관리

- **조직 정보**: 조직 이름, 구성원 목록을 관리합니다.
- 조직 내 사용자의 역할을 부여하는 기능도 포함됩니다.

#### 3. 인증 처리

- 사용자의 신원을 확인하기 위해 로그인 기능과 토큰 기반 인증을 제공합니다.

## 계정 관리 모듈 사용 방법

이제 계정 관리 모듈을 사용하여 사용자를 생성하고 인증하는 방법을 알아보겠습니다.

### 새로운 사용자 생성

```python
def 사용자_생성(사용자_이름, 비밀번호):
    # 이곳에서 사용자 정보를 데이터베이스에 저장
    return {"메시지": f"{사용자_이름}가 성공적으로 생성되었습니다."}
```

- `사용자_생성`: 사용자 이름과 비밀번호를 사용해 새로운 사용자를 생성하는 함수입니다.
- 출력 메시지를 통해 사용자가 성공적으로 생성되었음을 볼 수 있습니다.

### 로그인 처리

```python
def 로그인(사용자_이름, 비밀번호):
    # 사용자 이름과 비밀번호가 맞는지 확인
    if 올바른_비밀번호(사용자_이름, 비밀번호):
        return {"메시지": "인증 성공"}
    else:
        return {"메시지": "인증 실패"}
```

- `로그인`: 사용자의 이름과 비밀번호를 확인하여 인증 처리 결과를 제공합니다.
- 비밀번호가 맞으면 "인증 성공" 메시지를, 그렇지 않으면 "인증 실패" 메시지를 반환합니다.

## 계정 관리 모듈의 내부 구현

계정 관리 모듈이 실제로 어떻게 작동하는지 이해하기 위해 대략적인 처리 과정을 살펴봅시다.

### 인증 처리 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 서버 as 계정 관리 모듈
    사용자->>서버: 로그인 요청 (사용자 이름, 비밀번호)
    서버->>서버: 비밀번호 확인
    alt 비밀번호가 맞을 때
        서버->>사용자: 인증 성공
    else 비밀번호가 틀릴 때
        서버->>사용자: 인증 실패
    end
```

1. 사용자가 계정 관리 모듈에 로그인 요청을 보냅니다.
2. 모듈은 비밀번호를 확인합니다.
3. 비밀번호가 맞으면 "인증 성공" 메시지를, 틀리면 "인증 실패" 메시지를 반환합니다.

### 내부 코드 구현

기본적인 계정 관리 시스템에는 사용자 정보를 저장하고 인증을 처리하는 클래스 또는 데이터베이스 연결이 필요합니다. 아래는 이러한 기능을 간단히 구현한 예입니다.

```python
class 계정관리:
    def __init__(self):
        self.사용자들 = {}

    def 사용자_추가(self, 이름, 비밀번호):
        self.사용자들[이름] = 비밀번호

    def 로그인_처리(self, 이름, 비밀번호):
        # 사용자 정보 및 비밀번호 일치 여부 확인
        if 이름 in self.사용자들 and self.사용자들[이름] == 비밀번호:
            return "인증 성공"
        return "인증 실패"

계정 = 계정관리()
계정.사용자_추가("홍길동", "비밀번호123")
인증_결과 = 계정.로그인_처리("홍길동", "비밀번호123")
print(인증_결과)  # 출력: 인증 성공
```

- `계정관리`: 사용자 정보를 저장하고 인증을 처리하는 클래스입니다.
- `로그인_처리`: 사용자 이름과 비밀번호가 올바른지 확인합니다.

## 결론

이번 장에서는 계정 관리 모듈을 이용해 사용자를 생성하고 인증하는 방법, 그리고 그 내부 구현을 통해 이 모듈이 어떻게 작동하는지 배웠습니다. 다음 장에서는 사용자와 AI 에이전트 간의 상호작용을 관리하는 [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)에 대해 알아보겠습니다.
---
# Chapter 4: 챗봇 세션 관리 (Chat Session Management)

이전 장에서는 [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)에 대해 알아보았습니다. 이번 장에서는 사용자의 대화 세션과 메시지를 효과적으로 관리하고 저장하는 **챗봇 세션 관리 (Chat Session Management)**에 대해 살펴보겠습니다.

## 챗봇 세션 관리의 필요성

챗봇은 다양한 사용자와 상호작용하며 많은 메시지를 처리합니다. 이때, 각 사용자와의 대화 세션을 올바르게 관리해야 이전 대화 기록을 사용하여 대화를 이어 나가거나 정보를 추출할 수 있습니다. 예를 들어, 사용자가 "얼마 전 주문했던 상품이 뭐였죠?"라고 묻는 경우, 이전 대화 세션을 통해 지난 주문 내역을 찾아 제공해야 합니다. 이렇게 하려면 세션 관리가 필수적입니다.

## 챗봇 세션 관리의 주요 개념

1. **세션 저장 (Session Storage)**
   - 각 사용자의 대화 세션을 저장합니다. 이를 통해 필요한 정보를 빠르게 조회할 수 있습니다.

2. **세션 유지 (Session Persistence)**
   - 사용자가 언제든 대화를 이어갈 수 있도록 이전 대화를 유지합니다. 사용자가 다시 접속했을 때, 이전 대화 맥락을 기반으로 서비스를 제공할 수 있습니다.

3. **세션 종료 (Session Termination)**
   - 일정 시간이 지나면 대화 세션을 종료하여 리소스를 효율적으로 관리합니다.

## 챗봇 세션 관리 사용 방법

### 사용자의 세션 저장 예제

아래는 사용자의 대화 세션을 저장하는 간단한 코드 예제입니다.

```python
def 세션_저장(사용자_id, 메시지):
    # 이곳에 세션 데이터를 저장하는 로직을 구현
    return {"메시지": f"{사용자_id}의 세션이 성공적으로 저장되었습니다."}
```

- `세션_저장`: 사용자 ID와 메시지를 받아 세션을 저장하는 함수입니다.
- 반환된 메시지를 통해 성공적으로 세션이 저장되었음을 알 수 있습니다.

### 세션 조회 구현

```python
def 세션_조회(사용자_id):
    # 저장된 세션 데이터를 가져오는 로직 구현
    return {"메시지": f"{사용자_id}의 세션 정보입니다."}
```

- `세션_조회`: 사용자 ID를 입력하면 해당 사용자의 저장된 세션 내용을 반환하는 함수입니다.

## 챗봇 세션 관리의 내부 구현

챗봇 세션 관리가 어떻게 이루어지는지 이해하기 위해 과정을 살펴보겠습니다.

### 세션 관리 처리 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 서버 as 챗봇 세션 관리
    사용자->>서버: 메시지 전송
    서버->>서버: 메시지 저장
    서버->>사용자: 세션 저장 완료 메시지
    사용자->>서버: 세션 조회 요청
    서버->>사용자: 세션 데이터 반환
```

1. 사용자가 메시지를 챗봇에 보냅니다.
2. 서버는 메시지를 세션 데이터베이스에 저장합니다.
3. 저장 완료 후 사용자는 저장 완료 확인 메시지를 받습니다.
4. 사용자가 이전 세션 조회를 요청하면, 서버는 저장된 데이터를 반환합니다.

### 코드 구현 예제

간단한 세션 관리 시스템 코드 예제입니다.

```python
class 세션관리:
    def __init__(self):
        self.세션들 = {}  # 세션 저장을 위한 딕셔너리
    
    def 저장(self, 사용자_id, 메시지):
        # 세션 저장 로직
        if 사용자_id not in self.세션들:
            self.세션들[사용자_id] = []
        self.세션들[사용자_id].append(메시지)
        return "세션 저장 완료"
    
    def 조회(self, 사용자_id):
        # 세션 조회 로직
        return self.세션들.get(사용자_id, "세션 없음")

관리자 = 세션관리()
관리자.저장("사용자1", "안녕하세요!")
결과 = 관리자.조회("사용자1")
print(결과)  # 출력: ['안녕하세요!']
```

- `세션관리`: 사용자 세션을 관리하는 클래스입니다.
- `저장`: 사용자 메시지를 세션에 저장합니다.
- `조회`: 저장된 세션을 반환합니다.

## 결론

이번 장에서는 챗봇 세션 관리를 통해 사용자 대화 세션을 어떻게 저장, 유지, 조회할 수 있는지 배웠습니다. 올바른 세션 관리가 가능해야 사용자에게 더 나은 챗봇 경험을 제공할 수 있습니다. 다음 장에서는 백엔드 라우팅을 효과적으로 활용하는 방법에 대해 알아보겠습니다: [백엔드 라우팅 (Backend Routing)](05_백엔드_라우팅__backend_routing_.md).

Relevant Code Snippets (Code itself remains unchanged):
No specific code snippets provided for this abstraction.

Instructions for the chapter (Generate content in Korean unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 5: 백엔드 라우팅 (Backend Routing)`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).

- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).

- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).

- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).

- Heavily use analogies and examples throughout (in Korean) to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).

- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-06-30 00:18:21,174 - INFO - Using OpenAI model: gpt-4o
2025-06-30 00:18:37,743 - INFO - RESPONSE: # Chapter 5: 백엔드 라우팅 (Backend Routing)

이전 장에서는 [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)에 대해 배웠습니다. 이번 장에서는 Django를 사용하여 백엔드 API 경로를 설정하는 방법, 즉 **백엔드 라우팅 (Backend Routing)**에 대해 알아보겠습니다.

## 백엔드 라우팅의 필요성

백엔드 라우팅은 웹 애플리케이션이 클라이언트로부터 요청을 받고 적절한 응답을 할 수 있도록 경로를 설정하는 것입니다. 예를 들어, 사용자가 웹사이트에서 상품 목록을 볼 때, 클라이언트에서의 요청이 백엔드에서 정확한 정보를 전달받기 위해 필요한 모든 것은 라우팅입니다. 이는 특히 여러 페이지가 있는 복잡한 웹 애플리케이션에서 필수적입니다.

### 예시: 상품 목록 보기

- 사용자가 웹사이트의 `/products` 페이지로 들어가면, 백엔드는 상품 목록 데이터를 클라이언트에 제공합니다.
- 적절한 라우팅이 없다면, 요청된 페이지를 찾을 수 없다는 오류 메시지를 보게 될 것입니다.

## 주요 개념

### 1. URL 경로

각각의 URL은 특정한 데이터나 페이지로의 경로입니다. Django에서는 URL 패턴을 설정하여 어떤 URL이 어떤 함수나 클래스로 처리될지를 결정합니다.

### 2. 뷰(View)

각 요청에 대해 응답을 생성하는 역할을 합니다. 예를 들어, 상품 목록 요청을 받아 그것에 대한 HTML 페이지나 JSON 데이터를 반환합니다.

## 백엔드 라우팅 사용 방법

이제 Django에서 간단한 라우팅을 설정하는 방법을 알아봅시다.

### URL 패턴 설정 예제

`urls.py` 파일을 활용하여 URL 패턴을 설정합니다.

```python
# urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('products/', views.상품목록보기, name='상품목록'),
]
```

- `path()`: URL 경로를 설정하는 함수입니다. 첫 번째 인자는 경로, 두 번째 인자는 처리할 뷰 함수, 세 번째는 경로 이름입니다.

### 뷰 함수 구현

라우팅 된 URL을 처리할 뷰 함수를 구현해 봅시다.

```python
# views.py
from django.http import HttpResponse

def 상품목록보기(request):
    # 예시로 간단한 응답을 보냄
    return HttpResponse("상품 목록 페이지입니다.")
```

- `HttpResponse`: HTTP 응답을 생성하는 클래스입니다. 여기에 문자열을 넣어 간단히 출력할 수 있습니다.

## 백엔드 라우팅의 내부 구현

백엔드 라우팅이 내부적으로 어떻게 작동하는지 이해하기 위해 시퀀스 다이어그램을 살펴보겠습니다.

### 프로세스 흐름

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 서버 as Django 서버
    사용자->>서버: /products 요청
    서버->>서버: 경로 확인 (urls.py)
    서버->>서버: 뷰 함수 실행 (views.py)
    서버->>사용자: 상품 목록 응답
```

1. 사용자가 `/products` URL로 요청을 보냅니다.
2. `urls.py`에서 해당 경로에 맞는 패턴을 찾습니다.
3. 연결된 뷰 함수가 실행되어 응답을 생성합니다.
4. 생성된 응답이 사용자에게 전달됩니다.

### 추가 코드 예시

뷰에서 데이터베이스와 연동하여 더 유용한 정보 제공을 위한 예제 코드입니다.

```python
# views.py
from django.http import JsonResponse
from .models import Product

def 상품목록보기(request):
    # 모든 상품의 정보를 가져옴
    products = Product.objects.all().values()
    return JsonResponse(list(products), safe=False)
```

- `JsonResponse`: 데이터를 JSON 형식으로 응답하는 클래스입니다.
- `Product.objects.all()`: 모든 상품 정보를 데이터베이스에서 조회합니다.

## 결론

이번 장에서는 Django를 활용한 백엔드 라우팅의 기본적인 개념과 이를 사용하여 웹 애플리케이션에서 URL을 처리하고 응답하는 방법에 대해 배웠습니다. 다음 장에서는 문서 검색을 담당하는 [문서 검색 전문 에이전트 (RAG Agent)](06_문서_검색_전문_에이전트__rag_agent_.md)에 대해 알아보겠습니다. 이 장에서 배운 라우팅 기법을 활용하여 다양한 API 요청을 관리하게 될 것입니다.
2025-06-30 00:18:37,761 - INFO - PROMPT: 
IMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.

Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `SKN10-FINAL-1Team` about the concept: "문서 검색 전문 에이전트 (RAG Agent)". This is Chapter 6.

Concept Details (Note: Provided in Korean):
- Name: 문서 검색 전문 에이전트 (RAG Agent)
- Description:
사용자의 질문에 대해 회사 내부 문서를 검색하고 답변을 생성하는 에이전트입니다. (Agent that retrieves and generates answers based on company internal documents in response to user queries.)

Complete Tutorial Structure (Note: Chapter names might be in Korean):
1. [AI 에이전트 총괄 시스템 (LangGraph Supervisor)](01_ai_에이전트_총괄_시스템__langgraph_supervisor_.md)
2. [FastAPI 서버](02_fastapi_서버.md)
3. [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)
4. [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)
5. [백엔드 라우팅 (Backend Routing)](05_백엔드_라우팅__backend_routing_.md)
6. [문서 검색 전문 에이전트 (RAG Agent)](06_문서_검색_전문_에이전트__rag_agent_.md)
7. [지식베이스 관리 (Knowledge Management)](07_지식베이스_관리__knowledge_management_.md)
8. [데이터 분석 전문 에이전트 (Analytics Agent)](08_데이터_분석_전문_에이전트__analytics_agent_.md)
9. [MLOps 관리 (MLOps Management)](09_mlops_관리__mlops_management_.md)
10. [환경 설정 및 배포 (Environment Setup and Deployment)](10_환경_설정_및_배포__environment_setup_and_deployment_.md)

Context from previous chapters (Note: This summary might be in Korean):
# Chapter 1: AI 에이전트 총괄 시스템 (LangGraph Supervisor)

## 소개

우리가 상상하는 미래의 세계에서는 다양한 AI 에이전트가 우리의 일상 속에서 많은 역할을 하게 될 것입니다. 이 장에서는 사용자의 자연어 요청을 신속하고 정확하게 분석하여 적합한 전문 에이전트에게 작업을 분배하는 시스템인 **AI 에이전트 총괄 시스템 (LangGraph Supervisor)**를 소개합니다.

## 왜 AI 에이전트 총괄 시스템이 필요한가요?

### 문제에 대한 개요

어느 날, 당신은 다수의 AI 전문 에이전트를 관리하는 프로젝트의 관리자입니다. 고객이 다양한 요구를 AI에게 요청하지만 그 요청마다 다른 전문 에이전트로 보내야 합니다. 예를 들어, 문서 검색이 필요한 경우에는 '문서 검색 전문 에이전트', 데이터 분석이 필요한 경우에는 '데이터 분석 전문 에이전트'가 필요합니다.

AI 에이전트 총괄 시스템은 이러한 문제를 해결하기 위해 만들어졌습니다. 사용자가 보내는 자연어 요청을 효과적으로 해석하고, 적합한 에이전트로 작업을 분배합니다.

### 핵심 개념 설명

1. **자연어 처리 (Natural Language Processing)**: 사용자의 요청을 분석하기 위해 사용됩니다. 텍스트를 이해하고 그 의미를 파악합니다.

2. **에이전트 라우팅**: 각 에이전트는 서로 다른 전문 분야를 가지고 있으며, 요청에 가장 적합한 에이전트에게 작업을 보내기 위한 과정입니다.

## AI 에이전트 총괄 시스템 사용 방법

이 시스템을 이해하는 것을 용이하게 하기 위해, 우리는 간단한 예제를 통해 따라가 볼 것입니다.

### 간단한 구현 예제

```python
def 언어_분석(요청):
    # 요청의 내용을 분석하여 필요한 에이전트를 결정함
    if "데이터 분석" in 요청:
        return "데이터 분석 전문 에이전트"
    elif "문서 검색" in 요청:
        return "문서 검색 전문 에이전트"
    else:
        return "일반 에이전트"

결정된_에이전트 = 언어_분석("문서 검색을 원해요")
print(결정된_에이전트)  # 출력: 문서 검색 전문 에이전트
```

위의 코드는 사용자의 요청을 간단히 분석하고, 해당 요청을 가장 잘 수행할 에이전트를 선정하는 프로세스를 보여줍니다.

### 내부 구현

시스템이 어떻게 내부적으로 작동하는지 더 잘 이해하기 위해, 몇 가지 과정을 단계별로 나누어 설명하겠습니다.

#### 시스템 작동 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 시스템 as LangGraph Supervisor
    participant 에이전트1 as 문서 검색 전문 에이전트
    participant 에이전트2 as 데이터 분석 전문 에이전트
    사용자->>시스템: 자연어 요청 전송
    시스템->>사용자: 요청 분석
    시스템->>에이전트1: 적합한 에이전트로 요청 전달
    에이전트1->>시스템: 작업 수행 후 결과 반환
    시스템->>사용자: 결과 전송
```

1. 사용자는 자연어 요청을 시스템에 보냅니다.
2. 시스템은 요청을 분석하여 필요한 에이전트를 결정합니다.
3. 적합한 에이전트에게 요청을 보냅니다.
4. 에이전트는 작업을 수행 후 시스템에 결과를 반환합니다.
5. 시스템은 결과를 사용자에게 전달합니다.

#### 코드 예제

이제, 시스템 내부에서 언어 분석과 라우팅이 어떻게 이루어지는지 코드 레벨에서 예를 들어 보겠습니다.

```python
class LangGraphSupervisor:
    def __init__(self):
        self.agents = {
            "문서 검색": "문서 검색 전문 에이전트",
            "데이터 분석": "데이터 분석 전문 에이전트"
        }

    def 분석후_라우팅(self, 요청):
        for 키워드, 에이전트 in self.agents.items():
            if 키워드 in 요청:
                return 에이전트
        return "일반 에이전트"

supervisor = LangGraphSupervisor()
에이전트 = supervisor.분석후_라우팅("데이터 분석을 요청합니다")
print(에이전트)  # 출력: 데이터 분석 전문 에이전트
```

이 코드에서는 요청을 처리 및 분배하는 `LangGraphSupervisor` 클래스의 구조를 보여줍니다.

## 결론

이 장에서는 AI 에이전트 총괄 시스템의 핵심 개념과 사용 방법을 배웠습니다. 이 시스템은 사용자의 자연어 요청을 분석하고 적절한 에이전트로 작업을 분배하는 것을 목표로 합니다. 다음 장에서는 이 시스템을 구동할 서버 [FastAPI 서버](02_fastapi_서버.md)에 대해 알아봅니다.
---

# Chapter 2: FastAPI 서버

이전 장에서는 [AI 에이전트 총괄 시스템 (LangGraph Supervisor)](01_ai_에이전트_총괄_시스템__langgraph_supervisor_.md)에 대해 알아보았습니다. 이번 장에서는 이러한 시스템이 원활하게 작동하기 위해 필요한 서버 기술인 **FastAPI 서버**에 대해 설명하겠습니다.

FastAPI 서버는 실시간 AI 통신을 처리하며, 사용자와 AI 시스템 간의 데이터 교환을 담당하는 중요한 역할을 합니다. 이 장에서는 FastAPI 서버의 기본적인 개념과 구현 방법을 이해하고, 실제로 간단한 서버를 만들어 보는 것을 목표로 합니다.

## FastAPI 서버의 동기

FastAPI 서버는 왜 필요한 걸까요? FastAPI는 Python 기반의 웹 프레임워크로, 빠르고 효율적인 API를 구축하는 데 사용됩니다. 이것은 특히 AI 시스템과의 빠른 데이터 교환에 최적화되어 있습니다. 예를 들어, 사용자가 챗봇에게 질문을 하거나 AI 분석 결과를 요청하는 시나리오에서 실시간으로 응답을 받아야 합니다. FastAPI는 이러한 요구 사항을 충족시킬 수 있는 솔루션입니다.

### 주요 개념 설명

#### 1. 경량 웹 프레임워크

- FastAPI는 경량 프레임워크로, 쉽고 빠르게 서버를 구축할 수 있습니다.
- 비동기식 처리(Asynchronous Handling)를 통해 높은 처리 성능을 제공합니다.

#### 2. 자동 문서화

- FastAPI는 API 엔드포인트에 대한 자동 문서화 기능을 제공합니다.
- 이는 개발자가 API를 쉽게 이해하고 사용할 수 있도록 돕습니다.

## FastAPI 서버 사용 방법

이제 FastAPI를 사용하여 간단한 서버를 구축하는 방법을 따라해보겠습니다.

### FastAPI 설치

우선 FastAPI를 설치해야 합니다. Python 패키지 매니저인 pip를 통해 설치할 수 있습니다.

```bash
pip install fastapi
pip install uvicorn
```

- `fastapi`: FastAPI 프레임워크 설치
- `uvicorn`: FastAPI 애플리케이션을 실행하기 위한 ASGI 서버

### 간단한 FastAPI 서버 구현

아래는 FastAPI를 사용하여 간단한 서버를 구축하는 코드입니다.

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def 읽기_루트():
    return {"메시지": "Hello World!"}
```

- `FastAPI()`: 새로운 FastAPI 애플리케이션 인스턴스를 생성합니다.
- `@app.get("/")`: 루트 URL에서 GET 요청을 처리합니다.
- `읽기_루트()`: 루트 URL에 접근할 때 반환할 메시지를 정의합니다.

### 서버 실행

FastAPI 애플리케이션을 실행하려면 Uvicorn을 사용합니다.

```bash
uvicorn main:app --reload
```

- `main:app`: main.py 파일의 `app` 객체를 실행합니다.
- `--reload`: 코드 변경 시 서버를 자동으로 다시 시작합니다.

## FastAPI 서버의 내부 구현

FastAPI 서버가 어떻게 내부적으로 작동하는지 알아보겠습니다. FastAPI는 비동기 처리 방식으로 요청을 처리합니다. 아래의 시퀀스 다이어그램은 간단한 HTTP 요청 프로세스를 보여줍니다.

```mermaid
sequenceDiagram
    participant 고객 as 고객
    participant 서버 as FastAPI 서버
    고객->>서버: HTTP 요청 전송
    서버->>고객: 응답 전달
```

1. 고객이 서버로 HTTP 요청을 보냅니다.
2. FastAPI 서버는 요청을 처리하고 적절한 응답을 생성합니다.
3. 응답이 고객에게 전달됩니다.

이제 FastAPI의 코드 구조를 통해 더 깊이 들어가 보겠습니다.

```python
from fastapi import FastAPI, HTTPException

app = FastAPI()

@app.get("/items/{item_id}")
def 읽기_아이템(item_id: int):
    # 데이터베이스에서 항목 찾기 (예시를 위한 간단한 로직)
    if item_id not in [1, 2, 3]:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"item_id": item_id, "값": "여기에 데이터가 들어갑니다"}
```

- `HTTPException`: FastAPI에서 에러 응답을 생성할 때 사용합니다.
- `@app.get("/items/{item_id}")`: 경로 매개변수 `item_id`를 사용하여 특정 아이템에 대한 정보를 요청할 수 있습니다.

## 결론

이번 장에서는 FastAPI 서버의 기본 개념과 이를 사용하여 간단한 웹 애플리케이션을 구축하는 방법을 배웠습니다. FastAPI는 실시간으로 AI 및 사용자의 데이터 교환을 처리하는 데 최적화되어 있습니다. 이제 다음 장에서는 [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)로 이동해 보겠습니다. 이는 사용자의 계정 및 인증 관리를 담당하는 중요한 모듈입니다.
---
# Chapter 3: 계정 관리 모듈 (Accounts Module)

이전 장에서는 [FastAPI 서버](02_fastapi_서버.md)에 대해 알아보았습니다. 이번 장에서는 시스템 사용자와 조직의 정보를 관리하고 인증 처리 기능을 제공하는 중요한 모듈, **계정 관리 모듈 (Accounts Module)**에 대해 설명하겠습니다.

## 계정 관리 모듈의 필요성

현대의 많은 웹 애플리케이션들은 개별 사용자에게 개인화된 경험을 제공하기 위해 사용자 정보와 인증 기능을 필요로 합니다. 예를 들어, 사용자가 앱에 로그인하여 자신의 정보를 확인하고 개인화된 서비스를 받으려면 적절한 계정 관리 시스템이 필수적입니다. 본 모듈은 이러한 요구를 만족시키기 위해 설계되었습니다.

### 주요 개념 설명

#### 1. 사용자 관리

- **사용자 정보**: 사용자의 이름, 이메일, 가입 날짜 등의 정보를 저장합니다.
- **비밀번호 관리**: 사용자 비밀번호를 안전하게 저장하고 변경하는 기능을 포함합니다.

#### 2. 조직 관리

- **조직 정보**: 조직 이름, 구성원 목록을 관리합니다.
- 조직 내 사용자의 역할을 부여하는 기능도 포함됩니다.

#### 3. 인증 처리

- 사용자의 신원을 확인하기 위해 로그인 기능과 토큰 기반 인증을 제공합니다.

## 계정 관리 모듈 사용 방법

이제 계정 관리 모듈을 사용하여 사용자를 생성하고 인증하는 방법을 알아보겠습니다.

### 새로운 사용자 생성

```python
def 사용자_생성(사용자_이름, 비밀번호):
    # 이곳에서 사용자 정보를 데이터베이스에 저장
    return {"메시지": f"{사용자_이름}가 성공적으로 생성되었습니다."}
```

- `사용자_생성`: 사용자 이름과 비밀번호를 사용해 새로운 사용자를 생성하는 함수입니다.
- 출력 메시지를 통해 사용자가 성공적으로 생성되었음을 볼 수 있습니다.

### 로그인 처리

```python
def 로그인(사용자_이름, 비밀번호):
    # 사용자 이름과 비밀번호가 맞는지 확인
    if 올바른_비밀번호(사용자_이름, 비밀번호):
        return {"메시지": "인증 성공"}
    else:
        return {"메시지": "인증 실패"}
```

- `로그인`: 사용자의 이름과 비밀번호를 확인하여 인증 처리 결과를 제공합니다.
- 비밀번호가 맞으면 "인증 성공" 메시지를, 그렇지 않으면 "인증 실패" 메시지를 반환합니다.

## 계정 관리 모듈의 내부 구현

계정 관리 모듈이 실제로 어떻게 작동하는지 이해하기 위해 대략적인 처리 과정을 살펴봅시다.

### 인증 처리 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 서버 as 계정 관리 모듈
    사용자->>서버: 로그인 요청 (사용자 이름, 비밀번호)
    서버->>서버: 비밀번호 확인
    alt 비밀번호가 맞을 때
        서버->>사용자: 인증 성공
    else 비밀번호가 틀릴 때
        서버->>사용자: 인증 실패
    end
```

1. 사용자가 계정 관리 모듈에 로그인 요청을 보냅니다.
2. 모듈은 비밀번호를 확인합니다.
3. 비밀번호가 맞으면 "인증 성공" 메시지를, 틀리면 "인증 실패" 메시지를 반환합니다.

### 내부 코드 구현

기본적인 계정 관리 시스템에는 사용자 정보를 저장하고 인증을 처리하는 클래스 또는 데이터베이스 연결이 필요합니다. 아래는 이러한 기능을 간단히 구현한 예입니다.

```python
class 계정관리:
    def __init__(self):
        self.사용자들 = {}

    def 사용자_추가(self, 이름, 비밀번호):
        self.사용자들[이름] = 비밀번호

    def 로그인_처리(self, 이름, 비밀번호):
        # 사용자 정보 및 비밀번호 일치 여부 확인
        if 이름 in self.사용자들 and self.사용자들[이름] == 비밀번호:
            return "인증 성공"
        return "인증 실패"

계정 = 계정관리()
계정.사용자_추가("홍길동", "비밀번호123")
인증_결과 = 계정.로그인_처리("홍길동", "비밀번호123")
print(인증_결과)  # 출력: 인증 성공
```

- `계정관리`: 사용자 정보를 저장하고 인증을 처리하는 클래스입니다.
- `로그인_처리`: 사용자 이름과 비밀번호가 올바른지 확인합니다.

## 결론

이번 장에서는 계정 관리 모듈을 이용해 사용자를 생성하고 인증하는 방법, 그리고 그 내부 구현을 통해 이 모듈이 어떻게 작동하는지 배웠습니다. 다음 장에서는 사용자와 AI 에이전트 간의 상호작용을 관리하는 [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)에 대해 알아보겠습니다.
---
# Chapter 4: 챗봇 세션 관리 (Chat Session Management)

이전 장에서는 [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)에 대해 알아보았습니다. 이번 장에서는 사용자의 대화 세션과 메시지를 효과적으로 관리하고 저장하는 **챗봇 세션 관리 (Chat Session Management)**에 대해 살펴보겠습니다.

## 챗봇 세션 관리의 필요성

챗봇은 다양한 사용자와 상호작용하며 많은 메시지를 처리합니다. 이때, 각 사용자와의 대화 세션을 올바르게 관리해야 이전 대화 기록을 사용하여 대화를 이어 나가거나 정보를 추출할 수 있습니다. 예를 들어, 사용자가 "얼마 전 주문했던 상품이 뭐였죠?"라고 묻는 경우, 이전 대화 세션을 통해 지난 주문 내역을 찾아 제공해야 합니다. 이렇게 하려면 세션 관리가 필수적입니다.

## 챗봇 세션 관리의 주요 개념

1. **세션 저장 (Session Storage)**
   - 각 사용자의 대화 세션을 저장합니다. 이를 통해 필요한 정보를 빠르게 조회할 수 있습니다.

2. **세션 유지 (Session Persistence)**
   - 사용자가 언제든 대화를 이어갈 수 있도록 이전 대화를 유지합니다. 사용자가 다시 접속했을 때, 이전 대화 맥락을 기반으로 서비스를 제공할 수 있습니다.

3. **세션 종료 (Session Termination)**
   - 일정 시간이 지나면 대화 세션을 종료하여 리소스를 효율적으로 관리합니다.

## 챗봇 세션 관리 사용 방법

### 사용자의 세션 저장 예제

아래는 사용자의 대화 세션을 저장하는 간단한 코드 예제입니다.

```python
def 세션_저장(사용자_id, 메시지):
    # 이곳에 세션 데이터를 저장하는 로직을 구현
    return {"메시지": f"{사용자_id}의 세션이 성공적으로 저장되었습니다."}
```

- `세션_저장`: 사용자 ID와 메시지를 받아 세션을 저장하는 함수입니다.
- 반환된 메시지를 통해 성공적으로 세션이 저장되었음을 알 수 있습니다.

### 세션 조회 구현

```python
def 세션_조회(사용자_id):
    # 저장된 세션 데이터를 가져오는 로직 구현
    return {"메시지": f"{사용자_id}의 세션 정보입니다."}
```

- `세션_조회`: 사용자 ID를 입력하면 해당 사용자의 저장된 세션 내용을 반환하는 함수입니다.

## 챗봇 세션 관리의 내부 구현

챗봇 세션 관리가 어떻게 이루어지는지 이해하기 위해 과정을 살펴보겠습니다.

### 세션 관리 처리 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 서버 as 챗봇 세션 관리
    사용자->>서버: 메시지 전송
    서버->>서버: 메시지 저장
    서버->>사용자: 세션 저장 완료 메시지
    사용자->>서버: 세션 조회 요청
    서버->>사용자: 세션 데이터 반환
```

1. 사용자가 메시지를 챗봇에 보냅니다.
2. 서버는 메시지를 세션 데이터베이스에 저장합니다.
3. 저장 완료 후 사용자는 저장 완료 확인 메시지를 받습니다.
4. 사용자가 이전 세션 조회를 요청하면, 서버는 저장된 데이터를 반환합니다.

### 코드 구현 예제

간단한 세션 관리 시스템 코드 예제입니다.

```python
class 세션관리:
    def __init__(self):
        self.세션들 = {}  # 세션 저장을 위한 딕셔너리
    
    def 저장(self, 사용자_id, 메시지):
        # 세션 저장 로직
        if 사용자_id not in self.세션들:
            self.세션들[사용자_id] = []
        self.세션들[사용자_id].append(메시지)
        return "세션 저장 완료"
    
    def 조회(self, 사용자_id):
        # 세션 조회 로직
        return self.세션들.get(사용자_id, "세션 없음")

관리자 = 세션관리()
관리자.저장("사용자1", "안녕하세요!")
결과 = 관리자.조회("사용자1")
print(결과)  # 출력: ['안녕하세요!']
```

- `세션관리`: 사용자 세션을 관리하는 클래스입니다.
- `저장`: 사용자 메시지를 세션에 저장합니다.
- `조회`: 저장된 세션을 반환합니다.

## 결론

이번 장에서는 챗봇 세션 관리를 통해 사용자 대화 세션을 어떻게 저장, 유지, 조회할 수 있는지 배웠습니다. 올바른 세션 관리가 가능해야 사용자에게 더 나은 챗봇 경험을 제공할 수 있습니다. 다음 장에서는 백엔드 라우팅을 효과적으로 활용하는 방법에 대해 알아보겠습니다: [백엔드 라우팅 (Backend Routing)](05_백엔드_라우팅__backend_routing_.md).
---
# Chapter 5: 백엔드 라우팅 (Backend Routing)

이전 장에서는 [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)에 대해 배웠습니다. 이번 장에서는 Django를 사용하여 백엔드 API 경로를 설정하는 방법, 즉 **백엔드 라우팅 (Backend Routing)**에 대해 알아보겠습니다.

## 백엔드 라우팅의 필요성

백엔드 라우팅은 웹 애플리케이션이 클라이언트로부터 요청을 받고 적절한 응답을 할 수 있도록 경로를 설정하는 것입니다. 예를 들어, 사용자가 웹사이트에서 상품 목록을 볼 때, 클라이언트에서의 요청이 백엔드에서 정확한 정보를 전달받기 위해 필요한 모든 것은 라우팅입니다. 이는 특히 여러 페이지가 있는 복잡한 웹 애플리케이션에서 필수적입니다.

### 예시: 상품 목록 보기

- 사용자가 웹사이트의 `/products` 페이지로 들어가면, 백엔드는 상품 목록 데이터를 클라이언트에 제공합니다.
- 적절한 라우팅이 없다면, 요청된 페이지를 찾을 수 없다는 오류 메시지를 보게 될 것입니다.

## 주요 개념

### 1. URL 경로

각각의 URL은 특정한 데이터나 페이지로의 경로입니다. Django에서는 URL 패턴을 설정하여 어떤 URL이 어떤 함수나 클래스로 처리될지를 결정합니다.

### 2. 뷰(View)

각 요청에 대해 응답을 생성하는 역할을 합니다. 예를 들어, 상품 목록 요청을 받아 그것에 대한 HTML 페이지나 JSON 데이터를 반환합니다.

## 백엔드 라우팅 사용 방법

이제 Django에서 간단한 라우팅을 설정하는 방법을 알아봅시다.

### URL 패턴 설정 예제

`urls.py` 파일을 활용하여 URL 패턴을 설정합니다.

```python
# urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('products/', views.상품목록보기, name='상품목록'),
]
```

- `path()`: URL 경로를 설정하는 함수입니다. 첫 번째 인자는 경로, 두 번째 인자는 처리할 뷰 함수, 세 번째는 경로 이름입니다.

### 뷰 함수 구현

라우팅 된 URL을 처리할 뷰 함수를 구현해 봅시다.

```python
# views.py
from django.http import HttpResponse

def 상품목록보기(request):
    # 예시로 간단한 응답을 보냄
    return HttpResponse("상품 목록 페이지입니다.")
```

- `HttpResponse`: HTTP 응답을 생성하는 클래스입니다. 여기에 문자열을 넣어 간단히 출력할 수 있습니다.

## 백엔드 라우팅의 내부 구현

백엔드 라우팅이 내부적으로 어떻게 작동하는지 이해하기 위해 시퀀스 다이어그램을 살펴보겠습니다.

### 프로세스 흐름

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 서버 as Django 서버
    사용자->>서버: /products 요청
    서버->>서버: 경로 확인 (urls.py)
    서버->>서버: 뷰 함수 실행 (views.py)
    서버->>사용자: 상품 목록 응답
```

1. 사용자가 `/products` URL로 요청을 보냅니다.
2. `urls.py`에서 해당 경로에 맞는 패턴을 찾습니다.
3. 연결된 뷰 함수가 실행되어 응답을 생성합니다.
4. 생성된 응답이 사용자에게 전달됩니다.

### 추가 코드 예시

뷰에서 데이터베이스와 연동하여 더 유용한 정보 제공을 위한 예제 코드입니다.

```python
# views.py
from django.http import JsonResponse
from .models import Product

def 상품목록보기(request):
    # 모든 상품의 정보를 가져옴
    products = Product.objects.all().values()
    return JsonResponse(list(products), safe=False)
```

- `JsonResponse`: 데이터를 JSON 형식으로 응답하는 클래스입니다.
- `Product.objects.all()`: 모든 상품 정보를 데이터베이스에서 조회합니다.

## 결론

이번 장에서는 Django를 활용한 백엔드 라우팅의 기본적인 개념과 이를 사용하여 웹 애플리케이션에서 URL을 처리하고 응답하는 방법에 대해 배웠습니다. 다음 장에서는 문서 검색을 담당하는 [문서 검색 전문 에이전트 (RAG Agent)](06_문서_검색_전문_에이전트__rag_agent_.md)에 대해 알아보겠습니다. 이 장에서 배운 라우팅 기법을 활용하여 다양한 API 요청을 관리하게 될 것입니다.

Relevant Code Snippets (Code itself remains unchanged):
No specific code snippets provided for this abstraction.

Instructions for the chapter (Generate content in Korean unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 6: 문서 검색 전문 에이전트 (RAG Agent)`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).

- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).

- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).

- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).

- Heavily use analogies and examples throughout (in Korean) to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).

- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-06-30 00:18:38,014 - INFO - Using OpenAI model: gpt-4o
2025-06-30 00:18:53,969 - INFO - RESPONSE: # Chapter 6: 문서 검색 전문 에이전트 (RAG Agent)

이전 장에서는 [백엔드 라우팅 (Backend Routing)](05_백엔드_라우팅__backend_routing_.md)에 대해 배웠습니다. 이번 장에서는 사용자의 질문에 대해 회사 내부 문서를 검색하고 답변을 생성하는 **문서 검색 전문 에이전트 (RAG Agent)**에 대해 알아보겠습니다.

## 문서 검색 에이전트의 필요성

회사 내부에는 중요한 정보가 담긴 수많은 문서들이 존재합니다. 그런데 만약 고객이 특정 정보를 문의했을 때, 직원이 일일이 문서를 뒤져야 한다면 얼마나 시간이 걸릴까요? 이러한 문제를 해결하려면 자동화된 문서 검색 시스템이 필요합니다. **문서 검색 전문 에이전트**는 사용자의 질문에 맞춰 해당 문서를 빠르게 검색하고, 요청된 정보를 제공합니다.

### 예시 시나리오

- 고객이 "이 제품의 안전 지침은 무엇인가요?"라고 질문합니다.
- 에이전트는 즉시 관련 문서를 검색하고 적합한 내용을 찾아 답변합니다. 

## 문서 검색 에이전트의 주요 개념

### 1. 질의 처리 (Query Processing)
   - 사용자가 입력한 질문을 이해하고 가장 적합한 정보를 검색합니다.

### 2. 문서 인덱싱 (Document Indexing)
   - 모든 문서를 검색 가능한 형태로 인덱싱하여 빠른 검색이 가능하도록 합니다.

### 3. 정보 검색 (Information Retrieval)
   - 사용자의 질의에 맞는 문서를 찾아내고, 필요한 정보를 추출해서 제공합니다.

## 문서 검색 에이전트 사용 방법

문서 검색 에이전트를 사용하여 간단한 검색을 수행하는 방법을 알아보겠습니다.

### 사용자의 질문에 답변 예제

```python
def 질문_답변(질문):
    # 요청한 질문에 맞는 문서를 검색하는 로직
    return {"답변": f"'{질문}'에 대한 답변입니다."}
```

- `질문_답변`: 입력된 질문에 따라 특정 문서를 검색하고 답변을 제공하는 함수입니다.
- 결과로 질문에 해당하는 답변을 반환합니다.

### 코드 구현 예제

```python
class 문서검색에이전트:
    def __init__(self, 문서들):
        self.문서들 = 문서들
    
    def 검색(self, 질문):
        # 간단한 키워드 기반 검색 예제
        for 문서 in self.문서들:
            if 질문 in 문서:
                return 문서
        return "관련 문서 없음"

에이전트 = 문서검색에이전트(["안전 지침", "사용 설명서"])
답변 = 에이전트.검색("안전")
print(답변)  # 출력: 안전 지침
```

- `문서검색에이전트`: 문서를 관리하고 검색을 수행하는 클래스입니다.
- `검색`: 문서에서 질문에 맞는 내용을 찾아 반환합니다.

## 내부 작동 방식

문서 검색 전문 에이전트가 어떻게 작동하는지 시퀀스 다이어그램으로 살펴보겠습니다.

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 에이전트 as 문서 검색 에이전트
    사용자->>에이전트: 질문 전송
    에이전트->>에이전트: 문서 검색
    에이전트->>사용자: 검색 결과 반환
```

1. 사용자가 에이전트에 질문을 보냅니다.
2. 에이전트는 내부 문서를 바탕으로 질문에 해당하는 정보를 검색합니다.
3. 검색 결과를 사용자에게 반환합니다.

### 추가 코드 설명

더 복잡한 검색 기능을 위해서는 NLP를 활용해 질문을 보다 정교하게 처리할 수 있습니다.

```python
import re

class 고급문서검색에이전트:
    def __init__(self, 문서들):
        self.문서들 = 문서들
    
    def 고급_검색(self, 질문):
        # 정규식을 이용한 고급 검색 예제
        패턴 = re.compile(r'\b{}\b'.format(re.escape(질문)))
        for 문서 in self.문서들:
            if 패턴.search(문서):
                return 문서
        return "관련 문서 없음"

고급에이전트 = 고급문서검색에이전트(["안전 지침", "사용 설명서"])
고급답변 = 고급에이전트.고급_검색("지침")
print(고급답변)  # 출력: 안전 지침
```

- `고급문서검색에이전트`: 자연어 처리 기능을 추가한 문서 검색 에이전트 클래스입니다.
- 정규식을 사용하여 질문에 대해 더 정확한 검색이 가능합니다.

## 결론

이번 장에서는 문서 검색 전문 에이전트를 통해 회사 내부 문서를 빠르게 검색하고 필요한 정보를 제공하는 방법을 배웠습니다. 이러한 자동화 시스템은 업무 효율성을 크게 향상시킬 수 있습니다. 다음 장에서는 회사의 지식 자산을 체계적으로 관리하는 [지식베이스 관리 (Knowledge Management)](07_지식베이스_관리__knowledge_management_.md)에 대해 알아보겠습니다.
2025-06-30 00:18:53,988 - INFO - PROMPT: 
IMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.

Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `SKN10-FINAL-1Team` about the concept: "지식베이스 관리 (Knowledge Management)". This is Chapter 7.

Concept Details (Note: Provided in Korean):
- Name: 지식베이스 관리 (Knowledge Management)
- Description:
조직의 문서와 임베딩 데이터를 관리하며, 문서 검색을 지원합니다. (Management of organization documents and embedding data, supporting document retrieval.)

Complete Tutorial Structure (Note: Chapter names might be in Korean):
1. [AI 에이전트 총괄 시스템 (LangGraph Supervisor)](01_ai_에이전트_총괄_시스템__langgraph_supervisor_.md)
2. [FastAPI 서버](02_fastapi_서버.md)
3. [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)
4. [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)
5. [백엔드 라우팅 (Backend Routing)](05_백엔드_라우팅__backend_routing_.md)
6. [문서 검색 전문 에이전트 (RAG Agent)](06_문서_검색_전문_에이전트__rag_agent_.md)
7. [지식베이스 관리 (Knowledge Management)](07_지식베이스_관리__knowledge_management_.md)
8. [데이터 분석 전문 에이전트 (Analytics Agent)](08_데이터_분석_전문_에이전트__analytics_agent_.md)
9. [MLOps 관리 (MLOps Management)](09_mlops_관리__mlops_management_.md)
10. [환경 설정 및 배포 (Environment Setup and Deployment)](10_환경_설정_및_배포__environment_setup_and_deployment_.md)

Context from previous chapters (Note: This summary might be in Korean):
# Chapter 1: AI 에이전트 총괄 시스템 (LangGraph Supervisor)

## 소개

우리가 상상하는 미래의 세계에서는 다양한 AI 에이전트가 우리의 일상 속에서 많은 역할을 하게 될 것입니다. 이 장에서는 사용자의 자연어 요청을 신속하고 정확하게 분석하여 적합한 전문 에이전트에게 작업을 분배하는 시스템인 **AI 에이전트 총괄 시스템 (LangGraph Supervisor)**를 소개합니다.

## 왜 AI 에이전트 총괄 시스템이 필요한가요?

### 문제에 대한 개요

어느 날, 당신은 다수의 AI 전문 에이전트를 관리하는 프로젝트의 관리자입니다. 고객이 다양한 요구를 AI에게 요청하지만 그 요청마다 다른 전문 에이전트로 보내야 합니다. 예를 들어, 문서 검색이 필요한 경우에는 '문서 검색 전문 에이전트', 데이터 분석이 필요한 경우에는 '데이터 분석 전문 에이전트'가 필요합니다.

AI 에이전트 총괄 시스템은 이러한 문제를 해결하기 위해 만들어졌습니다. 사용자가 보내는 자연어 요청을 효과적으로 해석하고, 적합한 에이전트로 작업을 분배합니다.

### 핵심 개념 설명

1. **자연어 처리 (Natural Language Processing)**: 사용자의 요청을 분석하기 위해 사용됩니다. 텍스트를 이해하고 그 의미를 파악합니다.

2. **에이전트 라우팅**: 각 에이전트는 서로 다른 전문 분야를 가지고 있으며, 요청에 가장 적합한 에이전트에게 작업을 보내기 위한 과정입니다.

## AI 에이전트 총괄 시스템 사용 방법

이 시스템을 이해하는 것을 용이하게 하기 위해, 우리는 간단한 예제를 통해 따라가 볼 것입니다.

### 간단한 구현 예제

```python
def 언어_분석(요청):
    # 요청의 내용을 분석하여 필요한 에이전트를 결정함
    if "데이터 분석" in 요청:
        return "데이터 분석 전문 에이전트"
    elif "문서 검색" in 요청:
        return "문서 검색 전문 에이전트"
    else:
        return "일반 에이전트"

결정된_에이전트 = 언어_분석("문서 검색을 원해요")
print(결정된_에이전트)  # 출력: 문서 검색 전문 에이전트
```

위의 코드는 사용자의 요청을 간단히 분석하고, 해당 요청을 가장 잘 수행할 에이전트를 선정하는 프로세스를 보여줍니다.

### 내부 구현

시스템이 어떻게 내부적으로 작동하는지 더 잘 이해하기 위해, 몇 가지 과정을 단계별로 나누어 설명하겠습니다.

#### 시스템 작동 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 시스템 as LangGraph Supervisor
    participant 에이전트1 as 문서 검색 전문 에이전트
    participant 에이전트2 as 데이터 분석 전문 에이전트
    사용자->>시스템: 자연어 요청 전송
    시스템->>사용자: 요청 분석
    시스템->>에이전트1: 적합한 에이전트로 요청 전달
    에이전트1->>시스템: 작업 수행 후 결과 반환
    시스템->>사용자: 결과 전송
```

1. 사용자는 자연어 요청을 시스템에 보냅니다.
2. 시스템은 요청을 분석하여 필요한 에이전트를 결정합니다.
3. 적합한 에이전트에게 요청을 보냅니다.
4. 에이전트는 작업을 수행 후 시스템에 결과를 반환합니다.
5. 시스템은 결과를 사용자에게 전달합니다.

#### 코드 예제

이제, 시스템 내부에서 언어 분석과 라우팅이 어떻게 이루어지는지 코드 레벨에서 예를 들어 보겠습니다.

```python
class LangGraphSupervisor:
    def __init__(self):
        self.agents = {
            "문서 검색": "문서 검색 전문 에이전트",
            "데이터 분석": "데이터 분석 전문 에이전트"
        }

    def 분석후_라우팅(self, 요청):
        for 키워드, 에이전트 in self.agents.items():
            if 키워드 in 요청:
                return 에이전트
        return "일반 에이전트"

supervisor = LangGraphSupervisor()
에이전트 = supervisor.분석후_라우팅("데이터 분석을 요청합니다")
print(에이전트)  # 출력: 데이터 분석 전문 에이전트
```

이 코드에서는 요청을 처리 및 분배하는 `LangGraphSupervisor` 클래스의 구조를 보여줍니다.

## 결론

이 장에서는 AI 에이전트 총괄 시스템의 핵심 개념과 사용 방법을 배웠습니다. 이 시스템은 사용자의 자연어 요청을 분석하고 적절한 에이전트로 작업을 분배하는 것을 목표로 합니다. 다음 장에서는 이 시스템을 구동할 서버 [FastAPI 서버](02_fastapi_서버.md)에 대해 알아봅니다.
---

# Chapter 2: FastAPI 서버

이전 장에서는 [AI 에이전트 총괄 시스템 (LangGraph Supervisor)](01_ai_에이전트_총괄_시스템__langgraph_supervisor_.md)에 대해 알아보았습니다. 이번 장에서는 이러한 시스템이 원활하게 작동하기 위해 필요한 서버 기술인 **FastAPI 서버**에 대해 설명하겠습니다.

FastAPI 서버는 실시간 AI 통신을 처리하며, 사용자와 AI 시스템 간의 데이터 교환을 담당하는 중요한 역할을 합니다. 이 장에서는 FastAPI 서버의 기본적인 개념과 구현 방법을 이해하고, 실제로 간단한 서버를 만들어 보는 것을 목표로 합니다.

## FastAPI 서버의 동기

FastAPI 서버는 왜 필요한 걸까요? FastAPI는 Python 기반의 웹 프레임워크로, 빠르고 효율적인 API를 구축하는 데 사용됩니다. 이것은 특히 AI 시스템과의 빠른 데이터 교환에 최적화되어 있습니다. 예를 들어, 사용자가 챗봇에게 질문을 하거나 AI 분석 결과를 요청하는 시나리오에서 실시간으로 응답을 받아야 합니다. FastAPI는 이러한 요구 사항을 충족시킬 수 있는 솔루션입니다.

### 주요 개념 설명

#### 1. 경량 웹 프레임워크

- FastAPI는 경량 프레임워크로, 쉽고 빠르게 서버를 구축할 수 있습니다.
- 비동기식 처리(Asynchronous Handling)를 통해 높은 처리 성능을 제공합니다.

#### 2. 자동 문서화

- FastAPI는 API 엔드포인트에 대한 자동 문서화 기능을 제공합니다.
- 이는 개발자가 API를 쉽게 이해하고 사용할 수 있도록 돕습니다.

## FastAPI 서버 사용 방법

이제 FastAPI를 사용하여 간단한 서버를 구축하는 방법을 따라해보겠습니다.

### FastAPI 설치

우선 FastAPI를 설치해야 합니다. Python 패키지 매니저인 pip를 통해 설치할 수 있습니다.

```bash
pip install fastapi
pip install uvicorn
```

- `fastapi`: FastAPI 프레임워크 설치
- `uvicorn`: FastAPI 애플리케이션을 실행하기 위한 ASGI 서버

### 간단한 FastAPI 서버 구현

아래는 FastAPI를 사용하여 간단한 서버를 구축하는 코드입니다.

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def 읽기_루트():
    return {"메시지": "Hello World!"}
```

- `FastAPI()`: 새로운 FastAPI 애플리케이션 인스턴스를 생성합니다.
- `@app.get("/")`: 루트 URL에서 GET 요청을 처리합니다.
- `읽기_루트()`: 루트 URL에 접근할 때 반환할 메시지를 정의합니다.

### 서버 실행

FastAPI 애플리케이션을 실행하려면 Uvicorn을 사용합니다.

```bash
uvicorn main:app --reload
```

- `main:app`: main.py 파일의 `app` 객체를 실행합니다.
- `--reload`: 코드 변경 시 서버를 자동으로 다시 시작합니다.

## FastAPI 서버의 내부 구현

FastAPI 서버가 어떻게 내부적으로 작동하는지 알아보겠습니다. FastAPI는 비동기 처리 방식으로 요청을 처리합니다. 아래의 시퀀스 다이어그램은 간단한 HTTP 요청 프로세스를 보여줍니다.

```mermaid
sequenceDiagram
    participant 고객 as 고객
    participant 서버 as FastAPI 서버
    고객->>서버: HTTP 요청 전송
    서버->>고객: 응답 전달
```

1. 고객이 서버로 HTTP 요청을 보냅니다.
2. FastAPI 서버는 요청을 처리하고 적절한 응답을 생성합니다.
3. 응답이 고객에게 전달됩니다.

이제 FastAPI의 코드 구조를 통해 더 깊이 들어가 보겠습니다.

```python
from fastapi import FastAPI, HTTPException

app = FastAPI()

@app.get("/items/{item_id}")
def 읽기_아이템(item_id: int):
    # 데이터베이스에서 항목 찾기 (예시를 위한 간단한 로직)
    if item_id not in [1, 2, 3]:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"item_id": item_id, "값": "여기에 데이터가 들어갑니다"}
```

- `HTTPException`: FastAPI에서 에러 응답을 생성할 때 사용합니다.
- `@app.get("/items/{item_id}")`: 경로 매개변수 `item_id`를 사용하여 특정 아이템에 대한 정보를 요청할 수 있습니다.

## 결론

이번 장에서는 FastAPI 서버의 기본 개념과 이를 사용하여 간단한 웹 애플리케이션을 구축하는 방법을 배웠습니다. FastAPI는 실시간으로 AI 및 사용자의 데이터 교환을 처리하는 데 최적화되어 있습니다. 이제 다음 장에서는 [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)로 이동해 보겠습니다. 이는 사용자의 계정 및 인증 관리를 담당하는 중요한 모듈입니다.
---
# Chapter 3: 계정 관리 모듈 (Accounts Module)

이전 장에서는 [FastAPI 서버](02_fastapi_서버.md)에 대해 알아보았습니다. 이번 장에서는 시스템 사용자와 조직의 정보를 관리하고 인증 처리 기능을 제공하는 중요한 모듈, **계정 관리 모듈 (Accounts Module)**에 대해 설명하겠습니다.

## 계정 관리 모듈의 필요성

현대의 많은 웹 애플리케이션들은 개별 사용자에게 개인화된 경험을 제공하기 위해 사용자 정보와 인증 기능을 필요로 합니다. 예를 들어, 사용자가 앱에 로그인하여 자신의 정보를 확인하고 개인화된 서비스를 받으려면 적절한 계정 관리 시스템이 필수적입니다. 본 모듈은 이러한 요구를 만족시키기 위해 설계되었습니다.

### 주요 개념 설명

#### 1. 사용자 관리

- **사용자 정보**: 사용자의 이름, 이메일, 가입 날짜 등의 정보를 저장합니다.
- **비밀번호 관리**: 사용자 비밀번호를 안전하게 저장하고 변경하는 기능을 포함합니다.

#### 2. 조직 관리

- **조직 정보**: 조직 이름, 구성원 목록을 관리합니다.
- 조직 내 사용자의 역할을 부여하는 기능도 포함됩니다.

#### 3. 인증 처리

- 사용자의 신원을 확인하기 위해 로그인 기능과 토큰 기반 인증을 제공합니다.

## 계정 관리 모듈 사용 방법

이제 계정 관리 모듈을 사용하여 사용자를 생성하고 인증하는 방법을 알아보겠습니다.

### 새로운 사용자 생성

```python
def 사용자_생성(사용자_이름, 비밀번호):
    # 이곳에서 사용자 정보를 데이터베이스에 저장
    return {"메시지": f"{사용자_이름}가 성공적으로 생성되었습니다."}
```

- `사용자_생성`: 사용자 이름과 비밀번호를 사용해 새로운 사용자를 생성하는 함수입니다.
- 출력 메시지를 통해 사용자가 성공적으로 생성되었음을 볼 수 있습니다.

### 로그인 처리

```python
def 로그인(사용자_이름, 비밀번호):
    # 사용자 이름과 비밀번호가 맞는지 확인
    if 올바른_비밀번호(사용자_이름, 비밀번호):
        return {"메시지": "인증 성공"}
    else:
        return {"메시지": "인증 실패"}
```

- `로그인`: 사용자의 이름과 비밀번호를 확인하여 인증 처리 결과를 제공합니다.
- 비밀번호가 맞으면 "인증 성공" 메시지를, 그렇지 않으면 "인증 실패" 메시지를 반환합니다.

## 계정 관리 모듈의 내부 구현

계정 관리 모듈이 실제로 어떻게 작동하는지 이해하기 위해 대략적인 처리 과정을 살펴봅시다.

### 인증 처리 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 서버 as 계정 관리 모듈
    사용자->>서버: 로그인 요청 (사용자 이름, 비밀번호)
    서버->>서버: 비밀번호 확인
    alt 비밀번호가 맞을 때
        서버->>사용자: 인증 성공
    else 비밀번호가 틀릴 때
        서버->>사용자: 인증 실패
    end
```

1. 사용자가 계정 관리 모듈에 로그인 요청을 보냅니다.
2. 모듈은 비밀번호를 확인합니다.
3. 비밀번호가 맞으면 "인증 성공" 메시지를, 틀리면 "인증 실패" 메시지를 반환합니다.

### 내부 코드 구현

기본적인 계정 관리 시스템에는 사용자 정보를 저장하고 인증을 처리하는 클래스 또는 데이터베이스 연결이 필요합니다. 아래는 이러한 기능을 간단히 구현한 예입니다.

```python
class 계정관리:
    def __init__(self):
        self.사용자들 = {}

    def 사용자_추가(self, 이름, 비밀번호):
        self.사용자들[이름] = 비밀번호

    def 로그인_처리(self, 이름, 비밀번호):
        # 사용자 정보 및 비밀번호 일치 여부 확인
        if 이름 in self.사용자들 and self.사용자들[이름] == 비밀번호:
            return "인증 성공"
        return "인증 실패"

계정 = 계정관리()
계정.사용자_추가("홍길동", "비밀번호123")
인증_결과 = 계정.로그인_처리("홍길동", "비밀번호123")
print(인증_결과)  # 출력: 인증 성공
```

- `계정관리`: 사용자 정보를 저장하고 인증을 처리하는 클래스입니다.
- `로그인_처리`: 사용자 이름과 비밀번호가 올바른지 확인합니다.

## 결론

이번 장에서는 계정 관리 모듈을 이용해 사용자를 생성하고 인증하는 방법, 그리고 그 내부 구현을 통해 이 모듈이 어떻게 작동하는지 배웠습니다. 다음 장에서는 사용자와 AI 에이전트 간의 상호작용을 관리하는 [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)에 대해 알아보겠습니다.
---
# Chapter 4: 챗봇 세션 관리 (Chat Session Management)

이전 장에서는 [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)에 대해 알아보았습니다. 이번 장에서는 사용자의 대화 세션과 메시지를 효과적으로 관리하고 저장하는 **챗봇 세션 관리 (Chat Session Management)**에 대해 살펴보겠습니다.

## 챗봇 세션 관리의 필요성

챗봇은 다양한 사용자와 상호작용하며 많은 메시지를 처리합니다. 이때, 각 사용자와의 대화 세션을 올바르게 관리해야 이전 대화 기록을 사용하여 대화를 이어 나가거나 정보를 추출할 수 있습니다. 예를 들어, 사용자가 "얼마 전 주문했던 상품이 뭐였죠?"라고 묻는 경우, 이전 대화 세션을 통해 지난 주문 내역을 찾아 제공해야 합니다. 이렇게 하려면 세션 관리가 필수적입니다.

## 챗봇 세션 관리의 주요 개념

1. **세션 저장 (Session Storage)**
   - 각 사용자의 대화 세션을 저장합니다. 이를 통해 필요한 정보를 빠르게 조회할 수 있습니다.

2. **세션 유지 (Session Persistence)**
   - 사용자가 언제든 대화를 이어갈 수 있도록 이전 대화를 유지합니다. 사용자가 다시 접속했을 때, 이전 대화 맥락을 기반으로 서비스를 제공할 수 있습니다.

3. **세션 종료 (Session Termination)**
   - 일정 시간이 지나면 대화 세션을 종료하여 리소스를 효율적으로 관리합니다.

## 챗봇 세션 관리 사용 방법

### 사용자의 세션 저장 예제

아래는 사용자의 대화 세션을 저장하는 간단한 코드 예제입니다.

```python
def 세션_저장(사용자_id, 메시지):
    # 이곳에 세션 데이터를 저장하는 로직을 구현
    return {"메시지": f"{사용자_id}의 세션이 성공적으로 저장되었습니다."}
```

- `세션_저장`: 사용자 ID와 메시지를 받아 세션을 저장하는 함수입니다.
- 반환된 메시지를 통해 성공적으로 세션이 저장되었음을 알 수 있습니다.

### 세션 조회 구현

```python
def 세션_조회(사용자_id):
    # 저장된 세션 데이터를 가져오는 로직 구현
    return {"메시지": f"{사용자_id}의 세션 정보입니다."}
```

- `세션_조회`: 사용자 ID를 입력하면 해당 사용자의 저장된 세션 내용을 반환하는 함수입니다.

## 챗봇 세션 관리의 내부 구현

챗봇 세션 관리가 어떻게 이루어지는지 이해하기 위해 과정을 살펴보겠습니다.

### 세션 관리 처리 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 서버 as 챗봇 세션 관리
    사용자->>서버: 메시지 전송
    서버->>서버: 메시지 저장
    서버->>사용자: 세션 저장 완료 메시지
    사용자->>서버: 세션 조회 요청
    서버->>사용자: 세션 데이터 반환
```

1. 사용자가 메시지를 챗봇에 보냅니다.
2. 서버는 메시지를 세션 데이터베이스에 저장합니다.
3. 저장 완료 후 사용자는 저장 완료 확인 메시지를 받습니다.
4. 사용자가 이전 세션 조회를 요청하면, 서버는 저장된 데이터를 반환합니다.

### 코드 구현 예제

간단한 세션 관리 시스템 코드 예제입니다.

```python
class 세션관리:
    def __init__(self):
        self.세션들 = {}  # 세션 저장을 위한 딕셔너리
    
    def 저장(self, 사용자_id, 메시지):
        # 세션 저장 로직
        if 사용자_id not in self.세션들:
            self.세션들[사용자_id] = []
        self.세션들[사용자_id].append(메시지)
        return "세션 저장 완료"
    
    def 조회(self, 사용자_id):
        # 세션 조회 로직
        return self.세션들.get(사용자_id, "세션 없음")

관리자 = 세션관리()
관리자.저장("사용자1", "안녕하세요!")
결과 = 관리자.조회("사용자1")
print(결과)  # 출력: ['안녕하세요!']
```

- `세션관리`: 사용자 세션을 관리하는 클래스입니다.
- `저장`: 사용자 메시지를 세션에 저장합니다.
- `조회`: 저장된 세션을 반환합니다.

## 결론

이번 장에서는 챗봇 세션 관리를 통해 사용자 대화 세션을 어떻게 저장, 유지, 조회할 수 있는지 배웠습니다. 올바른 세션 관리가 가능해야 사용자에게 더 나은 챗봇 경험을 제공할 수 있습니다. 다음 장에서는 백엔드 라우팅을 효과적으로 활용하는 방법에 대해 알아보겠습니다: [백엔드 라우팅 (Backend Routing)](05_백엔드_라우팅__backend_routing_.md).
---
# Chapter 5: 백엔드 라우팅 (Backend Routing)

이전 장에서는 [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)에 대해 배웠습니다. 이번 장에서는 Django를 사용하여 백엔드 API 경로를 설정하는 방법, 즉 **백엔드 라우팅 (Backend Routing)**에 대해 알아보겠습니다.

## 백엔드 라우팅의 필요성

백엔드 라우팅은 웹 애플리케이션이 클라이언트로부터 요청을 받고 적절한 응답을 할 수 있도록 경로를 설정하는 것입니다. 예를 들어, 사용자가 웹사이트에서 상품 목록을 볼 때, 클라이언트에서의 요청이 백엔드에서 정확한 정보를 전달받기 위해 필요한 모든 것은 라우팅입니다. 이는 특히 여러 페이지가 있는 복잡한 웹 애플리케이션에서 필수적입니다.

### 예시: 상품 목록 보기

- 사용자가 웹사이트의 `/products` 페이지로 들어가면, 백엔드는 상품 목록 데이터를 클라이언트에 제공합니다.
- 적절한 라우팅이 없다면, 요청된 페이지를 찾을 수 없다는 오류 메시지를 보게 될 것입니다.

## 주요 개념

### 1. URL 경로

각각의 URL은 특정한 데이터나 페이지로의 경로입니다. Django에서는 URL 패턴을 설정하여 어떤 URL이 어떤 함수나 클래스로 처리될지를 결정합니다.

### 2. 뷰(View)

각 요청에 대해 응답을 생성하는 역할을 합니다. 예를 들어, 상품 목록 요청을 받아 그것에 대한 HTML 페이지나 JSON 데이터를 반환합니다.

## 백엔드 라우팅 사용 방법

이제 Django에서 간단한 라우팅을 설정하는 방법을 알아봅시다.

### URL 패턴 설정 예제

`urls.py` 파일을 활용하여 URL 패턴을 설정합니다.

```python
# urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('products/', views.상품목록보기, name='상품목록'),
]
```

- `path()`: URL 경로를 설정하는 함수입니다. 첫 번째 인자는 경로, 두 번째 인자는 처리할 뷰 함수, 세 번째는 경로 이름입니다.

### 뷰 함수 구현

라우팅 된 URL을 처리할 뷰 함수를 구현해 봅시다.

```python
# views.py
from django.http import HttpResponse

def 상품목록보기(request):
    # 예시로 간단한 응답을 보냄
    return HttpResponse("상품 목록 페이지입니다.")
```

- `HttpResponse`: HTTP 응답을 생성하는 클래스입니다. 여기에 문자열을 넣어 간단히 출력할 수 있습니다.

## 백엔드 라우팅의 내부 구현

백엔드 라우팅이 내부적으로 어떻게 작동하는지 이해하기 위해 시퀀스 다이어그램을 살펴보겠습니다.

### 프로세스 흐름

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 서버 as Django 서버
    사용자->>서버: /products 요청
    서버->>서버: 경로 확인 (urls.py)
    서버->>서버: 뷰 함수 실행 (views.py)
    서버->>사용자: 상품 목록 응답
```

1. 사용자가 `/products` URL로 요청을 보냅니다.
2. `urls.py`에서 해당 경로에 맞는 패턴을 찾습니다.
3. 연결된 뷰 함수가 실행되어 응답을 생성합니다.
4. 생성된 응답이 사용자에게 전달됩니다.

### 추가 코드 예시

뷰에서 데이터베이스와 연동하여 더 유용한 정보 제공을 위한 예제 코드입니다.

```python
# views.py
from django.http import JsonResponse
from .models import Product

def 상품목록보기(request):
    # 모든 상품의 정보를 가져옴
    products = Product.objects.all().values()
    return JsonResponse(list(products), safe=False)
```

- `JsonResponse`: 데이터를 JSON 형식으로 응답하는 클래스입니다.
- `Product.objects.all()`: 모든 상품 정보를 데이터베이스에서 조회합니다.

## 결론

이번 장에서는 Django를 활용한 백엔드 라우팅의 기본적인 개념과 이를 사용하여 웹 애플리케이션에서 URL을 처리하고 응답하는 방법에 대해 배웠습니다. 다음 장에서는 문서 검색을 담당하는 [문서 검색 전문 에이전트 (RAG Agent)](06_문서_검색_전문_에이전트__rag_agent_.md)에 대해 알아보겠습니다. 이 장에서 배운 라우팅 기법을 활용하여 다양한 API 요청을 관리하게 될 것입니다.
---
# Chapter 6: 문서 검색 전문 에이전트 (RAG Agent)

이전 장에서는 [백엔드 라우팅 (Backend Routing)](05_백엔드_라우팅__backend_routing_.md)에 대해 배웠습니다. 이번 장에서는 사용자의 질문에 대해 회사 내부 문서를 검색하고 답변을 생성하는 **문서 검색 전문 에이전트 (RAG Agent)**에 대해 알아보겠습니다.

## 문서 검색 에이전트의 필요성

회사 내부에는 중요한 정보가 담긴 수많은 문서들이 존재합니다. 그런데 만약 고객이 특정 정보를 문의했을 때, 직원이 일일이 문서를 뒤져야 한다면 얼마나 시간이 걸릴까요? 이러한 문제를 해결하려면 자동화된 문서 검색 시스템이 필요합니다. **문서 검색 전문 에이전트**는 사용자의 질문에 맞춰 해당 문서를 빠르게 검색하고, 요청된 정보를 제공합니다.

### 예시 시나리오

- 고객이 "이 제품의 안전 지침은 무엇인가요?"라고 질문합니다.
- 에이전트는 즉시 관련 문서를 검색하고 적합한 내용을 찾아 답변합니다. 

## 문서 검색 에이전트의 주요 개념

### 1. 질의 처리 (Query Processing)
   - 사용자가 입력한 질문을 이해하고 가장 적합한 정보를 검색합니다.

### 2. 문서 인덱싱 (Document Indexing)
   - 모든 문서를 검색 가능한 형태로 인덱싱하여 빠른 검색이 가능하도록 합니다.

### 3. 정보 검색 (Information Retrieval)
   - 사용자의 질의에 맞는 문서를 찾아내고, 필요한 정보를 추출해서 제공합니다.

## 문서 검색 에이전트 사용 방법

문서 검색 에이전트를 사용하여 간단한 검색을 수행하는 방법을 알아보겠습니다.

### 사용자의 질문에 답변 예제

```python
def 질문_답변(질문):
    # 요청한 질문에 맞는 문서를 검색하는 로직
    return {"답변": f"'{질문}'에 대한 답변입니다."}
```

- `질문_답변`: 입력된 질문에 따라 특정 문서를 검색하고 답변을 제공하는 함수입니다.
- 결과로 질문에 해당하는 답변을 반환합니다.

### 코드 구현 예제

```python
class 문서검색에이전트:
    def __init__(self, 문서들):
        self.문서들 = 문서들
    
    def 검색(self, 질문):
        # 간단한 키워드 기반 검색 예제
        for 문서 in self.문서들:
            if 질문 in 문서:
                return 문서
        return "관련 문서 없음"

에이전트 = 문서검색에이전트(["안전 지침", "사용 설명서"])
답변 = 에이전트.검색("안전")
print(답변)  # 출력: 안전 지침
```

- `문서검색에이전트`: 문서를 관리하고 검색을 수행하는 클래스입니다.
- `검색`: 문서에서 질문에 맞는 내용을 찾아 반환합니다.

## 내부 작동 방식

문서 검색 전문 에이전트가 어떻게 작동하는지 시퀀스 다이어그램으로 살펴보겠습니다.

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 에이전트 as 문서 검색 에이전트
    사용자->>에이전트: 질문 전송
    에이전트->>에이전트: 문서 검색
    에이전트->>사용자: 검색 결과 반환
```

1. 사용자가 에이전트에 질문을 보냅니다.
2. 에이전트는 내부 문서를 바탕으로 질문에 해당하는 정보를 검색합니다.
3. 검색 결과를 사용자에게 반환합니다.

### 추가 코드 설명

더 복잡한 검색 기능을 위해서는 NLP를 활용해 질문을 보다 정교하게 처리할 수 있습니다.

```python
import re

class 고급문서검색에이전트:
    def __init__(self, 문서들):
        self.문서들 = 문서들
    
    def 고급_검색(self, 질문):
        # 정규식을 이용한 고급 검색 예제
        패턴 = re.compile(r'\b{}\b'.format(re.escape(질문)))
        for 문서 in self.문서들:
            if 패턴.search(문서):
                return 문서
        return "관련 문서 없음"

고급에이전트 = 고급문서검색에이전트(["안전 지침", "사용 설명서"])
고급답변 = 고급에이전트.고급_검색("지침")
print(고급답변)  # 출력: 안전 지침
```

- `고급문서검색에이전트`: 자연어 처리 기능을 추가한 문서 검색 에이전트 클래스입니다.
- 정규식을 사용하여 질문에 대해 더 정확한 검색이 가능합니다.

## 결론

이번 장에서는 문서 검색 전문 에이전트를 통해 회사 내부 문서를 빠르게 검색하고 필요한 정보를 제공하는 방법을 배웠습니다. 이러한 자동화 시스템은 업무 효율성을 크게 향상시킬 수 있습니다. 다음 장에서는 회사의 지식 자산을 체계적으로 관리하는 [지식베이스 관리 (Knowledge Management)](07_지식베이스_관리__knowledge_management_.md)에 대해 알아보겠습니다.

Relevant Code Snippets (Code itself remains unchanged):
No specific code snippets provided for this abstraction.

Instructions for the chapter (Generate content in Korean unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 7: 지식베이스 관리 (Knowledge Management)`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).

- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).

- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).

- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).

- Heavily use analogies and examples throughout (in Korean) to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).

- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-06-30 00:18:54,246 - INFO - Using OpenAI model: gpt-4o
2025-06-30 00:19:08,852 - INFO - RESPONSE: # Chapter 7: 지식베이스 관리 (Knowledge Management)

이전 장에서는 [문서 검색 전문 에이전트 (RAG Agent)](06_문서_검색_전문_에이전트__rag_agent_.md)의 기능에 대해 알아보았습니다. 이번 장에서는 조직의 문서와 데이터를 체계적으로 관리하고 검색할 수 있는 방안을 제공하는 **지식베이스 관리 (Knowledge Management)**에 대해 다뤄보겠습니다.

## 지식베이스 관리의 필요성

조직은 다양한 문서와 데이터를 생성하고 사용합니다. 이러한 정보들은 시간이 지남에 따라 증가하고, 적절하게 관리되지 않으면 그 가치를 잃게 됩니다. 지식베이스 관리는 이러한 정보를 중앙에서 관리하고, 필요 시 빠르게 찾을 수 있도록 도와줍니다. 예를 들어, 고객 서비스 센터에서 자주 묻는 질문(FAQ)을 빠르게 검색할 수 있도록 관리하는 것입니다.

### 주요 개념 설명

1. **문서 저장 (Document Storage)**
   - 조직의 문서, 매뉴얼, 보고서 등을 중앙 저장소에 안전하게 보관합니다.

2. **문서 검색 (Document Retrieval)**
   - 특정 키워드나 주제에 따라 문서를 효과적으로 검색할 수 있습니다.

3. **임베딩 데이터 관리 (Embedding Data Management)**
   - 문서의 중요한 정보를 임베딩 데이터로 저장하여 검색과 활용을 돕습니다.

## 지식베이스 관리 사용 방법

### 문서 저장 예제

```python
def 문서_저장(문서_이름, 내용):
    # 문서를 저장하는 간단한 로직 예제
    return {"메시지": f"'{문서_이름}' 문서가 성공적으로 저장되었습니다."}
```

- `문서_저장`: 문서 이름과 내용을 입력받아 저장하는 함수입니다.
- 반환 값은 저장 성공을 알리는 메시지입니다.

### 문서 검색 예제

```python
def 문서_검색(키워드):
    # 키워드에 해당하는 문서를 검색하는 간단한 로직
    return {"결과": f"'{키워드}'와 관련된 문서를 찾았습니다."}
```

- `문서_검색`: 특정 키워드를 입력하여 관련 문서를 검색하는 함수입니다.
- 결과로 관련 문서를 찾았다는 메시지를 제공받습니다.

## 지식베이스 관리의 내부 구현

지식베이스 관리 시스템이 어떻게 작동하는지 시퀀스 다이어그램으로 설명합니다.

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 관리자 as 지식베이스 관리자 시스템
    사용자->>관리자: 문서 저장 요청
    관리자->>관리자: 문서 저장 절차 실행
    관리자->>사용자: 저장 완료 메시지
    사용자->>관리자: 문서 검색 요청
    관리자->>관리자: 키워드 기반 문서 검색
    관리자->>사용자: 검색 결과 반환
```

1. 사용자가 문서를 저장하려고 시스템에 요청을 보냅니다.
2. 시스템은 문서를 저장하고, 사용자에게 성공 메시지를 보냅니다.
3. 사용자가 문서 검색을 요청하면, 시스템은 키워드 기반으로 문서를 검색합니다.
4. 시스템은 검색 결과를 사용자에게 반환합니다.

### 내부 코드 예제

지식베이스 관리의 간단한 코드 예시입니다.

```python
class 지식베이스관리자:
    def __init__(self):
        self.문서들 = {}  # 문서 저장소

    def 문서_추가(self, 이름, 내용):
        # 문서를 추가하는 로직
        self.문서들[이름] = 내용
        return "문서 추가 완료"

    def 문서_검색(self, 키워드):
        # 키워드 기반 검색 로직
        결과 = [이름 for 이름 in self.문서들 if 키워드 in 이름]
        return 결과 or ["관련 문서 없음"]

관리자 = 지식베이스관리자()
관리자.문서_추가("안전 지침", "중요한 안전 정보")
검색_결과 = 관리자.문서_검색("안전")
print(검색_결과)  # 출력: ['안전 지침']
```

- `지식베이스관리자`: 문서 저장과 검색을 담당합니다.
- `문서_추가`: 새로운 문서를 저장소에 추가합니다.
- `문서_검색`: 특정 키워드를 기반으로 문서를 검색하여 반환합니다.

## 결론

이번 장에서는 지식베이스 관리 시스템을 통해 조직의 문서를 체계적으로 저장하고 검색하는 방법을 배웠습니다. 이로써 필요한 정보를 신속하게 찾고, 업무 효율성을 향상시킬 수 있습니다. 다음 장에서는 데이터를 분석하여 유의미한 정보를 도출하는 [데이터 분석 전문 에이전트 (Analytics Agent)](08_데이터_분석_전문_에이전트__analytics_agent_.md)에 대해 알아보겠습니다.
2025-06-30 00:19:08,870 - INFO - PROMPT: 
IMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.

Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `SKN10-FINAL-1Team` about the concept: "데이터 분석 전문 에이전트 (Analytics Agent)". This is Chapter 8.

Concept Details (Note: Provided in Korean):
- Name: 데이터 분석 전문 에이전트 (Analytics Agent)
- Description:
사용자의 질문을 바탕으로 데이터베이스를 검색, 분석하여 정보를 제공하는 에이전트입니다. (Agent that analyzes and provides insights from the database based on user queries.)

Complete Tutorial Structure (Note: Chapter names might be in Korean):
1. [AI 에이전트 총괄 시스템 (LangGraph Supervisor)](01_ai_에이전트_총괄_시스템__langgraph_supervisor_.md)
2. [FastAPI 서버](02_fastapi_서버.md)
3. [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)
4. [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)
5. [백엔드 라우팅 (Backend Routing)](05_백엔드_라우팅__backend_routing_.md)
6. [문서 검색 전문 에이전트 (RAG Agent)](06_문서_검색_전문_에이전트__rag_agent_.md)
7. [지식베이스 관리 (Knowledge Management)](07_지식베이스_관리__knowledge_management_.md)
8. [데이터 분석 전문 에이전트 (Analytics Agent)](08_데이터_분석_전문_에이전트__analytics_agent_.md)
9. [MLOps 관리 (MLOps Management)](09_mlops_관리__mlops_management_.md)
10. [환경 설정 및 배포 (Environment Setup and Deployment)](10_환경_설정_및_배포__environment_setup_and_deployment_.md)

Context from previous chapters (Note: This summary might be in Korean):
# Chapter 1: AI 에이전트 총괄 시스템 (LangGraph Supervisor)

## 소개

우리가 상상하는 미래의 세계에서는 다양한 AI 에이전트가 우리의 일상 속에서 많은 역할을 하게 될 것입니다. 이 장에서는 사용자의 자연어 요청을 신속하고 정확하게 분석하여 적합한 전문 에이전트에게 작업을 분배하는 시스템인 **AI 에이전트 총괄 시스템 (LangGraph Supervisor)**를 소개합니다.

## 왜 AI 에이전트 총괄 시스템이 필요한가요?

### 문제에 대한 개요

어느 날, 당신은 다수의 AI 전문 에이전트를 관리하는 프로젝트의 관리자입니다. 고객이 다양한 요구를 AI에게 요청하지만 그 요청마다 다른 전문 에이전트로 보내야 합니다. 예를 들어, 문서 검색이 필요한 경우에는 '문서 검색 전문 에이전트', 데이터 분석이 필요한 경우에는 '데이터 분석 전문 에이전트'가 필요합니다.

AI 에이전트 총괄 시스템은 이러한 문제를 해결하기 위해 만들어졌습니다. 사용자가 보내는 자연어 요청을 효과적으로 해석하고, 적합한 에이전트로 작업을 분배합니다.

### 핵심 개념 설명

1. **자연어 처리 (Natural Language Processing)**: 사용자의 요청을 분석하기 위해 사용됩니다. 텍스트를 이해하고 그 의미를 파악합니다.

2. **에이전트 라우팅**: 각 에이전트는 서로 다른 전문 분야를 가지고 있으며, 요청에 가장 적합한 에이전트에게 작업을 보내기 위한 과정입니다.

## AI 에이전트 총괄 시스템 사용 방법

이 시스템을 이해하는 것을 용이하게 하기 위해, 우리는 간단한 예제를 통해 따라가 볼 것입니다.

### 간단한 구현 예제

```python
def 언어_분석(요청):
    # 요청의 내용을 분석하여 필요한 에이전트를 결정함
    if "데이터 분석" in 요청:
        return "데이터 분석 전문 에이전트"
    elif "문서 검색" in 요청:
        return "문서 검색 전문 에이전트"
    else:
        return "일반 에이전트"

결정된_에이전트 = 언어_분석("문서 검색을 원해요")
print(결정된_에이전트)  # 출력: 문서 검색 전문 에이전트
```

위의 코드는 사용자의 요청을 간단히 분석하고, 해당 요청을 가장 잘 수행할 에이전트를 선정하는 프로세스를 보여줍니다.

### 내부 구현

시스템이 어떻게 내부적으로 작동하는지 더 잘 이해하기 위해, 몇 가지 과정을 단계별로 나누어 설명하겠습니다.

#### 시스템 작동 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 시스템 as LangGraph Supervisor
    participant 에이전트1 as 문서 검색 전문 에이전트
    participant 에이전트2 as 데이터 분석 전문 에이전트
    사용자->>시스템: 자연어 요청 전송
    시스템->>사용자: 요청 분석
    시스템->>에이전트1: 적합한 에이전트로 요청 전달
    에이전트1->>시스템: 작업 수행 후 결과 반환
    시스템->>사용자: 결과 전송
```

1. 사용자는 자연어 요청을 시스템에 보냅니다.
2. 시스템은 요청을 분석하여 필요한 에이전트를 결정합니다.
3. 적합한 에이전트에게 요청을 보냅니다.
4. 에이전트는 작업을 수행 후 시스템에 결과를 반환합니다.
5. 시스템은 결과를 사용자에게 전달합니다.

#### 코드 예제

이제, 시스템 내부에서 언어 분석과 라우팅이 어떻게 이루어지는지 코드 레벨에서 예를 들어 보겠습니다.

```python
class LangGraphSupervisor:
    def __init__(self):
        self.agents = {
            "문서 검색": "문서 검색 전문 에이전트",
            "데이터 분석": "데이터 분석 전문 에이전트"
        }

    def 분석후_라우팅(self, 요청):
        for 키워드, 에이전트 in self.agents.items():
            if 키워드 in 요청:
                return 에이전트
        return "일반 에이전트"

supervisor = LangGraphSupervisor()
에이전트 = supervisor.분석후_라우팅("데이터 분석을 요청합니다")
print(에이전트)  # 출력: 데이터 분석 전문 에이전트
```

이 코드에서는 요청을 처리 및 분배하는 `LangGraphSupervisor` 클래스의 구조를 보여줍니다.

## 결론

이 장에서는 AI 에이전트 총괄 시스템의 핵심 개념과 사용 방법을 배웠습니다. 이 시스템은 사용자의 자연어 요청을 분석하고 적절한 에이전트로 작업을 분배하는 것을 목표로 합니다. 다음 장에서는 이 시스템을 구동할 서버 [FastAPI 서버](02_fastapi_서버.md)에 대해 알아봅니다.
---

# Chapter 2: FastAPI 서버

이전 장에서는 [AI 에이전트 총괄 시스템 (LangGraph Supervisor)](01_ai_에이전트_총괄_시스템__langgraph_supervisor_.md)에 대해 알아보았습니다. 이번 장에서는 이러한 시스템이 원활하게 작동하기 위해 필요한 서버 기술인 **FastAPI 서버**에 대해 설명하겠습니다.

FastAPI 서버는 실시간 AI 통신을 처리하며, 사용자와 AI 시스템 간의 데이터 교환을 담당하는 중요한 역할을 합니다. 이 장에서는 FastAPI 서버의 기본적인 개념과 구현 방법을 이해하고, 실제로 간단한 서버를 만들어 보는 것을 목표로 합니다.

## FastAPI 서버의 동기

FastAPI 서버는 왜 필요한 걸까요? FastAPI는 Python 기반의 웹 프레임워크로, 빠르고 효율적인 API를 구축하는 데 사용됩니다. 이것은 특히 AI 시스템과의 빠른 데이터 교환에 최적화되어 있습니다. 예를 들어, 사용자가 챗봇에게 질문을 하거나 AI 분석 결과를 요청하는 시나리오에서 실시간으로 응답을 받아야 합니다. FastAPI는 이러한 요구 사항을 충족시킬 수 있는 솔루션입니다.

### 주요 개념 설명

#### 1. 경량 웹 프레임워크

- FastAPI는 경량 프레임워크로, 쉽고 빠르게 서버를 구축할 수 있습니다.
- 비동기식 처리(Asynchronous Handling)를 통해 높은 처리 성능을 제공합니다.

#### 2. 자동 문서화

- FastAPI는 API 엔드포인트에 대한 자동 문서화 기능을 제공합니다.
- 이는 개발자가 API를 쉽게 이해하고 사용할 수 있도록 돕습니다.

## FastAPI 서버 사용 방법

이제 FastAPI를 사용하여 간단한 서버를 구축하는 방법을 따라해보겠습니다.

### FastAPI 설치

우선 FastAPI를 설치해야 합니다. Python 패키지 매니저인 pip를 통해 설치할 수 있습니다.

```bash
pip install fastapi
pip install uvicorn
```

- `fastapi`: FastAPI 프레임워크 설치
- `uvicorn`: FastAPI 애플리케이션을 실행하기 위한 ASGI 서버

### 간단한 FastAPI 서버 구현

아래는 FastAPI를 사용하여 간단한 서버를 구축하는 코드입니다.

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def 읽기_루트():
    return {"메시지": "Hello World!"}
```

- `FastAPI()`: 새로운 FastAPI 애플리케이션 인스턴스를 생성합니다.
- `@app.get("/")`: 루트 URL에서 GET 요청을 처리합니다.
- `읽기_루트()`: 루트 URL에 접근할 때 반환할 메시지를 정의합니다.

### 서버 실행

FastAPI 애플리케이션을 실행하려면 Uvicorn을 사용합니다.

```bash
uvicorn main:app --reload
```

- `main:app`: main.py 파일의 `app` 객체를 실행합니다.
- `--reload`: 코드 변경 시 서버를 자동으로 다시 시작합니다.

## FastAPI 서버의 내부 구현

FastAPI 서버가 어떻게 내부적으로 작동하는지 알아보겠습니다. FastAPI는 비동기 처리 방식으로 요청을 처리합니다. 아래의 시퀀스 다이어그램은 간단한 HTTP 요청 프로세스를 보여줍니다.

```mermaid
sequenceDiagram
    participant 고객 as 고객
    participant 서버 as FastAPI 서버
    고객->>서버: HTTP 요청 전송
    서버->>고객: 응답 전달
```

1. 고객이 서버로 HTTP 요청을 보냅니다.
2. FastAPI 서버는 요청을 처리하고 적절한 응답을 생성합니다.
3. 응답이 고객에게 전달됩니다.

이제 FastAPI의 코드 구조를 통해 더 깊이 들어가 보겠습니다.

```python
from fastapi import FastAPI, HTTPException

app = FastAPI()

@app.get("/items/{item_id}")
def 읽기_아이템(item_id: int):
    # 데이터베이스에서 항목 찾기 (예시를 위한 간단한 로직)
    if item_id not in [1, 2, 3]:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"item_id": item_id, "값": "여기에 데이터가 들어갑니다"}
```

- `HTTPException`: FastAPI에서 에러 응답을 생성할 때 사용합니다.
- `@app.get("/items/{item_id}")`: 경로 매개변수 `item_id`를 사용하여 특정 아이템에 대한 정보를 요청할 수 있습니다.

## 결론

이번 장에서는 FastAPI 서버의 기본 개념과 이를 사용하여 간단한 웹 애플리케이션을 구축하는 방법을 배웠습니다. FastAPI는 실시간으로 AI 및 사용자의 데이터 교환을 처리하는 데 최적화되어 있습니다. 이제 다음 장에서는 [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)로 이동해 보겠습니다. 이는 사용자의 계정 및 인증 관리를 담당하는 중요한 모듈입니다.
---
# Chapter 3: 계정 관리 모듈 (Accounts Module)

이전 장에서는 [FastAPI 서버](02_fastapi_서버.md)에 대해 알아보았습니다. 이번 장에서는 시스템 사용자와 조직의 정보를 관리하고 인증 처리 기능을 제공하는 중요한 모듈, **계정 관리 모듈 (Accounts Module)**에 대해 설명하겠습니다.

## 계정 관리 모듈의 필요성

현대의 많은 웹 애플리케이션들은 개별 사용자에게 개인화된 경험을 제공하기 위해 사용자 정보와 인증 기능을 필요로 합니다. 예를 들어, 사용자가 앱에 로그인하여 자신의 정보를 확인하고 개인화된 서비스를 받으려면 적절한 계정 관리 시스템이 필수적입니다. 본 모듈은 이러한 요구를 만족시키기 위해 설계되었습니다.

### 주요 개념 설명

#### 1. 사용자 관리

- **사용자 정보**: 사용자의 이름, 이메일, 가입 날짜 등의 정보를 저장합니다.
- **비밀번호 관리**: 사용자 비밀번호를 안전하게 저장하고 변경하는 기능을 포함합니다.

#### 2. 조직 관리

- **조직 정보**: 조직 이름, 구성원 목록을 관리합니다.
- 조직 내 사용자의 역할을 부여하는 기능도 포함됩니다.

#### 3. 인증 처리

- 사용자의 신원을 확인하기 위해 로그인 기능과 토큰 기반 인증을 제공합니다.

## 계정 관리 모듈 사용 방법

이제 계정 관리 모듈을 사용하여 사용자를 생성하고 인증하는 방법을 알아보겠습니다.

### 새로운 사용자 생성

```python
def 사용자_생성(사용자_이름, 비밀번호):
    # 이곳에서 사용자 정보를 데이터베이스에 저장
    return {"메시지": f"{사용자_이름}가 성공적으로 생성되었습니다."}
```

- `사용자_생성`: 사용자 이름과 비밀번호를 사용해 새로운 사용자를 생성하는 함수입니다.
- 출력 메시지를 통해 사용자가 성공적으로 생성되었음을 볼 수 있습니다.

### 로그인 처리

```python
def 로그인(사용자_이름, 비밀번호):
    # 사용자 이름과 비밀번호가 맞는지 확인
    if 올바른_비밀번호(사용자_이름, 비밀번호):
        return {"메시지": "인증 성공"}
    else:
        return {"메시지": "인증 실패"}
```

- `로그인`: 사용자의 이름과 비밀번호를 확인하여 인증 처리 결과를 제공합니다.
- 비밀번호가 맞으면 "인증 성공" 메시지를, 그렇지 않으면 "인증 실패" 메시지를 반환합니다.

## 계정 관리 모듈의 내부 구현

계정 관리 모듈이 실제로 어떻게 작동하는지 이해하기 위해 대략적인 처리 과정을 살펴봅시다.

### 인증 처리 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 서버 as 계정 관리 모듈
    사용자->>서버: 로그인 요청 (사용자 이름, 비밀번호)
    서버->>서버: 비밀번호 확인
    alt 비밀번호가 맞을 때
        서버->>사용자: 인증 성공
    else 비밀번호가 틀릴 때
        서버->>사용자: 인증 실패
    end
```

1. 사용자가 계정 관리 모듈에 로그인 요청을 보냅니다.
2. 모듈은 비밀번호를 확인합니다.
3. 비밀번호가 맞으면 "인증 성공" 메시지를, 틀리면 "인증 실패" 메시지를 반환합니다.

### 내부 코드 구현

기본적인 계정 관리 시스템에는 사용자 정보를 저장하고 인증을 처리하는 클래스 또는 데이터베이스 연결이 필요합니다. 아래는 이러한 기능을 간단히 구현한 예입니다.

```python
class 계정관리:
    def __init__(self):
        self.사용자들 = {}

    def 사용자_추가(self, 이름, 비밀번호):
        self.사용자들[이름] = 비밀번호

    def 로그인_처리(self, 이름, 비밀번호):
        # 사용자 정보 및 비밀번호 일치 여부 확인
        if 이름 in self.사용자들 and self.사용자들[이름] == 비밀번호:
            return "인증 성공"
        return "인증 실패"

계정 = 계정관리()
계정.사용자_추가("홍길동", "비밀번호123")
인증_결과 = 계정.로그인_처리("홍길동", "비밀번호123")
print(인증_결과)  # 출력: 인증 성공
```

- `계정관리`: 사용자 정보를 저장하고 인증을 처리하는 클래스입니다.
- `로그인_처리`: 사용자 이름과 비밀번호가 올바른지 확인합니다.

## 결론

이번 장에서는 계정 관리 모듈을 이용해 사용자를 생성하고 인증하는 방법, 그리고 그 내부 구현을 통해 이 모듈이 어떻게 작동하는지 배웠습니다. 다음 장에서는 사용자와 AI 에이전트 간의 상호작용을 관리하는 [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)에 대해 알아보겠습니다.
---
# Chapter 4: 챗봇 세션 관리 (Chat Session Management)

이전 장에서는 [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)에 대해 알아보았습니다. 이번 장에서는 사용자의 대화 세션과 메시지를 효과적으로 관리하고 저장하는 **챗봇 세션 관리 (Chat Session Management)**에 대해 살펴보겠습니다.

## 챗봇 세션 관리의 필요성

챗봇은 다양한 사용자와 상호작용하며 많은 메시지를 처리합니다. 이때, 각 사용자와의 대화 세션을 올바르게 관리해야 이전 대화 기록을 사용하여 대화를 이어 나가거나 정보를 추출할 수 있습니다. 예를 들어, 사용자가 "얼마 전 주문했던 상품이 뭐였죠?"라고 묻는 경우, 이전 대화 세션을 통해 지난 주문 내역을 찾아 제공해야 합니다. 이렇게 하려면 세션 관리가 필수적입니다.

## 챗봇 세션 관리의 주요 개념

1. **세션 저장 (Session Storage)**
   - 각 사용자의 대화 세션을 저장합니다. 이를 통해 필요한 정보를 빠르게 조회할 수 있습니다.

2. **세션 유지 (Session Persistence)**
   - 사용자가 언제든 대화를 이어갈 수 있도록 이전 대화를 유지합니다. 사용자가 다시 접속했을 때, 이전 대화 맥락을 기반으로 서비스를 제공할 수 있습니다.

3. **세션 종료 (Session Termination)**
   - 일정 시간이 지나면 대화 세션을 종료하여 리소스를 효율적으로 관리합니다.

## 챗봇 세션 관리 사용 방법

### 사용자의 세션 저장 예제

아래는 사용자의 대화 세션을 저장하는 간단한 코드 예제입니다.

```python
def 세션_저장(사용자_id, 메시지):
    # 이곳에 세션 데이터를 저장하는 로직을 구현
    return {"메시지": f"{사용자_id}의 세션이 성공적으로 저장되었습니다."}
```

- `세션_저장`: 사용자 ID와 메시지를 받아 세션을 저장하는 함수입니다.
- 반환된 메시지를 통해 성공적으로 세션이 저장되었음을 알 수 있습니다.

### 세션 조회 구현

```python
def 세션_조회(사용자_id):
    # 저장된 세션 데이터를 가져오는 로직 구현
    return {"메시지": f"{사용자_id}의 세션 정보입니다."}
```

- `세션_조회`: 사용자 ID를 입력하면 해당 사용자의 저장된 세션 내용을 반환하는 함수입니다.

## 챗봇 세션 관리의 내부 구현

챗봇 세션 관리가 어떻게 이루어지는지 이해하기 위해 과정을 살펴보겠습니다.

### 세션 관리 처리 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 서버 as 챗봇 세션 관리
    사용자->>서버: 메시지 전송
    서버->>서버: 메시지 저장
    서버->>사용자: 세션 저장 완료 메시지
    사용자->>서버: 세션 조회 요청
    서버->>사용자: 세션 데이터 반환
```

1. 사용자가 메시지를 챗봇에 보냅니다.
2. 서버는 메시지를 세션 데이터베이스에 저장합니다.
3. 저장 완료 후 사용자는 저장 완료 확인 메시지를 받습니다.
4. 사용자가 이전 세션 조회를 요청하면, 서버는 저장된 데이터를 반환합니다.

### 코드 구현 예제

간단한 세션 관리 시스템 코드 예제입니다.

```python
class 세션관리:
    def __init__(self):
        self.세션들 = {}  # 세션 저장을 위한 딕셔너리
    
    def 저장(self, 사용자_id, 메시지):
        # 세션 저장 로직
        if 사용자_id not in self.세션들:
            self.세션들[사용자_id] = []
        self.세션들[사용자_id].append(메시지)
        return "세션 저장 완료"
    
    def 조회(self, 사용자_id):
        # 세션 조회 로직
        return self.세션들.get(사용자_id, "세션 없음")

관리자 = 세션관리()
관리자.저장("사용자1", "안녕하세요!")
결과 = 관리자.조회("사용자1")
print(결과)  # 출력: ['안녕하세요!']
```

- `세션관리`: 사용자 세션을 관리하는 클래스입니다.
- `저장`: 사용자 메시지를 세션에 저장합니다.
- `조회`: 저장된 세션을 반환합니다.

## 결론

이번 장에서는 챗봇 세션 관리를 통해 사용자 대화 세션을 어떻게 저장, 유지, 조회할 수 있는지 배웠습니다. 올바른 세션 관리가 가능해야 사용자에게 더 나은 챗봇 경험을 제공할 수 있습니다. 다음 장에서는 백엔드 라우팅을 효과적으로 활용하는 방법에 대해 알아보겠습니다: [백엔드 라우팅 (Backend Routing)](05_백엔드_라우팅__backend_routing_.md).
---
# Chapter 5: 백엔드 라우팅 (Backend Routing)

이전 장에서는 [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)에 대해 배웠습니다. 이번 장에서는 Django를 사용하여 백엔드 API 경로를 설정하는 방법, 즉 **백엔드 라우팅 (Backend Routing)**에 대해 알아보겠습니다.

## 백엔드 라우팅의 필요성

백엔드 라우팅은 웹 애플리케이션이 클라이언트로부터 요청을 받고 적절한 응답을 할 수 있도록 경로를 설정하는 것입니다. 예를 들어, 사용자가 웹사이트에서 상품 목록을 볼 때, 클라이언트에서의 요청이 백엔드에서 정확한 정보를 전달받기 위해 필요한 모든 것은 라우팅입니다. 이는 특히 여러 페이지가 있는 복잡한 웹 애플리케이션에서 필수적입니다.

### 예시: 상품 목록 보기

- 사용자가 웹사이트의 `/products` 페이지로 들어가면, 백엔드는 상품 목록 데이터를 클라이언트에 제공합니다.
- 적절한 라우팅이 없다면, 요청된 페이지를 찾을 수 없다는 오류 메시지를 보게 될 것입니다.

## 주요 개념

### 1. URL 경로

각각의 URL은 특정한 데이터나 페이지로의 경로입니다. Django에서는 URL 패턴을 설정하여 어떤 URL이 어떤 함수나 클래스로 처리될지를 결정합니다.

### 2. 뷰(View)

각 요청에 대해 응답을 생성하는 역할을 합니다. 예를 들어, 상품 목록 요청을 받아 그것에 대한 HTML 페이지나 JSON 데이터를 반환합니다.

## 백엔드 라우팅 사용 방법

이제 Django에서 간단한 라우팅을 설정하는 방법을 알아봅시다.

### URL 패턴 설정 예제

`urls.py` 파일을 활용하여 URL 패턴을 설정합니다.

```python
# urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('products/', views.상품목록보기, name='상품목록'),
]
```

- `path()`: URL 경로를 설정하는 함수입니다. 첫 번째 인자는 경로, 두 번째 인자는 처리할 뷰 함수, 세 번째는 경로 이름입니다.

### 뷰 함수 구현

라우팅 된 URL을 처리할 뷰 함수를 구현해 봅시다.

```python
# views.py
from django.http import HttpResponse

def 상품목록보기(request):
    # 예시로 간단한 응답을 보냄
    return HttpResponse("상품 목록 페이지입니다.")
```

- `HttpResponse`: HTTP 응답을 생성하는 클래스입니다. 여기에 문자열을 넣어 간단히 출력할 수 있습니다.

## 백엔드 라우팅의 내부 구현

백엔드 라우팅이 내부적으로 어떻게 작동하는지 이해하기 위해 시퀀스 다이어그램을 살펴보겠습니다.

### 프로세스 흐름

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 서버 as Django 서버
    사용자->>서버: /products 요청
    서버->>서버: 경로 확인 (urls.py)
    서버->>서버: 뷰 함수 실행 (views.py)
    서버->>사용자: 상품 목록 응답
```

1. 사용자가 `/products` URL로 요청을 보냅니다.
2. `urls.py`에서 해당 경로에 맞는 패턴을 찾습니다.
3. 연결된 뷰 함수가 실행되어 응답을 생성합니다.
4. 생성된 응답이 사용자에게 전달됩니다.

### 추가 코드 예시

뷰에서 데이터베이스와 연동하여 더 유용한 정보 제공을 위한 예제 코드입니다.

```python
# views.py
from django.http import JsonResponse
from .models import Product

def 상품목록보기(request):
    # 모든 상품의 정보를 가져옴
    products = Product.objects.all().values()
    return JsonResponse(list(products), safe=False)
```

- `JsonResponse`: 데이터를 JSON 형식으로 응답하는 클래스입니다.
- `Product.objects.all()`: 모든 상품 정보를 데이터베이스에서 조회합니다.

## 결론

이번 장에서는 Django를 활용한 백엔드 라우팅의 기본적인 개념과 이를 사용하여 웹 애플리케이션에서 URL을 처리하고 응답하는 방법에 대해 배웠습니다. 다음 장에서는 문서 검색을 담당하는 [문서 검색 전문 에이전트 (RAG Agent)](06_문서_검색_전문_에이전트__rag_agent_.md)에 대해 알아보겠습니다. 이 장에서 배운 라우팅 기법을 활용하여 다양한 API 요청을 관리하게 될 것입니다.
---
# Chapter 6: 문서 검색 전문 에이전트 (RAG Agent)

이전 장에서는 [백엔드 라우팅 (Backend Routing)](05_백엔드_라우팅__backend_routing_.md)에 대해 배웠습니다. 이번 장에서는 사용자의 질문에 대해 회사 내부 문서를 검색하고 답변을 생성하는 **문서 검색 전문 에이전트 (RAG Agent)**에 대해 알아보겠습니다.

## 문서 검색 에이전트의 필요성

회사 내부에는 중요한 정보가 담긴 수많은 문서들이 존재합니다. 그런데 만약 고객이 특정 정보를 문의했을 때, 직원이 일일이 문서를 뒤져야 한다면 얼마나 시간이 걸릴까요? 이러한 문제를 해결하려면 자동화된 문서 검색 시스템이 필요합니다. **문서 검색 전문 에이전트**는 사용자의 질문에 맞춰 해당 문서를 빠르게 검색하고, 요청된 정보를 제공합니다.

### 예시 시나리오

- 고객이 "이 제품의 안전 지침은 무엇인가요?"라고 질문합니다.
- 에이전트는 즉시 관련 문서를 검색하고 적합한 내용을 찾아 답변합니다. 

## 문서 검색 에이전트의 주요 개념

### 1. 질의 처리 (Query Processing)
   - 사용자가 입력한 질문을 이해하고 가장 적합한 정보를 검색합니다.

### 2. 문서 인덱싱 (Document Indexing)
   - 모든 문서를 검색 가능한 형태로 인덱싱하여 빠른 검색이 가능하도록 합니다.

### 3. 정보 검색 (Information Retrieval)
   - 사용자의 질의에 맞는 문서를 찾아내고, 필요한 정보를 추출해서 제공합니다.

## 문서 검색 에이전트 사용 방법

문서 검색 에이전트를 사용하여 간단한 검색을 수행하는 방법을 알아보겠습니다.

### 사용자의 질문에 답변 예제

```python
def 질문_답변(질문):
    # 요청한 질문에 맞는 문서를 검색하는 로직
    return {"답변": f"'{질문}'에 대한 답변입니다."}
```

- `질문_답변`: 입력된 질문에 따라 특정 문서를 검색하고 답변을 제공하는 함수입니다.
- 결과로 질문에 해당하는 답변을 반환합니다.

### 코드 구현 예제

```python
class 문서검색에이전트:
    def __init__(self, 문서들):
        self.문서들 = 문서들
    
    def 검색(self, 질문):
        # 간단한 키워드 기반 검색 예제
        for 문서 in self.문서들:
            if 질문 in 문서:
                return 문서
        return "관련 문서 없음"

에이전트 = 문서검색에이전트(["안전 지침", "사용 설명서"])
답변 = 에이전트.검색("안전")
print(답변)  # 출력: 안전 지침
```

- `문서검색에이전트`: 문서를 관리하고 검색을 수행하는 클래스입니다.
- `검색`: 문서에서 질문에 맞는 내용을 찾아 반환합니다.

## 내부 작동 방식

문서 검색 전문 에이전트가 어떻게 작동하는지 시퀀스 다이어그램으로 살펴보겠습니다.

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 에이전트 as 문서 검색 에이전트
    사용자->>에이전트: 질문 전송
    에이전트->>에이전트: 문서 검색
    에이전트->>사용자: 검색 결과 반환
```

1. 사용자가 에이전트에 질문을 보냅니다.
2. 에이전트는 내부 문서를 바탕으로 질문에 해당하는 정보를 검색합니다.
3. 검색 결과를 사용자에게 반환합니다.

### 추가 코드 설명

더 복잡한 검색 기능을 위해서는 NLP를 활용해 질문을 보다 정교하게 처리할 수 있습니다.

```python
import re

class 고급문서검색에이전트:
    def __init__(self, 문서들):
        self.문서들 = 문서들
    
    def 고급_검색(self, 질문):
        # 정규식을 이용한 고급 검색 예제
        패턴 = re.compile(r'\b{}\b'.format(re.escape(질문)))
        for 문서 in self.문서들:
            if 패턴.search(문서):
                return 문서
        return "관련 문서 없음"

고급에이전트 = 고급문서검색에이전트(["안전 지침", "사용 설명서"])
고급답변 = 고급에이전트.고급_검색("지침")
print(고급답변)  # 출력: 안전 지침
```

- `고급문서검색에이전트`: 자연어 처리 기능을 추가한 문서 검색 에이전트 클래스입니다.
- 정규식을 사용하여 질문에 대해 더 정확한 검색이 가능합니다.

## 결론

이번 장에서는 문서 검색 전문 에이전트를 통해 회사 내부 문서를 빠르게 검색하고 필요한 정보를 제공하는 방법을 배웠습니다. 이러한 자동화 시스템은 업무 효율성을 크게 향상시킬 수 있습니다. 다음 장에서는 회사의 지식 자산을 체계적으로 관리하는 [지식베이스 관리 (Knowledge Management)](07_지식베이스_관리__knowledge_management_.md)에 대해 알아보겠습니다.
---
# Chapter 7: 지식베이스 관리 (Knowledge Management)

이전 장에서는 [문서 검색 전문 에이전트 (RAG Agent)](06_문서_검색_전문_에이전트__rag_agent_.md)의 기능에 대해 알아보았습니다. 이번 장에서는 조직의 문서와 데이터를 체계적으로 관리하고 검색할 수 있는 방안을 제공하는 **지식베이스 관리 (Knowledge Management)**에 대해 다뤄보겠습니다.

## 지식베이스 관리의 필요성

조직은 다양한 문서와 데이터를 생성하고 사용합니다. 이러한 정보들은 시간이 지남에 따라 증가하고, 적절하게 관리되지 않으면 그 가치를 잃게 됩니다. 지식베이스 관리는 이러한 정보를 중앙에서 관리하고, 필요 시 빠르게 찾을 수 있도록 도와줍니다. 예를 들어, 고객 서비스 센터에서 자주 묻는 질문(FAQ)을 빠르게 검색할 수 있도록 관리하는 것입니다.

### 주요 개념 설명

1. **문서 저장 (Document Storage)**
   - 조직의 문서, 매뉴얼, 보고서 등을 중앙 저장소에 안전하게 보관합니다.

2. **문서 검색 (Document Retrieval)**
   - 특정 키워드나 주제에 따라 문서를 효과적으로 검색할 수 있습니다.

3. **임베딩 데이터 관리 (Embedding Data Management)**
   - 문서의 중요한 정보를 임베딩 데이터로 저장하여 검색과 활용을 돕습니다.

## 지식베이스 관리 사용 방법

### 문서 저장 예제

```python
def 문서_저장(문서_이름, 내용):
    # 문서를 저장하는 간단한 로직 예제
    return {"메시지": f"'{문서_이름}' 문서가 성공적으로 저장되었습니다."}
```

- `문서_저장`: 문서 이름과 내용을 입력받아 저장하는 함수입니다.
- 반환 값은 저장 성공을 알리는 메시지입니다.

### 문서 검색 예제

```python
def 문서_검색(키워드):
    # 키워드에 해당하는 문서를 검색하는 간단한 로직
    return {"결과": f"'{키워드}'와 관련된 문서를 찾았습니다."}
```

- `문서_검색`: 특정 키워드를 입력하여 관련 문서를 검색하는 함수입니다.
- 결과로 관련 문서를 찾았다는 메시지를 제공받습니다.

## 지식베이스 관리의 내부 구현

지식베이스 관리 시스템이 어떻게 작동하는지 시퀀스 다이어그램으로 설명합니다.

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 관리자 as 지식베이스 관리자 시스템
    사용자->>관리자: 문서 저장 요청
    관리자->>관리자: 문서 저장 절차 실행
    관리자->>사용자: 저장 완료 메시지
    사용자->>관리자: 문서 검색 요청
    관리자->>관리자: 키워드 기반 문서 검색
    관리자->>사용자: 검색 결과 반환
```

1. 사용자가 문서를 저장하려고 시스템에 요청을 보냅니다.
2. 시스템은 문서를 저장하고, 사용자에게 성공 메시지를 보냅니다.
3. 사용자가 문서 검색을 요청하면, 시스템은 키워드 기반으로 문서를 검색합니다.
4. 시스템은 검색 결과를 사용자에게 반환합니다.

### 내부 코드 예제

지식베이스 관리의 간단한 코드 예시입니다.

```python
class 지식베이스관리자:
    def __init__(self):
        self.문서들 = {}  # 문서 저장소

    def 문서_추가(self, 이름, 내용):
        # 문서를 추가하는 로직
        self.문서들[이름] = 내용
        return "문서 추가 완료"

    def 문서_검색(self, 키워드):
        # 키워드 기반 검색 로직
        결과 = [이름 for 이름 in self.문서들 if 키워드 in 이름]
        return 결과 or ["관련 문서 없음"]

관리자 = 지식베이스관리자()
관리자.문서_추가("안전 지침", "중요한 안전 정보")
검색_결과 = 관리자.문서_검색("안전")
print(검색_결과)  # 출력: ['안전 지침']
```

- `지식베이스관리자`: 문서 저장과 검색을 담당합니다.
- `문서_추가`: 새로운 문서를 저장소에 추가합니다.
- `문서_검색`: 특정 키워드를 기반으로 문서를 검색하여 반환합니다.

## 결론

이번 장에서는 지식베이스 관리 시스템을 통해 조직의 문서를 체계적으로 저장하고 검색하는 방법을 배웠습니다. 이로써 필요한 정보를 신속하게 찾고, 업무 효율성을 향상시킬 수 있습니다. 다음 장에서는 데이터를 분석하여 유의미한 정보를 도출하는 [데이터 분석 전문 에이전트 (Analytics Agent)](08_데이터_분석_전문_에이전트__analytics_agent_.md)에 대해 알아보겠습니다.

Relevant Code Snippets (Code itself remains unchanged):
No specific code snippets provided for this abstraction.

Instructions for the chapter (Generate content in Korean unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 8: 데이터 분석 전문 에이전트 (Analytics Agent)`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).

- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).

- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).

- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).

- Heavily use analogies and examples throughout (in Korean) to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).

- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-06-30 00:19:09,129 - INFO - Using OpenAI model: gpt-4o
2025-06-30 00:19:24,278 - INFO - RESPONSE: # Chapter 8: 데이터 분석 전문 에이전트 (Analytics Agent)

이전 장에서는 [지식베이스 관리 (Knowledge Management)](07_지식베이스_관리__knowledge_management_.md)를 통해 데이터를 체계적으로 관리하는 방법을 배웠습니다. 이번 장에서는 데이터를 분석하여 사용자에게 유의미한 인사이트를 제공하는 **데이터 분석 전문 에이전트 (Analytics Agent)**를 살펴보겠습니다.

## 데이터 분석 전문 에이전트의 필요성

왜 데이터 분석 전문 에이전트가 필요할까요? 현대의 비즈니스 환경에서는 방대한 양의 데이터가 생성되고 있으며, 이를 분석하여 의사 결정에 활용하는 것이 매우 중요합니다. 예를 들어, 특정 제품의 판매 추이를 분석함으로써 시장의 변화를 예측하고 전략을 수립할 수 있습니다. 데이터 분석 전문 에이전트는 이러한 데이터를 효과적으로 분석하여 필요한 정보를 제공합니다.

### 예시 시나리오

하나의 시나리오로, "지난 6개월 동안 가장 많이 판매된 제품은 무엇인가요?"라는 질문이 있을 수 있습니다. 데이터 분석 전문 에이전트는 데이터베이스에서 관련 데이터를 검색하고 분석하여 이러한 질문에 대한 답변을 제공합니다.

## 데이터 분석 전문 에이전트의 주요 개념

1. **질의 처리 (Query Processing)**
   - 사용자의 질문을 이해하고 데이터베이스에서 필요한 데이터를 추출합니다.

2. **데이터 분석 (Data Analysis)**
   - 추출된 데이터를 다양한 기법을 사용하여 분석하고, 의미 있는 결과를 도출합니다.

3. **결과 제공 (Result Presentation)**
   - 분석된 결과를 사용자에게 이해하기 쉽게 제공합니다.

## 데이터 분석 전문 에이전트 사용 방법

이제 간단한 코드 예제를 통해 데이터 분석 전문 에이전트를 사용하는 방법을 살펴보겠습니다.

### 사용자의 질문에 답변 예제

먼저, 사용자가 질문을 던지면 데이터베이스에서 필요한 데이터를 추출하는 예제입니다.

```python
def 데이터_검색(질문):
    # 질의에 따라 데이터베이스 검색하는 로직
    return {"결과": f"'{질문}'에 관련된 데이터를 찾았습니다."}
```

- `데이터_검색`: 사용자가 입력한 질문을 데이터베이스에서 검색하여 필요한 데이터를 반환하는 함수입니다.

### 분석 결과 제공 예제

데이터를 분석하고, 그 결과를 사용자에게 제공하는 방식을 살펴봅시다.

```python
def 결과_제공(데이터):
    # 데이터 분석 결과를 반환하는 간단한 로직
    return {"분석 결과": f"분석된 결과입니다: {데이터}"}
```

- `결과_제공`: 분석된 데이터를 기반으로 사용자에게 결과를 제공하는 함수입니다.

## 데이터 분석 전문 에이전트의 내부 작동 방식

이제 데이터 분석 전문 에이전트가 어떻게 작동하는지 한눈에 볼 수 있도록 시퀀스 다이어그램을 통해 설명해 보겠습니다.

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 분석에이전트 as 데이터 분석 에이전트
    사용자->>분석에이전트: 질문 전송
    분석에이전트->>분석에이전트: 데이터 검색 및 분석
    분석에이전트->>사용자: 분석 결과 제공
```

1. 사용자는 데이터 분석 전문 에이전트에 질문을 보냅니다.
2. 에이전트는 관련 데이터를 데이터베이스에서 검색하고 분석을 수행합니다.
3. 분석된 결과는 사용자에게 제공됩니다.

### 내부 코드 설명

데이터를 검색하고 분석하는 클래스의 간단한 예제를 살펴봅시다.

```python
class 데이터분석에이전트:
    def __init__(self, 데이터베이스):
        self.데이터베이스 = 데이터베이스
        
    def 분석(self, 질문):
        # 데이터를 검색하고 분석하는 기본 로직
        데이터 = self.데이터베이스.get(질문, "데이터 없음")
        return f"분석된 데이터: {데이터}"

데이터베이스 = {
    "지난 6개월 판매": "판매 데이터",
    "고객 리뷰": "리뷰 데이터"
}

에이전트 = 데이터분석에이전트(데이터베이스)
결과 = 에이전트.분석("지난 6개월 판매")
print(결과)  # 출력: 분석된 데이터: 판매 데이터
```

- `데이터분석에이전트`: 데이터베이스로부터 데이터를 검색하여 분석하는 클래스를 정의합니다.
- `분석`: 특정 질문에 대한 데이터를 검색한 후 분석된 결과를 반환합니다.

## 결론

이번 장에서는 데이터 분석 전문 에이전트를 활용하여 데이터베이스에서 데이터를 검색하고, 이를 분석하여 유의미한 결과를 사용자에게 제공하는 방법을 배웠습니다. 데이터 분석은 조직의 중요한 의사 결정에 매우 유용한 정보 자원이 될 수 있습니다. 다음 장에서는 이러한 시스템의 개발 및 배포를 효과적으로 관리할 수 있는 [MLOps 관리 (MLOps Management)](09_mlops_관리__mlops_management_.md)에 대해 알아보겠습니다.
2025-06-30 00:19:24,297 - INFO - PROMPT: 
IMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.

Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `SKN10-FINAL-1Team` about the concept: "MLOps 관리 (MLOps Management)". This is Chapter 9.

Concept Details (Note: Provided in Korean):
- Name: MLOps 관리 (MLOps Management)
- Description:
분석 결과와 모델 아티팩트를 관리하고 추적하는 시스템입니다. (System that manages and tracks analytics results and model artifacts.)

Complete Tutorial Structure (Note: Chapter names might be in Korean):
1. [AI 에이전트 총괄 시스템 (LangGraph Supervisor)](01_ai_에이전트_총괄_시스템__langgraph_supervisor_.md)
2. [FastAPI 서버](02_fastapi_서버.md)
3. [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)
4. [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)
5. [백엔드 라우팅 (Backend Routing)](05_백엔드_라우팅__backend_routing_.md)
6. [문서 검색 전문 에이전트 (RAG Agent)](06_문서_검색_전문_에이전트__rag_agent_.md)
7. [지식베이스 관리 (Knowledge Management)](07_지식베이스_관리__knowledge_management_.md)
8. [데이터 분석 전문 에이전트 (Analytics Agent)](08_데이터_분석_전문_에이전트__analytics_agent_.md)
9. [MLOps 관리 (MLOps Management)](09_mlops_관리__mlops_management_.md)
10. [환경 설정 및 배포 (Environment Setup and Deployment)](10_환경_설정_및_배포__environment_setup_and_deployment_.md)

Context from previous chapters (Note: This summary might be in Korean):
# Chapter 1: AI 에이전트 총괄 시스템 (LangGraph Supervisor)

## 소개

우리가 상상하는 미래의 세계에서는 다양한 AI 에이전트가 우리의 일상 속에서 많은 역할을 하게 될 것입니다. 이 장에서는 사용자의 자연어 요청을 신속하고 정확하게 분석하여 적합한 전문 에이전트에게 작업을 분배하는 시스템인 **AI 에이전트 총괄 시스템 (LangGraph Supervisor)**를 소개합니다.

## 왜 AI 에이전트 총괄 시스템이 필요한가요?

### 문제에 대한 개요

어느 날, 당신은 다수의 AI 전문 에이전트를 관리하는 프로젝트의 관리자입니다. 고객이 다양한 요구를 AI에게 요청하지만 그 요청마다 다른 전문 에이전트로 보내야 합니다. 예를 들어, 문서 검색이 필요한 경우에는 '문서 검색 전문 에이전트', 데이터 분석이 필요한 경우에는 '데이터 분석 전문 에이전트'가 필요합니다.

AI 에이전트 총괄 시스템은 이러한 문제를 해결하기 위해 만들어졌습니다. 사용자가 보내는 자연어 요청을 효과적으로 해석하고, 적합한 에이전트로 작업을 분배합니다.

### 핵심 개념 설명

1. **자연어 처리 (Natural Language Processing)**: 사용자의 요청을 분석하기 위해 사용됩니다. 텍스트를 이해하고 그 의미를 파악합니다.

2. **에이전트 라우팅**: 각 에이전트는 서로 다른 전문 분야를 가지고 있으며, 요청에 가장 적합한 에이전트에게 작업을 보내기 위한 과정입니다.

## AI 에이전트 총괄 시스템 사용 방법

이 시스템을 이해하는 것을 용이하게 하기 위해, 우리는 간단한 예제를 통해 따라가 볼 것입니다.

### 간단한 구현 예제

```python
def 언어_분석(요청):
    # 요청의 내용을 분석하여 필요한 에이전트를 결정함
    if "데이터 분석" in 요청:
        return "데이터 분석 전문 에이전트"
    elif "문서 검색" in 요청:
        return "문서 검색 전문 에이전트"
    else:
        return "일반 에이전트"

결정된_에이전트 = 언어_분석("문서 검색을 원해요")
print(결정된_에이전트)  # 출력: 문서 검색 전문 에이전트
```

위의 코드는 사용자의 요청을 간단히 분석하고, 해당 요청을 가장 잘 수행할 에이전트를 선정하는 프로세스를 보여줍니다.

### 내부 구현

시스템이 어떻게 내부적으로 작동하는지 더 잘 이해하기 위해, 몇 가지 과정을 단계별로 나누어 설명하겠습니다.

#### 시스템 작동 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 시스템 as LangGraph Supervisor
    participant 에이전트1 as 문서 검색 전문 에이전트
    participant 에이전트2 as 데이터 분석 전문 에이전트
    사용자->>시스템: 자연어 요청 전송
    시스템->>사용자: 요청 분석
    시스템->>에이전트1: 적합한 에이전트로 요청 전달
    에이전트1->>시스템: 작업 수행 후 결과 반환
    시스템->>사용자: 결과 전송
```

1. 사용자는 자연어 요청을 시스템에 보냅니다.
2. 시스템은 요청을 분석하여 필요한 에이전트를 결정합니다.
3. 적합한 에이전트에게 요청을 보냅니다.
4. 에이전트는 작업을 수행 후 시스템에 결과를 반환합니다.
5. 시스템은 결과를 사용자에게 전달합니다.

#### 코드 예제

이제, 시스템 내부에서 언어 분석과 라우팅이 어떻게 이루어지는지 코드 레벨에서 예를 들어 보겠습니다.

```python
class LangGraphSupervisor:
    def __init__(self):
        self.agents = {
            "문서 검색": "문서 검색 전문 에이전트",
            "데이터 분석": "데이터 분석 전문 에이전트"
        }

    def 분석후_라우팅(self, 요청):
        for 키워드, 에이전트 in self.agents.items():
            if 키워드 in 요청:
                return 에이전트
        return "일반 에이전트"

supervisor = LangGraphSupervisor()
에이전트 = supervisor.분석후_라우팅("데이터 분석을 요청합니다")
print(에이전트)  # 출력: 데이터 분석 전문 에이전트
```

이 코드에서는 요청을 처리 및 분배하는 `LangGraphSupervisor` 클래스의 구조를 보여줍니다.

## 결론

이 장에서는 AI 에이전트 총괄 시스템의 핵심 개념과 사용 방법을 배웠습니다. 이 시스템은 사용자의 자연어 요청을 분석하고 적절한 에이전트로 작업을 분배하는 것을 목표로 합니다. 다음 장에서는 이 시스템을 구동할 서버 [FastAPI 서버](02_fastapi_서버.md)에 대해 알아봅니다.
---

# Chapter 2: FastAPI 서버

이전 장에서는 [AI 에이전트 총괄 시스템 (LangGraph Supervisor)](01_ai_에이전트_총괄_시스템__langgraph_supervisor_.md)에 대해 알아보았습니다. 이번 장에서는 이러한 시스템이 원활하게 작동하기 위해 필요한 서버 기술인 **FastAPI 서버**에 대해 설명하겠습니다.

FastAPI 서버는 실시간 AI 통신을 처리하며, 사용자와 AI 시스템 간의 데이터 교환을 담당하는 중요한 역할을 합니다. 이 장에서는 FastAPI 서버의 기본적인 개념과 구현 방법을 이해하고, 실제로 간단한 서버를 만들어 보는 것을 목표로 합니다.

## FastAPI 서버의 동기

FastAPI 서버는 왜 필요한 걸까요? FastAPI는 Python 기반의 웹 프레임워크로, 빠르고 효율적인 API를 구축하는 데 사용됩니다. 이것은 특히 AI 시스템과의 빠른 데이터 교환에 최적화되어 있습니다. 예를 들어, 사용자가 챗봇에게 질문을 하거나 AI 분석 결과를 요청하는 시나리오에서 실시간으로 응답을 받아야 합니다. FastAPI는 이러한 요구 사항을 충족시킬 수 있는 솔루션입니다.

### 주요 개념 설명

#### 1. 경량 웹 프레임워크

- FastAPI는 경량 프레임워크로, 쉽고 빠르게 서버를 구축할 수 있습니다.
- 비동기식 처리(Asynchronous Handling)를 통해 높은 처리 성능을 제공합니다.

#### 2. 자동 문서화

- FastAPI는 API 엔드포인트에 대한 자동 문서화 기능을 제공합니다.
- 이는 개발자가 API를 쉽게 이해하고 사용할 수 있도록 돕습니다.

## FastAPI 서버 사용 방법

이제 FastAPI를 사용하여 간단한 서버를 구축하는 방법을 따라해보겠습니다.

### FastAPI 설치

우선 FastAPI를 설치해야 합니다. Python 패키지 매니저인 pip를 통해 설치할 수 있습니다.

```bash
pip install fastapi
pip install uvicorn
```

- `fastapi`: FastAPI 프레임워크 설치
- `uvicorn`: FastAPI 애플리케이션을 실행하기 위한 ASGI 서버

### 간단한 FastAPI 서버 구현

아래는 FastAPI를 사용하여 간단한 서버를 구축하는 코드입니다.

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def 읽기_루트():
    return {"메시지": "Hello World!"}
```

- `FastAPI()`: 새로운 FastAPI 애플리케이션 인스턴스를 생성합니다.
- `@app.get("/")`: 루트 URL에서 GET 요청을 처리합니다.
- `읽기_루트()`: 루트 URL에 접근할 때 반환할 메시지를 정의합니다.

### 서버 실행

FastAPI 애플리케이션을 실행하려면 Uvicorn을 사용합니다.

```bash
uvicorn main:app --reload
```

- `main:app`: main.py 파일의 `app` 객체를 실행합니다.
- `--reload`: 코드 변경 시 서버를 자동으로 다시 시작합니다.

## FastAPI 서버의 내부 구현

FastAPI 서버가 어떻게 내부적으로 작동하는지 알아보겠습니다. FastAPI는 비동기 처리 방식으로 요청을 처리합니다. 아래의 시퀀스 다이어그램은 간단한 HTTP 요청 프로세스를 보여줍니다.

```mermaid
sequenceDiagram
    participant 고객 as 고객
    participant 서버 as FastAPI 서버
    고객->>서버: HTTP 요청 전송
    서버->>고객: 응답 전달
```

1. 고객이 서버로 HTTP 요청을 보냅니다.
2. FastAPI 서버는 요청을 처리하고 적절한 응답을 생성합니다.
3. 응답이 고객에게 전달됩니다.

이제 FastAPI의 코드 구조를 통해 더 깊이 들어가 보겠습니다.

```python
from fastapi import FastAPI, HTTPException

app = FastAPI()

@app.get("/items/{item_id}")
def 읽기_아이템(item_id: int):
    # 데이터베이스에서 항목 찾기 (예시를 위한 간단한 로직)
    if item_id not in [1, 2, 3]:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"item_id": item_id, "값": "여기에 데이터가 들어갑니다"}
```

- `HTTPException`: FastAPI에서 에러 응답을 생성할 때 사용합니다.
- `@app.get("/items/{item_id}")`: 경로 매개변수 `item_id`를 사용하여 특정 아이템에 대한 정보를 요청할 수 있습니다.

## 결론

이번 장에서는 FastAPI 서버의 기본 개념과 이를 사용하여 간단한 웹 애플리케이션을 구축하는 방법을 배웠습니다. FastAPI는 실시간으로 AI 및 사용자의 데이터 교환을 처리하는 데 최적화되어 있습니다. 이제 다음 장에서는 [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)로 이동해 보겠습니다. 이는 사용자의 계정 및 인증 관리를 담당하는 중요한 모듈입니다.
---
# Chapter 3: 계정 관리 모듈 (Accounts Module)

이전 장에서는 [FastAPI 서버](02_fastapi_서버.md)에 대해 알아보았습니다. 이번 장에서는 시스템 사용자와 조직의 정보를 관리하고 인증 처리 기능을 제공하는 중요한 모듈, **계정 관리 모듈 (Accounts Module)**에 대해 설명하겠습니다.

## 계정 관리 모듈의 필요성

현대의 많은 웹 애플리케이션들은 개별 사용자에게 개인화된 경험을 제공하기 위해 사용자 정보와 인증 기능을 필요로 합니다. 예를 들어, 사용자가 앱에 로그인하여 자신의 정보를 확인하고 개인화된 서비스를 받으려면 적절한 계정 관리 시스템이 필수적입니다. 본 모듈은 이러한 요구를 만족시키기 위해 설계되었습니다.

### 주요 개념 설명

#### 1. 사용자 관리

- **사용자 정보**: 사용자의 이름, 이메일, 가입 날짜 등의 정보를 저장합니다.
- **비밀번호 관리**: 사용자 비밀번호를 안전하게 저장하고 변경하는 기능을 포함합니다.

#### 2. 조직 관리

- **조직 정보**: 조직 이름, 구성원 목록을 관리합니다.
- 조직 내 사용자의 역할을 부여하는 기능도 포함됩니다.

#### 3. 인증 처리

- 사용자의 신원을 확인하기 위해 로그인 기능과 토큰 기반 인증을 제공합니다.

## 계정 관리 모듈 사용 방법

이제 계정 관리 모듈을 사용하여 사용자를 생성하고 인증하는 방법을 알아보겠습니다.

### 새로운 사용자 생성

```python
def 사용자_생성(사용자_이름, 비밀번호):
    # 이곳에서 사용자 정보를 데이터베이스에 저장
    return {"메시지": f"{사용자_이름}가 성공적으로 생성되었습니다."}
```

- `사용자_생성`: 사용자 이름과 비밀번호를 사용해 새로운 사용자를 생성하는 함수입니다.
- 출력 메시지를 통해 사용자가 성공적으로 생성되었음을 볼 수 있습니다.

### 로그인 처리

```python
def 로그인(사용자_이름, 비밀번호):
    # 사용자 이름과 비밀번호가 맞는지 확인
    if 올바른_비밀번호(사용자_이름, 비밀번호):
        return {"메시지": "인증 성공"}
    else:
        return {"메시지": "인증 실패"}
```

- `로그인`: 사용자의 이름과 비밀번호를 확인하여 인증 처리 결과를 제공합니다.
- 비밀번호가 맞으면 "인증 성공" 메시지를, 그렇지 않으면 "인증 실패" 메시지를 반환합니다.

## 계정 관리 모듈의 내부 구현

계정 관리 모듈이 실제로 어떻게 작동하는지 이해하기 위해 대략적인 처리 과정을 살펴봅시다.

### 인증 처리 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 서버 as 계정 관리 모듈
    사용자->>서버: 로그인 요청 (사용자 이름, 비밀번호)
    서버->>서버: 비밀번호 확인
    alt 비밀번호가 맞을 때
        서버->>사용자: 인증 성공
    else 비밀번호가 틀릴 때
        서버->>사용자: 인증 실패
    end
```

1. 사용자가 계정 관리 모듈에 로그인 요청을 보냅니다.
2. 모듈은 비밀번호를 확인합니다.
3. 비밀번호가 맞으면 "인증 성공" 메시지를, 틀리면 "인증 실패" 메시지를 반환합니다.

### 내부 코드 구현

기본적인 계정 관리 시스템에는 사용자 정보를 저장하고 인증을 처리하는 클래스 또는 데이터베이스 연결이 필요합니다. 아래는 이러한 기능을 간단히 구현한 예입니다.

```python
class 계정관리:
    def __init__(self):
        self.사용자들 = {}

    def 사용자_추가(self, 이름, 비밀번호):
        self.사용자들[이름] = 비밀번호

    def 로그인_처리(self, 이름, 비밀번호):
        # 사용자 정보 및 비밀번호 일치 여부 확인
        if 이름 in self.사용자들 and self.사용자들[이름] == 비밀번호:
            return "인증 성공"
        return "인증 실패"

계정 = 계정관리()
계정.사용자_추가("홍길동", "비밀번호123")
인증_결과 = 계정.로그인_처리("홍길동", "비밀번호123")
print(인증_결과)  # 출력: 인증 성공
```

- `계정관리`: 사용자 정보를 저장하고 인증을 처리하는 클래스입니다.
- `로그인_처리`: 사용자 이름과 비밀번호가 올바른지 확인합니다.

## 결론

이번 장에서는 계정 관리 모듈을 이용해 사용자를 생성하고 인증하는 방법, 그리고 그 내부 구현을 통해 이 모듈이 어떻게 작동하는지 배웠습니다. 다음 장에서는 사용자와 AI 에이전트 간의 상호작용을 관리하는 [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)에 대해 알아보겠습니다.
---
# Chapter 4: 챗봇 세션 관리 (Chat Session Management)

이전 장에서는 [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)에 대해 알아보았습니다. 이번 장에서는 사용자의 대화 세션과 메시지를 효과적으로 관리하고 저장하는 **챗봇 세션 관리 (Chat Session Management)**에 대해 살펴보겠습니다.

## 챗봇 세션 관리의 필요성

챗봇은 다양한 사용자와 상호작용하며 많은 메시지를 처리합니다. 이때, 각 사용자와의 대화 세션을 올바르게 관리해야 이전 대화 기록을 사용하여 대화를 이어 나가거나 정보를 추출할 수 있습니다. 예를 들어, 사용자가 "얼마 전 주문했던 상품이 뭐였죠?"라고 묻는 경우, 이전 대화 세션을 통해 지난 주문 내역을 찾아 제공해야 합니다. 이렇게 하려면 세션 관리가 필수적입니다.

## 챗봇 세션 관리의 주요 개념

1. **세션 저장 (Session Storage)**
   - 각 사용자의 대화 세션을 저장합니다. 이를 통해 필요한 정보를 빠르게 조회할 수 있습니다.

2. **세션 유지 (Session Persistence)**
   - 사용자가 언제든 대화를 이어갈 수 있도록 이전 대화를 유지합니다. 사용자가 다시 접속했을 때, 이전 대화 맥락을 기반으로 서비스를 제공할 수 있습니다.

3. **세션 종료 (Session Termination)**
   - 일정 시간이 지나면 대화 세션을 종료하여 리소스를 효율적으로 관리합니다.

## 챗봇 세션 관리 사용 방법

### 사용자의 세션 저장 예제

아래는 사용자의 대화 세션을 저장하는 간단한 코드 예제입니다.

```python
def 세션_저장(사용자_id, 메시지):
    # 이곳에 세션 데이터를 저장하는 로직을 구현
    return {"메시지": f"{사용자_id}의 세션이 성공적으로 저장되었습니다."}
```

- `세션_저장`: 사용자 ID와 메시지를 받아 세션을 저장하는 함수입니다.
- 반환된 메시지를 통해 성공적으로 세션이 저장되었음을 알 수 있습니다.

### 세션 조회 구현

```python
def 세션_조회(사용자_id):
    # 저장된 세션 데이터를 가져오는 로직 구현
    return {"메시지": f"{사용자_id}의 세션 정보입니다."}
```

- `세션_조회`: 사용자 ID를 입력하면 해당 사용자의 저장된 세션 내용을 반환하는 함수입니다.

## 챗봇 세션 관리의 내부 구현

챗봇 세션 관리가 어떻게 이루어지는지 이해하기 위해 과정을 살펴보겠습니다.

### 세션 관리 처리 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 서버 as 챗봇 세션 관리
    사용자->>서버: 메시지 전송
    서버->>서버: 메시지 저장
    서버->>사용자: 세션 저장 완료 메시지
    사용자->>서버: 세션 조회 요청
    서버->>사용자: 세션 데이터 반환
```

1. 사용자가 메시지를 챗봇에 보냅니다.
2. 서버는 메시지를 세션 데이터베이스에 저장합니다.
3. 저장 완료 후 사용자는 저장 완료 확인 메시지를 받습니다.
4. 사용자가 이전 세션 조회를 요청하면, 서버는 저장된 데이터를 반환합니다.

### 코드 구현 예제

간단한 세션 관리 시스템 코드 예제입니다.

```python
class 세션관리:
    def __init__(self):
        self.세션들 = {}  # 세션 저장을 위한 딕셔너리
    
    def 저장(self, 사용자_id, 메시지):
        # 세션 저장 로직
        if 사용자_id not in self.세션들:
            self.세션들[사용자_id] = []
        self.세션들[사용자_id].append(메시지)
        return "세션 저장 완료"
    
    def 조회(self, 사용자_id):
        # 세션 조회 로직
        return self.세션들.get(사용자_id, "세션 없음")

관리자 = 세션관리()
관리자.저장("사용자1", "안녕하세요!")
결과 = 관리자.조회("사용자1")
print(결과)  # 출력: ['안녕하세요!']
```

- `세션관리`: 사용자 세션을 관리하는 클래스입니다.
- `저장`: 사용자 메시지를 세션에 저장합니다.
- `조회`: 저장된 세션을 반환합니다.

## 결론

이번 장에서는 챗봇 세션 관리를 통해 사용자 대화 세션을 어떻게 저장, 유지, 조회할 수 있는지 배웠습니다. 올바른 세션 관리가 가능해야 사용자에게 더 나은 챗봇 경험을 제공할 수 있습니다. 다음 장에서는 백엔드 라우팅을 효과적으로 활용하는 방법에 대해 알아보겠습니다: [백엔드 라우팅 (Backend Routing)](05_백엔드_라우팅__backend_routing_.md).
---
# Chapter 5: 백엔드 라우팅 (Backend Routing)

이전 장에서는 [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)에 대해 배웠습니다. 이번 장에서는 Django를 사용하여 백엔드 API 경로를 설정하는 방법, 즉 **백엔드 라우팅 (Backend Routing)**에 대해 알아보겠습니다.

## 백엔드 라우팅의 필요성

백엔드 라우팅은 웹 애플리케이션이 클라이언트로부터 요청을 받고 적절한 응답을 할 수 있도록 경로를 설정하는 것입니다. 예를 들어, 사용자가 웹사이트에서 상품 목록을 볼 때, 클라이언트에서의 요청이 백엔드에서 정확한 정보를 전달받기 위해 필요한 모든 것은 라우팅입니다. 이는 특히 여러 페이지가 있는 복잡한 웹 애플리케이션에서 필수적입니다.

### 예시: 상품 목록 보기

- 사용자가 웹사이트의 `/products` 페이지로 들어가면, 백엔드는 상품 목록 데이터를 클라이언트에 제공합니다.
- 적절한 라우팅이 없다면, 요청된 페이지를 찾을 수 없다는 오류 메시지를 보게 될 것입니다.

## 주요 개념

### 1. URL 경로

각각의 URL은 특정한 데이터나 페이지로의 경로입니다. Django에서는 URL 패턴을 설정하여 어떤 URL이 어떤 함수나 클래스로 처리될지를 결정합니다.

### 2. 뷰(View)

각 요청에 대해 응답을 생성하는 역할을 합니다. 예를 들어, 상품 목록 요청을 받아 그것에 대한 HTML 페이지나 JSON 데이터를 반환합니다.

## 백엔드 라우팅 사용 방법

이제 Django에서 간단한 라우팅을 설정하는 방법을 알아봅시다.

### URL 패턴 설정 예제

`urls.py` 파일을 활용하여 URL 패턴을 설정합니다.

```python
# urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('products/', views.상품목록보기, name='상품목록'),
]
```

- `path()`: URL 경로를 설정하는 함수입니다. 첫 번째 인자는 경로, 두 번째 인자는 처리할 뷰 함수, 세 번째는 경로 이름입니다.

### 뷰 함수 구현

라우팅 된 URL을 처리할 뷰 함수를 구현해 봅시다.

```python
# views.py
from django.http import HttpResponse

def 상품목록보기(request):
    # 예시로 간단한 응답을 보냄
    return HttpResponse("상품 목록 페이지입니다.")
```

- `HttpResponse`: HTTP 응답을 생성하는 클래스입니다. 여기에 문자열을 넣어 간단히 출력할 수 있습니다.

## 백엔드 라우팅의 내부 구현

백엔드 라우팅이 내부적으로 어떻게 작동하는지 이해하기 위해 시퀀스 다이어그램을 살펴보겠습니다.

### 프로세스 흐름

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 서버 as Django 서버
    사용자->>서버: /products 요청
    서버->>서버: 경로 확인 (urls.py)
    서버->>서버: 뷰 함수 실행 (views.py)
    서버->>사용자: 상품 목록 응답
```

1. 사용자가 `/products` URL로 요청을 보냅니다.
2. `urls.py`에서 해당 경로에 맞는 패턴을 찾습니다.
3. 연결된 뷰 함수가 실행되어 응답을 생성합니다.
4. 생성된 응답이 사용자에게 전달됩니다.

### 추가 코드 예시

뷰에서 데이터베이스와 연동하여 더 유용한 정보 제공을 위한 예제 코드입니다.

```python
# views.py
from django.http import JsonResponse
from .models import Product

def 상품목록보기(request):
    # 모든 상품의 정보를 가져옴
    products = Product.objects.all().values()
    return JsonResponse(list(products), safe=False)
```

- `JsonResponse`: 데이터를 JSON 형식으로 응답하는 클래스입니다.
- `Product.objects.all()`: 모든 상품 정보를 데이터베이스에서 조회합니다.

## 결론

이번 장에서는 Django를 활용한 백엔드 라우팅의 기본적인 개념과 이를 사용하여 웹 애플리케이션에서 URL을 처리하고 응답하는 방법에 대해 배웠습니다. 다음 장에서는 문서 검색을 담당하는 [문서 검색 전문 에이전트 (RAG Agent)](06_문서_검색_전문_에이전트__rag_agent_.md)에 대해 알아보겠습니다. 이 장에서 배운 라우팅 기법을 활용하여 다양한 API 요청을 관리하게 될 것입니다.
---
# Chapter 6: 문서 검색 전문 에이전트 (RAG Agent)

이전 장에서는 [백엔드 라우팅 (Backend Routing)](05_백엔드_라우팅__backend_routing_.md)에 대해 배웠습니다. 이번 장에서는 사용자의 질문에 대해 회사 내부 문서를 검색하고 답변을 생성하는 **문서 검색 전문 에이전트 (RAG Agent)**에 대해 알아보겠습니다.

## 문서 검색 에이전트의 필요성

회사 내부에는 중요한 정보가 담긴 수많은 문서들이 존재합니다. 그런데 만약 고객이 특정 정보를 문의했을 때, 직원이 일일이 문서를 뒤져야 한다면 얼마나 시간이 걸릴까요? 이러한 문제를 해결하려면 자동화된 문서 검색 시스템이 필요합니다. **문서 검색 전문 에이전트**는 사용자의 질문에 맞춰 해당 문서를 빠르게 검색하고, 요청된 정보를 제공합니다.

### 예시 시나리오

- 고객이 "이 제품의 안전 지침은 무엇인가요?"라고 질문합니다.
- 에이전트는 즉시 관련 문서를 검색하고 적합한 내용을 찾아 답변합니다. 

## 문서 검색 에이전트의 주요 개념

### 1. 질의 처리 (Query Processing)
   - 사용자가 입력한 질문을 이해하고 가장 적합한 정보를 검색합니다.

### 2. 문서 인덱싱 (Document Indexing)
   - 모든 문서를 검색 가능한 형태로 인덱싱하여 빠른 검색이 가능하도록 합니다.

### 3. 정보 검색 (Information Retrieval)
   - 사용자의 질의에 맞는 문서를 찾아내고, 필요한 정보를 추출해서 제공합니다.

## 문서 검색 에이전트 사용 방법

문서 검색 에이전트를 사용하여 간단한 검색을 수행하는 방법을 알아보겠습니다.

### 사용자의 질문에 답변 예제

```python
def 질문_답변(질문):
    # 요청한 질문에 맞는 문서를 검색하는 로직
    return {"답변": f"'{질문}'에 대한 답변입니다."}
```

- `질문_답변`: 입력된 질문에 따라 특정 문서를 검색하고 답변을 제공하는 함수입니다.
- 결과로 질문에 해당하는 답변을 반환합니다.

### 코드 구현 예제

```python
class 문서검색에이전트:
    def __init__(self, 문서들):
        self.문서들 = 문서들
    
    def 검색(self, 질문):
        # 간단한 키워드 기반 검색 예제
        for 문서 in self.문서들:
            if 질문 in 문서:
                return 문서
        return "관련 문서 없음"

에이전트 = 문서검색에이전트(["안전 지침", "사용 설명서"])
답변 = 에이전트.검색("안전")
print(답변)  # 출력: 안전 지침
```

- `문서검색에이전트`: 문서를 관리하고 검색을 수행하는 클래스입니다.
- `검색`: 문서에서 질문에 맞는 내용을 찾아 반환합니다.

## 내부 작동 방식

문서 검색 전문 에이전트가 어떻게 작동하는지 시퀀스 다이어그램으로 살펴보겠습니다.

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 에이전트 as 문서 검색 에이전트
    사용자->>에이전트: 질문 전송
    에이전트->>에이전트: 문서 검색
    에이전트->>사용자: 검색 결과 반환
```

1. 사용자가 에이전트에 질문을 보냅니다.
2. 에이전트는 내부 문서를 바탕으로 질문에 해당하는 정보를 검색합니다.
3. 검색 결과를 사용자에게 반환합니다.

### 추가 코드 설명

더 복잡한 검색 기능을 위해서는 NLP를 활용해 질문을 보다 정교하게 처리할 수 있습니다.

```python
import re

class 고급문서검색에이전트:
    def __init__(self, 문서들):
        self.문서들 = 문서들
    
    def 고급_검색(self, 질문):
        # 정규식을 이용한 고급 검색 예제
        패턴 = re.compile(r'\b{}\b'.format(re.escape(질문)))
        for 문서 in self.문서들:
            if 패턴.search(문서):
                return 문서
        return "관련 문서 없음"

고급에이전트 = 고급문서검색에이전트(["안전 지침", "사용 설명서"])
고급답변 = 고급에이전트.고급_검색("지침")
print(고급답변)  # 출력: 안전 지침
```

- `고급문서검색에이전트`: 자연어 처리 기능을 추가한 문서 검색 에이전트 클래스입니다.
- 정규식을 사용하여 질문에 대해 더 정확한 검색이 가능합니다.

## 결론

이번 장에서는 문서 검색 전문 에이전트를 통해 회사 내부 문서를 빠르게 검색하고 필요한 정보를 제공하는 방법을 배웠습니다. 이러한 자동화 시스템은 업무 효율성을 크게 향상시킬 수 있습니다. 다음 장에서는 회사의 지식 자산을 체계적으로 관리하는 [지식베이스 관리 (Knowledge Management)](07_지식베이스_관리__knowledge_management_.md)에 대해 알아보겠습니다.
---
# Chapter 7: 지식베이스 관리 (Knowledge Management)

이전 장에서는 [문서 검색 전문 에이전트 (RAG Agent)](06_문서_검색_전문_에이전트__rag_agent_.md)의 기능에 대해 알아보았습니다. 이번 장에서는 조직의 문서와 데이터를 체계적으로 관리하고 검색할 수 있는 방안을 제공하는 **지식베이스 관리 (Knowledge Management)**에 대해 다뤄보겠습니다.

## 지식베이스 관리의 필요성

조직은 다양한 문서와 데이터를 생성하고 사용합니다. 이러한 정보들은 시간이 지남에 따라 증가하고, 적절하게 관리되지 않으면 그 가치를 잃게 됩니다. 지식베이스 관리는 이러한 정보를 중앙에서 관리하고, 필요 시 빠르게 찾을 수 있도록 도와줍니다. 예를 들어, 고객 서비스 센터에서 자주 묻는 질문(FAQ)을 빠르게 검색할 수 있도록 관리하는 것입니다.

### 주요 개념 설명

1. **문서 저장 (Document Storage)**
   - 조직의 문서, 매뉴얼, 보고서 등을 중앙 저장소에 안전하게 보관합니다.

2. **문서 검색 (Document Retrieval)**
   - 특정 키워드나 주제에 따라 문서를 효과적으로 검색할 수 있습니다.

3. **임베딩 데이터 관리 (Embedding Data Management)**
   - 문서의 중요한 정보를 임베딩 데이터로 저장하여 검색과 활용을 돕습니다.

## 지식베이스 관리 사용 방법

### 문서 저장 예제

```python
def 문서_저장(문서_이름, 내용):
    # 문서를 저장하는 간단한 로직 예제
    return {"메시지": f"'{문서_이름}' 문서가 성공적으로 저장되었습니다."}
```

- `문서_저장`: 문서 이름과 내용을 입력받아 저장하는 함수입니다.
- 반환 값은 저장 성공을 알리는 메시지입니다.

### 문서 검색 예제

```python
def 문서_검색(키워드):
    # 키워드에 해당하는 문서를 검색하는 간단한 로직
    return {"결과": f"'{키워드}'와 관련된 문서를 찾았습니다."}
```

- `문서_검색`: 특정 키워드를 입력하여 관련 문서를 검색하는 함수입니다.
- 결과로 관련 문서를 찾았다는 메시지를 제공받습니다.

## 지식베이스 관리의 내부 구현

지식베이스 관리 시스템이 어떻게 작동하는지 시퀀스 다이어그램으로 설명합니다.

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 관리자 as 지식베이스 관리자 시스템
    사용자->>관리자: 문서 저장 요청
    관리자->>관리자: 문서 저장 절차 실행
    관리자->>사용자: 저장 완료 메시지
    사용자->>관리자: 문서 검색 요청
    관리자->>관리자: 키워드 기반 문서 검색
    관리자->>사용자: 검색 결과 반환
```

1. 사용자가 문서를 저장하려고 시스템에 요청을 보냅니다.
2. 시스템은 문서를 저장하고, 사용자에게 성공 메시지를 보냅니다.
3. 사용자가 문서 검색을 요청하면, 시스템은 키워드 기반으로 문서를 검색합니다.
4. 시스템은 검색 결과를 사용자에게 반환합니다.

### 내부 코드 예제

지식베이스 관리의 간단한 코드 예시입니다.

```python
class 지식베이스관리자:
    def __init__(self):
        self.문서들 = {}  # 문서 저장소

    def 문서_추가(self, 이름, 내용):
        # 문서를 추가하는 로직
        self.문서들[이름] = 내용
        return "문서 추가 완료"

    def 문서_검색(self, 키워드):
        # 키워드 기반 검색 로직
        결과 = [이름 for 이름 in self.문서들 if 키워드 in 이름]
        return 결과 or ["관련 문서 없음"]

관리자 = 지식베이스관리자()
관리자.문서_추가("안전 지침", "중요한 안전 정보")
검색_결과 = 관리자.문서_검색("안전")
print(검색_결과)  # 출력: ['안전 지침']
```

- `지식베이스관리자`: 문서 저장과 검색을 담당합니다.
- `문서_추가`: 새로운 문서를 저장소에 추가합니다.
- `문서_검색`: 특정 키워드를 기반으로 문서를 검색하여 반환합니다.

## 결론

이번 장에서는 지식베이스 관리 시스템을 통해 조직의 문서를 체계적으로 저장하고 검색하는 방법을 배웠습니다. 이로써 필요한 정보를 신속하게 찾고, 업무 효율성을 향상시킬 수 있습니다. 다음 장에서는 데이터를 분석하여 유의미한 정보를 도출하는 [데이터 분석 전문 에이전트 (Analytics Agent)](08_데이터_분석_전문_에이전트__analytics_agent_.md)에 대해 알아보겠습니다.
---
# Chapter 8: 데이터 분석 전문 에이전트 (Analytics Agent)

이전 장에서는 [지식베이스 관리 (Knowledge Management)](07_지식베이스_관리__knowledge_management_.md)를 통해 데이터를 체계적으로 관리하는 방법을 배웠습니다. 이번 장에서는 데이터를 분석하여 사용자에게 유의미한 인사이트를 제공하는 **데이터 분석 전문 에이전트 (Analytics Agent)**를 살펴보겠습니다.

## 데이터 분석 전문 에이전트의 필요성

왜 데이터 분석 전문 에이전트가 필요할까요? 현대의 비즈니스 환경에서는 방대한 양의 데이터가 생성되고 있으며, 이를 분석하여 의사 결정에 활용하는 것이 매우 중요합니다. 예를 들어, 특정 제품의 판매 추이를 분석함으로써 시장의 변화를 예측하고 전략을 수립할 수 있습니다. 데이터 분석 전문 에이전트는 이러한 데이터를 효과적으로 분석하여 필요한 정보를 제공합니다.

### 예시 시나리오

하나의 시나리오로, "지난 6개월 동안 가장 많이 판매된 제품은 무엇인가요?"라는 질문이 있을 수 있습니다. 데이터 분석 전문 에이전트는 데이터베이스에서 관련 데이터를 검색하고 분석하여 이러한 질문에 대한 답변을 제공합니다.

## 데이터 분석 전문 에이전트의 주요 개념

1. **질의 처리 (Query Processing)**
   - 사용자의 질문을 이해하고 데이터베이스에서 필요한 데이터를 추출합니다.

2. **데이터 분석 (Data Analysis)**
   - 추출된 데이터를 다양한 기법을 사용하여 분석하고, 의미 있는 결과를 도출합니다.

3. **결과 제공 (Result Presentation)**
   - 분석된 결과를 사용자에게 이해하기 쉽게 제공합니다.

## 데이터 분석 전문 에이전트 사용 방법

이제 간단한 코드 예제를 통해 데이터 분석 전문 에이전트를 사용하는 방법을 살펴보겠습니다.

### 사용자의 질문에 답변 예제

먼저, 사용자가 질문을 던지면 데이터베이스에서 필요한 데이터를 추출하는 예제입니다.

```python
def 데이터_검색(질문):
    # 질의에 따라 데이터베이스 검색하는 로직
    return {"결과": f"'{질문}'에 관련된 데이터를 찾았습니다."}
```

- `데이터_검색`: 사용자가 입력한 질문을 데이터베이스에서 검색하여 필요한 데이터를 반환하는 함수입니다.

### 분석 결과 제공 예제

데이터를 분석하고, 그 결과를 사용자에게 제공하는 방식을 살펴봅시다.

```python
def 결과_제공(데이터):
    # 데이터 분석 결과를 반환하는 간단한 로직
    return {"분석 결과": f"분석된 결과입니다: {데이터}"}
```

- `결과_제공`: 분석된 데이터를 기반으로 사용자에게 결과를 제공하는 함수입니다.

## 데이터 분석 전문 에이전트의 내부 작동 방식

이제 데이터 분석 전문 에이전트가 어떻게 작동하는지 한눈에 볼 수 있도록 시퀀스 다이어그램을 통해 설명해 보겠습니다.

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 분석에이전트 as 데이터 분석 에이전트
    사용자->>분석에이전트: 질문 전송
    분석에이전트->>분석에이전트: 데이터 검색 및 분석
    분석에이전트->>사용자: 분석 결과 제공
```

1. 사용자는 데이터 분석 전문 에이전트에 질문을 보냅니다.
2. 에이전트는 관련 데이터를 데이터베이스에서 검색하고 분석을 수행합니다.
3. 분석된 결과는 사용자에게 제공됩니다.

### 내부 코드 설명

데이터를 검색하고 분석하는 클래스의 간단한 예제를 살펴봅시다.

```python
class 데이터분석에이전트:
    def __init__(self, 데이터베이스):
        self.데이터베이스 = 데이터베이스
        
    def 분석(self, 질문):
        # 데이터를 검색하고 분석하는 기본 로직
        데이터 = self.데이터베이스.get(질문, "데이터 없음")
        return f"분석된 데이터: {데이터}"

데이터베이스 = {
    "지난 6개월 판매": "판매 데이터",
    "고객 리뷰": "리뷰 데이터"
}

에이전트 = 데이터분석에이전트(데이터베이스)
결과 = 에이전트.분석("지난 6개월 판매")
print(결과)  # 출력: 분석된 데이터: 판매 데이터
```

- `데이터분석에이전트`: 데이터베이스로부터 데이터를 검색하여 분석하는 클래스를 정의합니다.
- `분석`: 특정 질문에 대한 데이터를 검색한 후 분석된 결과를 반환합니다.

## 결론

이번 장에서는 데이터 분석 전문 에이전트를 활용하여 데이터베이스에서 데이터를 검색하고, 이를 분석하여 유의미한 결과를 사용자에게 제공하는 방법을 배웠습니다. 데이터 분석은 조직의 중요한 의사 결정에 매우 유용한 정보 자원이 될 수 있습니다. 다음 장에서는 이러한 시스템의 개발 및 배포를 효과적으로 관리할 수 있는 [MLOps 관리 (MLOps Management)](09_mlops_관리__mlops_management_.md)에 대해 알아보겠습니다.

Relevant Code Snippets (Code itself remains unchanged):
No specific code snippets provided for this abstraction.

Instructions for the chapter (Generate content in Korean unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 9: MLOps 관리 (MLOps Management)`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).

- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).

- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).

- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).

- Heavily use analogies and examples throughout (in Korean) to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).

- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-06-30 00:19:24,557 - INFO - Using OpenAI model: gpt-4o
2025-06-30 00:19:36,397 - INFO - RESPONSE: # Chapter 9: MLOps 관리 (MLOps Management)

이전 장에서는 [데이터 분석 전문 에이전트 (Analytics Agent)](08_데이터_분석_전문_에이전트__analytics_agent_.md)를 통해 데이터를 분석하고 의미 있는 해답을 찾는 방법을 배웠습니다. 이번 장에서는 머신러닝 모델을 관리 및 추적하여 안정적으로 운영할 수 있는 **MLOps 관리 (MLOps Management)**에 대해 알아보겠습니다.

## MLOps 관리의 필요성

머신러닝 모델은 데이터의 변화에 따라 성능이 달라질 수 있습니다. MLOps 관리는 이러한 모델의 라이프사이클을 체계적으로 관리하여 지속적으로 높은 성능을 유지하는 데 필수적입니다. 예를 들어, 새로운 데이터를 다루기 위해 모델을 재학습할 때에도 필요한 프로세스를 관리해야 합니다.

### 주요 개념

1. **모델 아티팩트 관리 (Model Artifact Management)**
   - 훈련된 모델 파일을 관리하고 버전을 기록합니다.

2. **모델 추적 (Model Tracking)**
   - 각 모델의 성능과 변경 내역을 추적하여 최적의 성능을 유지합니다.

3. **분석 결과 관리 (Analytics Result Management)**
   - 모델을 통한 분석 결과를 체계적으로 관리하여 재사용성을 높입니다.

## MLOps 관리 사용 방법

MLOps 관리의 각 단계를 간단한 예제를 통해 설명하겠습니다.

### 모델 아티팩트 관리

```python
def 모델_저장(모델_이름, 버전):
    # 모델 정보를 시스템에 저장하는 로직
    return {"메시지": f"{모델_이름} (버전 {버전})이 저장되었습니다."}
```

- `모델_저장`: 모델의 이름과 버전을 파라미터로 받아 시스템에 저장하는 함수입니다.

### 모델 추적 예제

```python
def 모델_추적(모델_이름):
    # 모델 성능을 추적하는 간단한 로직
    return {"결과": f"{모델_이름}의 성능이 기록되었습니다."}
```

- `모델_추적`: 모델의 과거 성능 데이터를 추적하고 결과를 반환하는 함수입니다.

## MLOps 관리의 내부 구현

MLOps 관리 시스템의 내부 작동 방식을 시퀀스 다이어그램으로 설명하겠습니다.

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 시스템 as MLOps 관리 시스템
    사용자->>시스템: 모델 저장 요청
    시스템->>시스템: 모델 아티팩트 저장
    시스템->>사용자: 저장 완료 메시지
    사용자->>시스템: 모델 성능 추적 요청
    시스템->>시스템: 모델 성능 기록
    시스템->>사용자: 추적 완료 메시지
```

1. 사용자가 모델 아티팩트를 MLOps 시스템에 저장합니다.
2. 시스템은 모델 정보를 저장하고 사용자에게 완료 메시지를 보냅니다.
3. 사용자가 모델 추적을 요청하면, 시스템은 성능을 기록합니다.
4. 시스템은 해당 정보를 사용자에게 전달합니다.

### 내부 코드 설명

MLOps 관리를 위한 간단한 내부 구현 예제입니다.

```python
class MLOps관리:
    def __init__(self):
        self.모델들 = {}  # 모델 저장소

    def 모델_저장(self, 이름, 버전):
        # 모델을 저장소에 추가
        self.모델들[이름] = 버전
        return "모델 저장 완료"

    def 성능_추적(self, 이름):
        # 저장된 모델의 성능을 출력 (기본 구현)
        return self.모델들.get(이름, "모델 없음")

관리자 = MLOps관리()
관리자.모델_저장("모델1", "v1.0")
추적_결과 = 관리자.성능_추적("모델1")
print(추적_결과)  # 출력: v1.0
```

- `MLOps관리`: 모델 아티팩트를 저장하고 성능을 추적하는 클래스입니다.
- `모델_저장`: 모델의 버전을 저장합니다.
- `성능_추적`: 저장된 모델의 버전을 추적합니다.

## 결론

이번 장에서는 MLOps 관리 시스템의 각 요소를 이해하고, 이를 통해 머신러닝 모델을 효과적으로 관리하는 방법을 배웠습니다. 이러한 시스템은 머신러닝의 안정적 운영 및 성능 유지에 중요합니다. 이제 다음 장에서는 시스템의 환경 설정과 배포에 대한 [환경 설정 및 배포 (Environment Setup and Deployment)](10_환경_설정_및_배포__environment_setup_and_deployment_.md)에 대해 알아보겠습니다.
2025-06-30 00:19:36,422 - INFO - PROMPT: 
IMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.

Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `SKN10-FINAL-1Team` about the concept: "환경 설정 및 배포 (Environment Setup and Deployment)". This is Chapter 10.

Concept Details (Note: Provided in Korean):
- Name: 환경 설정 및 배포 (Environment Setup and Deployment)
- Description:
프로젝트의 환경 설정과 관련된 파일 및 배포 절차를 정의합니다. (Defines environment setup files and deployment procedures.)

Complete Tutorial Structure (Note: Chapter names might be in Korean):
1. [AI 에이전트 총괄 시스템 (LangGraph Supervisor)](01_ai_에이전트_총괄_시스템__langgraph_supervisor_.md)
2. [FastAPI 서버](02_fastapi_서버.md)
3. [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)
4. [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)
5. [백엔드 라우팅 (Backend Routing)](05_백엔드_라우팅__backend_routing_.md)
6. [문서 검색 전문 에이전트 (RAG Agent)](06_문서_검색_전문_에이전트__rag_agent_.md)
7. [지식베이스 관리 (Knowledge Management)](07_지식베이스_관리__knowledge_management_.md)
8. [데이터 분석 전문 에이전트 (Analytics Agent)](08_데이터_분석_전문_에이전트__analytics_agent_.md)
9. [MLOps 관리 (MLOps Management)](09_mlops_관리__mlops_management_.md)
10. [환경 설정 및 배포 (Environment Setup and Deployment)](10_환경_설정_및_배포__environment_setup_and_deployment_.md)

Context from previous chapters (Note: This summary might be in Korean):
# Chapter 1: AI 에이전트 총괄 시스템 (LangGraph Supervisor)

## 소개

우리가 상상하는 미래의 세계에서는 다양한 AI 에이전트가 우리의 일상 속에서 많은 역할을 하게 될 것입니다. 이 장에서는 사용자의 자연어 요청을 신속하고 정확하게 분석하여 적합한 전문 에이전트에게 작업을 분배하는 시스템인 **AI 에이전트 총괄 시스템 (LangGraph Supervisor)**를 소개합니다.

## 왜 AI 에이전트 총괄 시스템이 필요한가요?

### 문제에 대한 개요

어느 날, 당신은 다수의 AI 전문 에이전트를 관리하는 프로젝트의 관리자입니다. 고객이 다양한 요구를 AI에게 요청하지만 그 요청마다 다른 전문 에이전트로 보내야 합니다. 예를 들어, 문서 검색이 필요한 경우에는 '문서 검색 전문 에이전트', 데이터 분석이 필요한 경우에는 '데이터 분석 전문 에이전트'가 필요합니다.

AI 에이전트 총괄 시스템은 이러한 문제를 해결하기 위해 만들어졌습니다. 사용자가 보내는 자연어 요청을 효과적으로 해석하고, 적합한 에이전트로 작업을 분배합니다.

### 핵심 개념 설명

1. **자연어 처리 (Natural Language Processing)**: 사용자의 요청을 분석하기 위해 사용됩니다. 텍스트를 이해하고 그 의미를 파악합니다.

2. **에이전트 라우팅**: 각 에이전트는 서로 다른 전문 분야를 가지고 있으며, 요청에 가장 적합한 에이전트에게 작업을 보내기 위한 과정입니다.

## AI 에이전트 총괄 시스템 사용 방법

이 시스템을 이해하는 것을 용이하게 하기 위해, 우리는 간단한 예제를 통해 따라가 볼 것입니다.

### 간단한 구현 예제

```python
def 언어_분석(요청):
    # 요청의 내용을 분석하여 필요한 에이전트를 결정함
    if "데이터 분석" in 요청:
        return "데이터 분석 전문 에이전트"
    elif "문서 검색" in 요청:
        return "문서 검색 전문 에이전트"
    else:
        return "일반 에이전트"

결정된_에이전트 = 언어_분석("문서 검색을 원해요")
print(결정된_에이전트)  # 출력: 문서 검색 전문 에이전트
```

위의 코드는 사용자의 요청을 간단히 분석하고, 해당 요청을 가장 잘 수행할 에이전트를 선정하는 프로세스를 보여줍니다.

### 내부 구현

시스템이 어떻게 내부적으로 작동하는지 더 잘 이해하기 위해, 몇 가지 과정을 단계별로 나누어 설명하겠습니다.

#### 시스템 작동 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 시스템 as LangGraph Supervisor
    participant 에이전트1 as 문서 검색 전문 에이전트
    participant 에이전트2 as 데이터 분석 전문 에이전트
    사용자->>시스템: 자연어 요청 전송
    시스템->>사용자: 요청 분석
    시스템->>에이전트1: 적합한 에이전트로 요청 전달
    에이전트1->>시스템: 작업 수행 후 결과 반환
    시스템->>사용자: 결과 전송
```

1. 사용자는 자연어 요청을 시스템에 보냅니다.
2. 시스템은 요청을 분석하여 필요한 에이전트를 결정합니다.
3. 적합한 에이전트에게 요청을 보냅니다.
4. 에이전트는 작업을 수행 후 시스템에 결과를 반환합니다.
5. 시스템은 결과를 사용자에게 전달합니다.

#### 코드 예제

이제, 시스템 내부에서 언어 분석과 라우팅이 어떻게 이루어지는지 코드 레벨에서 예를 들어 보겠습니다.

```python
class LangGraphSupervisor:
    def __init__(self):
        self.agents = {
            "문서 검색": "문서 검색 전문 에이전트",
            "데이터 분석": "데이터 분석 전문 에이전트"
        }

    def 분석후_라우팅(self, 요청):
        for 키워드, 에이전트 in self.agents.items():
            if 키워드 in 요청:
                return 에이전트
        return "일반 에이전트"

supervisor = LangGraphSupervisor()
에이전트 = supervisor.분석후_라우팅("데이터 분석을 요청합니다")
print(에이전트)  # 출력: 데이터 분석 전문 에이전트
```

이 코드에서는 요청을 처리 및 분배하는 `LangGraphSupervisor` 클래스의 구조를 보여줍니다.

## 결론

이 장에서는 AI 에이전트 총괄 시스템의 핵심 개념과 사용 방법을 배웠습니다. 이 시스템은 사용자의 자연어 요청을 분석하고 적절한 에이전트로 작업을 분배하는 것을 목표로 합니다. 다음 장에서는 이 시스템을 구동할 서버 [FastAPI 서버](02_fastapi_서버.md)에 대해 알아봅니다.
---

# Chapter 2: FastAPI 서버

이전 장에서는 [AI 에이전트 총괄 시스템 (LangGraph Supervisor)](01_ai_에이전트_총괄_시스템__langgraph_supervisor_.md)에 대해 알아보았습니다. 이번 장에서는 이러한 시스템이 원활하게 작동하기 위해 필요한 서버 기술인 **FastAPI 서버**에 대해 설명하겠습니다.

FastAPI 서버는 실시간 AI 통신을 처리하며, 사용자와 AI 시스템 간의 데이터 교환을 담당하는 중요한 역할을 합니다. 이 장에서는 FastAPI 서버의 기본적인 개념과 구현 방법을 이해하고, 실제로 간단한 서버를 만들어 보는 것을 목표로 합니다.

## FastAPI 서버의 동기

FastAPI 서버는 왜 필요한 걸까요? FastAPI는 Python 기반의 웹 프레임워크로, 빠르고 효율적인 API를 구축하는 데 사용됩니다. 이것은 특히 AI 시스템과의 빠른 데이터 교환에 최적화되어 있습니다. 예를 들어, 사용자가 챗봇에게 질문을 하거나 AI 분석 결과를 요청하는 시나리오에서 실시간으로 응답을 받아야 합니다. FastAPI는 이러한 요구 사항을 충족시킬 수 있는 솔루션입니다.

### 주요 개념 설명

#### 1. 경량 웹 프레임워크

- FastAPI는 경량 프레임워크로, 쉽고 빠르게 서버를 구축할 수 있습니다.
- 비동기식 처리(Asynchronous Handling)를 통해 높은 처리 성능을 제공합니다.

#### 2. 자동 문서화

- FastAPI는 API 엔드포인트에 대한 자동 문서화 기능을 제공합니다.
- 이는 개발자가 API를 쉽게 이해하고 사용할 수 있도록 돕습니다.

## FastAPI 서버 사용 방법

이제 FastAPI를 사용하여 간단한 서버를 구축하는 방법을 따라해보겠습니다.

### FastAPI 설치

우선 FastAPI를 설치해야 합니다. Python 패키지 매니저인 pip를 통해 설치할 수 있습니다.

```bash
pip install fastapi
pip install uvicorn
```

- `fastapi`: FastAPI 프레임워크 설치
- `uvicorn`: FastAPI 애플리케이션을 실행하기 위한 ASGI 서버

### 간단한 FastAPI 서버 구현

아래는 FastAPI를 사용하여 간단한 서버를 구축하는 코드입니다.

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def 읽기_루트():
    return {"메시지": "Hello World!"}
```

- `FastAPI()`: 새로운 FastAPI 애플리케이션 인스턴스를 생성합니다.
- `@app.get("/")`: 루트 URL에서 GET 요청을 처리합니다.
- `읽기_루트()`: 루트 URL에 접근할 때 반환할 메시지를 정의합니다.

### 서버 실행

FastAPI 애플리케이션을 실행하려면 Uvicorn을 사용합니다.

```bash
uvicorn main:app --reload
```

- `main:app`: main.py 파일의 `app` 객체를 실행합니다.
- `--reload`: 코드 변경 시 서버를 자동으로 다시 시작합니다.

## FastAPI 서버의 내부 구현

FastAPI 서버가 어떻게 내부적으로 작동하는지 알아보겠습니다. FastAPI는 비동기 처리 방식으로 요청을 처리합니다. 아래의 시퀀스 다이어그램은 간단한 HTTP 요청 프로세스를 보여줍니다.

```mermaid
sequenceDiagram
    participant 고객 as 고객
    participant 서버 as FastAPI 서버
    고객->>서버: HTTP 요청 전송
    서버->>고객: 응답 전달
```

1. 고객이 서버로 HTTP 요청을 보냅니다.
2. FastAPI 서버는 요청을 처리하고 적절한 응답을 생성합니다.
3. 응답이 고객에게 전달됩니다.

이제 FastAPI의 코드 구조를 통해 더 깊이 들어가 보겠습니다.

```python
from fastapi import FastAPI, HTTPException

app = FastAPI()

@app.get("/items/{item_id}")
def 읽기_아이템(item_id: int):
    # 데이터베이스에서 항목 찾기 (예시를 위한 간단한 로직)
    if item_id not in [1, 2, 3]:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"item_id": item_id, "값": "여기에 데이터가 들어갑니다"}
```

- `HTTPException`: FastAPI에서 에러 응답을 생성할 때 사용합니다.
- `@app.get("/items/{item_id}")`: 경로 매개변수 `item_id`를 사용하여 특정 아이템에 대한 정보를 요청할 수 있습니다.

## 결론

이번 장에서는 FastAPI 서버의 기본 개념과 이를 사용하여 간단한 웹 애플리케이션을 구축하는 방법을 배웠습니다. FastAPI는 실시간으로 AI 및 사용자의 데이터 교환을 처리하는 데 최적화되어 있습니다. 이제 다음 장에서는 [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)로 이동해 보겠습니다. 이는 사용자의 계정 및 인증 관리를 담당하는 중요한 모듈입니다.
---
# Chapter 3: 계정 관리 모듈 (Accounts Module)

이전 장에서는 [FastAPI 서버](02_fastapi_서버.md)에 대해 알아보았습니다. 이번 장에서는 시스템 사용자와 조직의 정보를 관리하고 인증 처리 기능을 제공하는 중요한 모듈, **계정 관리 모듈 (Accounts Module)**에 대해 설명하겠습니다.

## 계정 관리 모듈의 필요성

현대의 많은 웹 애플리케이션들은 개별 사용자에게 개인화된 경험을 제공하기 위해 사용자 정보와 인증 기능을 필요로 합니다. 예를 들어, 사용자가 앱에 로그인하여 자신의 정보를 확인하고 개인화된 서비스를 받으려면 적절한 계정 관리 시스템이 필수적입니다. 본 모듈은 이러한 요구를 만족시키기 위해 설계되었습니다.

### 주요 개념 설명

#### 1. 사용자 관리

- **사용자 정보**: 사용자의 이름, 이메일, 가입 날짜 등의 정보를 저장합니다.
- **비밀번호 관리**: 사용자 비밀번호를 안전하게 저장하고 변경하는 기능을 포함합니다.

#### 2. 조직 관리

- **조직 정보**: 조직 이름, 구성원 목록을 관리합니다.
- 조직 내 사용자의 역할을 부여하는 기능도 포함됩니다.

#### 3. 인증 처리

- 사용자의 신원을 확인하기 위해 로그인 기능과 토큰 기반 인증을 제공합니다.

## 계정 관리 모듈 사용 방법

이제 계정 관리 모듈을 사용하여 사용자를 생성하고 인증하는 방법을 알아보겠습니다.

### 새로운 사용자 생성

```python
def 사용자_생성(사용자_이름, 비밀번호):
    # 이곳에서 사용자 정보를 데이터베이스에 저장
    return {"메시지": f"{사용자_이름}가 성공적으로 생성되었습니다."}
```

- `사용자_생성`: 사용자 이름과 비밀번호를 사용해 새로운 사용자를 생성하는 함수입니다.
- 출력 메시지를 통해 사용자가 성공적으로 생성되었음을 볼 수 있습니다.

### 로그인 처리

```python
def 로그인(사용자_이름, 비밀번호):
    # 사용자 이름과 비밀번호가 맞는지 확인
    if 올바른_비밀번호(사용자_이름, 비밀번호):
        return {"메시지": "인증 성공"}
    else:
        return {"메시지": "인증 실패"}
```

- `로그인`: 사용자의 이름과 비밀번호를 확인하여 인증 처리 결과를 제공합니다.
- 비밀번호가 맞으면 "인증 성공" 메시지를, 그렇지 않으면 "인증 실패" 메시지를 반환합니다.

## 계정 관리 모듈의 내부 구현

계정 관리 모듈이 실제로 어떻게 작동하는지 이해하기 위해 대략적인 처리 과정을 살펴봅시다.

### 인증 처리 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 서버 as 계정 관리 모듈
    사용자->>서버: 로그인 요청 (사용자 이름, 비밀번호)
    서버->>서버: 비밀번호 확인
    alt 비밀번호가 맞을 때
        서버->>사용자: 인증 성공
    else 비밀번호가 틀릴 때
        서버->>사용자: 인증 실패
    end
```

1. 사용자가 계정 관리 모듈에 로그인 요청을 보냅니다.
2. 모듈은 비밀번호를 확인합니다.
3. 비밀번호가 맞으면 "인증 성공" 메시지를, 틀리면 "인증 실패" 메시지를 반환합니다.

### 내부 코드 구현

기본적인 계정 관리 시스템에는 사용자 정보를 저장하고 인증을 처리하는 클래스 또는 데이터베이스 연결이 필요합니다. 아래는 이러한 기능을 간단히 구현한 예입니다.

```python
class 계정관리:
    def __init__(self):
        self.사용자들 = {}

    def 사용자_추가(self, 이름, 비밀번호):
        self.사용자들[이름] = 비밀번호

    def 로그인_처리(self, 이름, 비밀번호):
        # 사용자 정보 및 비밀번호 일치 여부 확인
        if 이름 in self.사용자들 and self.사용자들[이름] == 비밀번호:
            return "인증 성공"
        return "인증 실패"

계정 = 계정관리()
계정.사용자_추가("홍길동", "비밀번호123")
인증_결과 = 계정.로그인_처리("홍길동", "비밀번호123")
print(인증_결과)  # 출력: 인증 성공
```

- `계정관리`: 사용자 정보를 저장하고 인증을 처리하는 클래스입니다.
- `로그인_처리`: 사용자 이름과 비밀번호가 올바른지 확인합니다.

## 결론

이번 장에서는 계정 관리 모듈을 이용해 사용자를 생성하고 인증하는 방법, 그리고 그 내부 구현을 통해 이 모듈이 어떻게 작동하는지 배웠습니다. 다음 장에서는 사용자와 AI 에이전트 간의 상호작용을 관리하는 [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)에 대해 알아보겠습니다.
---
# Chapter 4: 챗봇 세션 관리 (Chat Session Management)

이전 장에서는 [계정 관리 모듈 (Accounts Module)](03_계정_관리_모듈__accounts_module_.md)에 대해 알아보았습니다. 이번 장에서는 사용자의 대화 세션과 메시지를 효과적으로 관리하고 저장하는 **챗봇 세션 관리 (Chat Session Management)**에 대해 살펴보겠습니다.

## 챗봇 세션 관리의 필요성

챗봇은 다양한 사용자와 상호작용하며 많은 메시지를 처리합니다. 이때, 각 사용자와의 대화 세션을 올바르게 관리해야 이전 대화 기록을 사용하여 대화를 이어 나가거나 정보를 추출할 수 있습니다. 예를 들어, 사용자가 "얼마 전 주문했던 상품이 뭐였죠?"라고 묻는 경우, 이전 대화 세션을 통해 지난 주문 내역을 찾아 제공해야 합니다. 이렇게 하려면 세션 관리가 필수적입니다.

## 챗봇 세션 관리의 주요 개념

1. **세션 저장 (Session Storage)**
   - 각 사용자의 대화 세션을 저장합니다. 이를 통해 필요한 정보를 빠르게 조회할 수 있습니다.

2. **세션 유지 (Session Persistence)**
   - 사용자가 언제든 대화를 이어갈 수 있도록 이전 대화를 유지합니다. 사용자가 다시 접속했을 때, 이전 대화 맥락을 기반으로 서비스를 제공할 수 있습니다.

3. **세션 종료 (Session Termination)**
   - 일정 시간이 지나면 대화 세션을 종료하여 리소스를 효율적으로 관리합니다.

## 챗봇 세션 관리 사용 방법

### 사용자의 세션 저장 예제

아래는 사용자의 대화 세션을 저장하는 간단한 코드 예제입니다.

```python
def 세션_저장(사용자_id, 메시지):
    # 이곳에 세션 데이터를 저장하는 로직을 구현
    return {"메시지": f"{사용자_id}의 세션이 성공적으로 저장되었습니다."}
```

- `세션_저장`: 사용자 ID와 메시지를 받아 세션을 저장하는 함수입니다.
- 반환된 메시지를 통해 성공적으로 세션이 저장되었음을 알 수 있습니다.

### 세션 조회 구현

```python
def 세션_조회(사용자_id):
    # 저장된 세션 데이터를 가져오는 로직 구현
    return {"메시지": f"{사용자_id}의 세션 정보입니다."}
```

- `세션_조회`: 사용자 ID를 입력하면 해당 사용자의 저장된 세션 내용을 반환하는 함수입니다.

## 챗봇 세션 관리의 내부 구현

챗봇 세션 관리가 어떻게 이루어지는지 이해하기 위해 과정을 살펴보겠습니다.

### 세션 관리 처리 과정

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 서버 as 챗봇 세션 관리
    사용자->>서버: 메시지 전송
    서버->>서버: 메시지 저장
    서버->>사용자: 세션 저장 완료 메시지
    사용자->>서버: 세션 조회 요청
    서버->>사용자: 세션 데이터 반환
```

1. 사용자가 메시지를 챗봇에 보냅니다.
2. 서버는 메시지를 세션 데이터베이스에 저장합니다.
3. 저장 완료 후 사용자는 저장 완료 확인 메시지를 받습니다.
4. 사용자가 이전 세션 조회를 요청하면, 서버는 저장된 데이터를 반환합니다.

### 코드 구현 예제

간단한 세션 관리 시스템 코드 예제입니다.

```python
class 세션관리:
    def __init__(self):
        self.세션들 = {}  # 세션 저장을 위한 딕셔너리
    
    def 저장(self, 사용자_id, 메시지):
        # 세션 저장 로직
        if 사용자_id not in self.세션들:
            self.세션들[사용자_id] = []
        self.세션들[사용자_id].append(메시지)
        return "세션 저장 완료"
    
    def 조회(self, 사용자_id):
        # 세션 조회 로직
        return self.세션들.get(사용자_id, "세션 없음")

관리자 = 세션관리()
관리자.저장("사용자1", "안녕하세요!")
결과 = 관리자.조회("사용자1")
print(결과)  # 출력: ['안녕하세요!']
```

- `세션관리`: 사용자 세션을 관리하는 클래스입니다.
- `저장`: 사용자 메시지를 세션에 저장합니다.
- `조회`: 저장된 세션을 반환합니다.

## 결론

이번 장에서는 챗봇 세션 관리를 통해 사용자 대화 세션을 어떻게 저장, 유지, 조회할 수 있는지 배웠습니다. 올바른 세션 관리가 가능해야 사용자에게 더 나은 챗봇 경험을 제공할 수 있습니다. 다음 장에서는 백엔드 라우팅을 효과적으로 활용하는 방법에 대해 알아보겠습니다: [백엔드 라우팅 (Backend Routing)](05_백엔드_라우팅__backend_routing_.md).
---
# Chapter 5: 백엔드 라우팅 (Backend Routing)

이전 장에서는 [챗봇 세션 관리 (Chat Session Management)](04_챗봇_세션_관리__chat_session_management_.md)에 대해 배웠습니다. 이번 장에서는 Django를 사용하여 백엔드 API 경로를 설정하는 방법, 즉 **백엔드 라우팅 (Backend Routing)**에 대해 알아보겠습니다.

## 백엔드 라우팅의 필요성

백엔드 라우팅은 웹 애플리케이션이 클라이언트로부터 요청을 받고 적절한 응답을 할 수 있도록 경로를 설정하는 것입니다. 예를 들어, 사용자가 웹사이트에서 상품 목록을 볼 때, 클라이언트에서의 요청이 백엔드에서 정확한 정보를 전달받기 위해 필요한 모든 것은 라우팅입니다. 이는 특히 여러 페이지가 있는 복잡한 웹 애플리케이션에서 필수적입니다.

### 예시: 상품 목록 보기

- 사용자가 웹사이트의 `/products` 페이지로 들어가면, 백엔드는 상품 목록 데이터를 클라이언트에 제공합니다.
- 적절한 라우팅이 없다면, 요청된 페이지를 찾을 수 없다는 오류 메시지를 보게 될 것입니다.

## 주요 개념

### 1. URL 경로

각각의 URL은 특정한 데이터나 페이지로의 경로입니다. Django에서는 URL 패턴을 설정하여 어떤 URL이 어떤 함수나 클래스로 처리될지를 결정합니다.

### 2. 뷰(View)

각 요청에 대해 응답을 생성하는 역할을 합니다. 예를 들어, 상품 목록 요청을 받아 그것에 대한 HTML 페이지나 JSON 데이터를 반환합니다.

## 백엔드 라우팅 사용 방법

이제 Django에서 간단한 라우팅을 설정하는 방법을 알아봅시다.

### URL 패턴 설정 예제

`urls.py` 파일을 활용하여 URL 패턴을 설정합니다.

```python
# urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('products/', views.상품목록보기, name='상품목록'),
]
```

- `path()`: URL 경로를 설정하는 함수입니다. 첫 번째 인자는 경로, 두 번째 인자는 처리할 뷰 함수, 세 번째는 경로 이름입니다.

### 뷰 함수 구현

라우팅 된 URL을 처리할 뷰 함수를 구현해 봅시다.

```python
# views.py
from django.http import HttpResponse

def 상품목록보기(request):
    # 예시로 간단한 응답을 보냄
    return HttpResponse("상품 목록 페이지입니다.")
```

- `HttpResponse`: HTTP 응답을 생성하는 클래스입니다. 여기에 문자열을 넣어 간단히 출력할 수 있습니다.

## 백엔드 라우팅의 내부 구현

백엔드 라우팅이 내부적으로 어떻게 작동하는지 이해하기 위해 시퀀스 다이어그램을 살펴보겠습니다.

### 프로세스 흐름

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 서버 as Django 서버
    사용자->>서버: /products 요청
    서버->>서버: 경로 확인 (urls.py)
    서버->>서버: 뷰 함수 실행 (views.py)
    서버->>사용자: 상품 목록 응답
```

1. 사용자가 `/products` URL로 요청을 보냅니다.
2. `urls.py`에서 해당 경로에 맞는 패턴을 찾습니다.
3. 연결된 뷰 함수가 실행되어 응답을 생성합니다.
4. 생성된 응답이 사용자에게 전달됩니다.

### 추가 코드 예시

뷰에서 데이터베이스와 연동하여 더 유용한 정보 제공을 위한 예제 코드입니다.

```python
# views.py
from django.http import JsonResponse
from .models import Product

def 상품목록보기(request):
    # 모든 상품의 정보를 가져옴
    products = Product.objects.all().values()
    return JsonResponse(list(products), safe=False)
```

- `JsonResponse`: 데이터를 JSON 형식으로 응답하는 클래스입니다.
- `Product.objects.all()`: 모든 상품 정보를 데이터베이스에서 조회합니다.

## 결론

이번 장에서는 Django를 활용한 백엔드 라우팅의 기본적인 개념과 이를 사용하여 웹 애플리케이션에서 URL을 처리하고 응답하는 방법에 대해 배웠습니다. 다음 장에서는 문서 검색을 담당하는 [문서 검색 전문 에이전트 (RAG Agent)](06_문서_검색_전문_에이전트__rag_agent_.md)에 대해 알아보겠습니다. 이 장에서 배운 라우팅 기법을 활용하여 다양한 API 요청을 관리하게 될 것입니다.
---
# Chapter 6: 문서 검색 전문 에이전트 (RAG Agent)

이전 장에서는 [백엔드 라우팅 (Backend Routing)](05_백엔드_라우팅__backend_routing_.md)에 대해 배웠습니다. 이번 장에서는 사용자의 질문에 대해 회사 내부 문서를 검색하고 답변을 생성하는 **문서 검색 전문 에이전트 (RAG Agent)**에 대해 알아보겠습니다.

## 문서 검색 에이전트의 필요성

회사 내부에는 중요한 정보가 담긴 수많은 문서들이 존재합니다. 그런데 만약 고객이 특정 정보를 문의했을 때, 직원이 일일이 문서를 뒤져야 한다면 얼마나 시간이 걸릴까요? 이러한 문제를 해결하려면 자동화된 문서 검색 시스템이 필요합니다. **문서 검색 전문 에이전트**는 사용자의 질문에 맞춰 해당 문서를 빠르게 검색하고, 요청된 정보를 제공합니다.

### 예시 시나리오

- 고객이 "이 제품의 안전 지침은 무엇인가요?"라고 질문합니다.
- 에이전트는 즉시 관련 문서를 검색하고 적합한 내용을 찾아 답변합니다. 

## 문서 검색 에이전트의 주요 개념

### 1. 질의 처리 (Query Processing)
   - 사용자가 입력한 질문을 이해하고 가장 적합한 정보를 검색합니다.

### 2. 문서 인덱싱 (Document Indexing)
   - 모든 문서를 검색 가능한 형태로 인덱싱하여 빠른 검색이 가능하도록 합니다.

### 3. 정보 검색 (Information Retrieval)
   - 사용자의 질의에 맞는 문서를 찾아내고, 필요한 정보를 추출해서 제공합니다.

## 문서 검색 에이전트 사용 방법

문서 검색 에이전트를 사용하여 간단한 검색을 수행하는 방법을 알아보겠습니다.

### 사용자의 질문에 답변 예제

```python
def 질문_답변(질문):
    # 요청한 질문에 맞는 문서를 검색하는 로직
    return {"답변": f"'{질문}'에 대한 답변입니다."}
```

- `질문_답변`: 입력된 질문에 따라 특정 문서를 검색하고 답변을 제공하는 함수입니다.
- 결과로 질문에 해당하는 답변을 반환합니다.

### 코드 구현 예제

```python
class 문서검색에이전트:
    def __init__(self, 문서들):
        self.문서들 = 문서들
    
    def 검색(self, 질문):
        # 간단한 키워드 기반 검색 예제
        for 문서 in self.문서들:
            if 질문 in 문서:
                return 문서
        return "관련 문서 없음"

에이전트 = 문서검색에이전트(["안전 지침", "사용 설명서"])
답변 = 에이전트.검색("안전")
print(답변)  # 출력: 안전 지침
```

- `문서검색에이전트`: 문서를 관리하고 검색을 수행하는 클래스입니다.
- `검색`: 문서에서 질문에 맞는 내용을 찾아 반환합니다.

## 내부 작동 방식

문서 검색 전문 에이전트가 어떻게 작동하는지 시퀀스 다이어그램으로 살펴보겠습니다.

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 에이전트 as 문서 검색 에이전트
    사용자->>에이전트: 질문 전송
    에이전트->>에이전트: 문서 검색
    에이전트->>사용자: 검색 결과 반환
```

1. 사용자가 에이전트에 질문을 보냅니다.
2. 에이전트는 내부 문서를 바탕으로 질문에 해당하는 정보를 검색합니다.
3. 검색 결과를 사용자에게 반환합니다.

### 추가 코드 설명

더 복잡한 검색 기능을 위해서는 NLP를 활용해 질문을 보다 정교하게 처리할 수 있습니다.

```python
import re

class 고급문서검색에이전트:
    def __init__(self, 문서들):
        self.문서들 = 문서들
    
    def 고급_검색(self, 질문):
        # 정규식을 이용한 고급 검색 예제
        패턴 = re.compile(r'\b{}\b'.format(re.escape(질문)))
        for 문서 in self.문서들:
            if 패턴.search(문서):
                return 문서
        return "관련 문서 없음"

고급에이전트 = 고급문서검색에이전트(["안전 지침", "사용 설명서"])
고급답변 = 고급에이전트.고급_검색("지침")
print(고급답변)  # 출력: 안전 지침
```

- `고급문서검색에이전트`: 자연어 처리 기능을 추가한 문서 검색 에이전트 클래스입니다.
- 정규식을 사용하여 질문에 대해 더 정확한 검색이 가능합니다.

## 결론

이번 장에서는 문서 검색 전문 에이전트를 통해 회사 내부 문서를 빠르게 검색하고 필요한 정보를 제공하는 방법을 배웠습니다. 이러한 자동화 시스템은 업무 효율성을 크게 향상시킬 수 있습니다. 다음 장에서는 회사의 지식 자산을 체계적으로 관리하는 [지식베이스 관리 (Knowledge Management)](07_지식베이스_관리__knowledge_management_.md)에 대해 알아보겠습니다.
---
# Chapter 7: 지식베이스 관리 (Knowledge Management)

이전 장에서는 [문서 검색 전문 에이전트 (RAG Agent)](06_문서_검색_전문_에이전트__rag_agent_.md)의 기능에 대해 알아보았습니다. 이번 장에서는 조직의 문서와 데이터를 체계적으로 관리하고 검색할 수 있는 방안을 제공하는 **지식베이스 관리 (Knowledge Management)**에 대해 다뤄보겠습니다.

## 지식베이스 관리의 필요성

조직은 다양한 문서와 데이터를 생성하고 사용합니다. 이러한 정보들은 시간이 지남에 따라 증가하고, 적절하게 관리되지 않으면 그 가치를 잃게 됩니다. 지식베이스 관리는 이러한 정보를 중앙에서 관리하고, 필요 시 빠르게 찾을 수 있도록 도와줍니다. 예를 들어, 고객 서비스 센터에서 자주 묻는 질문(FAQ)을 빠르게 검색할 수 있도록 관리하는 것입니다.

### 주요 개념 설명

1. **문서 저장 (Document Storage)**
   - 조직의 문서, 매뉴얼, 보고서 등을 중앙 저장소에 안전하게 보관합니다.

2. **문서 검색 (Document Retrieval)**
   - 특정 키워드나 주제에 따라 문서를 효과적으로 검색할 수 있습니다.

3. **임베딩 데이터 관리 (Embedding Data Management)**
   - 문서의 중요한 정보를 임베딩 데이터로 저장하여 검색과 활용을 돕습니다.

## 지식베이스 관리 사용 방법

### 문서 저장 예제

```python
def 문서_저장(문서_이름, 내용):
    # 문서를 저장하는 간단한 로직 예제
    return {"메시지": f"'{문서_이름}' 문서가 성공적으로 저장되었습니다."}
```

- `문서_저장`: 문서 이름과 내용을 입력받아 저장하는 함수입니다.
- 반환 값은 저장 성공을 알리는 메시지입니다.

### 문서 검색 예제

```python
def 문서_검색(키워드):
    # 키워드에 해당하는 문서를 검색하는 간단한 로직
    return {"결과": f"'{키워드}'와 관련된 문서를 찾았습니다."}
```

- `문서_검색`: 특정 키워드를 입력하여 관련 문서를 검색하는 함수입니다.
- 결과로 관련 문서를 찾았다는 메시지를 제공받습니다.

## 지식베이스 관리의 내부 구현

지식베이스 관리 시스템이 어떻게 작동하는지 시퀀스 다이어그램으로 설명합니다.

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 관리자 as 지식베이스 관리자 시스템
    사용자->>관리자: 문서 저장 요청
    관리자->>관리자: 문서 저장 절차 실행
    관리자->>사용자: 저장 완료 메시지
    사용자->>관리자: 문서 검색 요청
    관리자->>관리자: 키워드 기반 문서 검색
    관리자->>사용자: 검색 결과 반환
```

1. 사용자가 문서를 저장하려고 시스템에 요청을 보냅니다.
2. 시스템은 문서를 저장하고, 사용자에게 성공 메시지를 보냅니다.
3. 사용자가 문서 검색을 요청하면, 시스템은 키워드 기반으로 문서를 검색합니다.
4. 시스템은 검색 결과를 사용자에게 반환합니다.

### 내부 코드 예제

지식베이스 관리의 간단한 코드 예시입니다.

```python
class 지식베이스관리자:
    def __init__(self):
        self.문서들 = {}  # 문서 저장소

    def 문서_추가(self, 이름, 내용):
        # 문서를 추가하는 로직
        self.문서들[이름] = 내용
        return "문서 추가 완료"

    def 문서_검색(self, 키워드):
        # 키워드 기반 검색 로직
        결과 = [이름 for 이름 in self.문서들 if 키워드 in 이름]
        return 결과 or ["관련 문서 없음"]

관리자 = 지식베이스관리자()
관리자.문서_추가("안전 지침", "중요한 안전 정보")
검색_결과 = 관리자.문서_검색("안전")
print(검색_결과)  # 출력: ['안전 지침']
```

- `지식베이스관리자`: 문서 저장과 검색을 담당합니다.
- `문서_추가`: 새로운 문서를 저장소에 추가합니다.
- `문서_검색`: 특정 키워드를 기반으로 문서를 검색하여 반환합니다.

## 결론

이번 장에서는 지식베이스 관리 시스템을 통해 조직의 문서를 체계적으로 저장하고 검색하는 방법을 배웠습니다. 이로써 필요한 정보를 신속하게 찾고, 업무 효율성을 향상시킬 수 있습니다. 다음 장에서는 데이터를 분석하여 유의미한 정보를 도출하는 [데이터 분석 전문 에이전트 (Analytics Agent)](08_데이터_분석_전문_에이전트__analytics_agent_.md)에 대해 알아보겠습니다.
---
# Chapter 8: 데이터 분석 전문 에이전트 (Analytics Agent)

이전 장에서는 [지식베이스 관리 (Knowledge Management)](07_지식베이스_관리__knowledge_management_.md)를 통해 데이터를 체계적으로 관리하는 방법을 배웠습니다. 이번 장에서는 데이터를 분석하여 사용자에게 유의미한 인사이트를 제공하는 **데이터 분석 전문 에이전트 (Analytics Agent)**를 살펴보겠습니다.

## 데이터 분석 전문 에이전트의 필요성

왜 데이터 분석 전문 에이전트가 필요할까요? 현대의 비즈니스 환경에서는 방대한 양의 데이터가 생성되고 있으며, 이를 분석하여 의사 결정에 활용하는 것이 매우 중요합니다. 예를 들어, 특정 제품의 판매 추이를 분석함으로써 시장의 변화를 예측하고 전략을 수립할 수 있습니다. 데이터 분석 전문 에이전트는 이러한 데이터를 효과적으로 분석하여 필요한 정보를 제공합니다.

### 예시 시나리오

하나의 시나리오로, "지난 6개월 동안 가장 많이 판매된 제품은 무엇인가요?"라는 질문이 있을 수 있습니다. 데이터 분석 전문 에이전트는 데이터베이스에서 관련 데이터를 검색하고 분석하여 이러한 질문에 대한 답변을 제공합니다.

## 데이터 분석 전문 에이전트의 주요 개념

1. **질의 처리 (Query Processing)**
   - 사용자의 질문을 이해하고 데이터베이스에서 필요한 데이터를 추출합니다.

2. **데이터 분석 (Data Analysis)**
   - 추출된 데이터를 다양한 기법을 사용하여 분석하고, 의미 있는 결과를 도출합니다.

3. **결과 제공 (Result Presentation)**
   - 분석된 결과를 사용자에게 이해하기 쉽게 제공합니다.

## 데이터 분석 전문 에이전트 사용 방법

이제 간단한 코드 예제를 통해 데이터 분석 전문 에이전트를 사용하는 방법을 살펴보겠습니다.

### 사용자의 질문에 답변 예제

먼저, 사용자가 질문을 던지면 데이터베이스에서 필요한 데이터를 추출하는 예제입니다.

```python
def 데이터_검색(질문):
    # 질의에 따라 데이터베이스 검색하는 로직
    return {"결과": f"'{질문}'에 관련된 데이터를 찾았습니다."}
```

- `데이터_검색`: 사용자가 입력한 질문을 데이터베이스에서 검색하여 필요한 데이터를 반환하는 함수입니다.

### 분석 결과 제공 예제

데이터를 분석하고, 그 결과를 사용자에게 제공하는 방식을 살펴봅시다.

```python
def 결과_제공(데이터):
    # 데이터 분석 결과를 반환하는 간단한 로직
    return {"분석 결과": f"분석된 결과입니다: {데이터}"}
```

- `결과_제공`: 분석된 데이터를 기반으로 사용자에게 결과를 제공하는 함수입니다.

## 데이터 분석 전문 에이전트의 내부 작동 방식

이제 데이터 분석 전문 에이전트가 어떻게 작동하는지 한눈에 볼 수 있도록 시퀀스 다이어그램을 통해 설명해 보겠습니다.

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 분석에이전트 as 데이터 분석 에이전트
    사용자->>분석에이전트: 질문 전송
    분석에이전트->>분석에이전트: 데이터 검색 및 분석
    분석에이전트->>사용자: 분석 결과 제공
```

1. 사용자는 데이터 분석 전문 에이전트에 질문을 보냅니다.
2. 에이전트는 관련 데이터를 데이터베이스에서 검색하고 분석을 수행합니다.
3. 분석된 결과는 사용자에게 제공됩니다.

### 내부 코드 설명

데이터를 검색하고 분석하는 클래스의 간단한 예제를 살펴봅시다.

```python
class 데이터분석에이전트:
    def __init__(self, 데이터베이스):
        self.데이터베이스 = 데이터베이스
        
    def 분석(self, 질문):
        # 데이터를 검색하고 분석하는 기본 로직
        데이터 = self.데이터베이스.get(질문, "데이터 없음")
        return f"분석된 데이터: {데이터}"

데이터베이스 = {
    "지난 6개월 판매": "판매 데이터",
    "고객 리뷰": "리뷰 데이터"
}

에이전트 = 데이터분석에이전트(데이터베이스)
결과 = 에이전트.분석("지난 6개월 판매")
print(결과)  # 출력: 분석된 데이터: 판매 데이터
```

- `데이터분석에이전트`: 데이터베이스로부터 데이터를 검색하여 분석하는 클래스를 정의합니다.
- `분석`: 특정 질문에 대한 데이터를 검색한 후 분석된 결과를 반환합니다.

## 결론

이번 장에서는 데이터 분석 전문 에이전트를 활용하여 데이터베이스에서 데이터를 검색하고, 이를 분석하여 유의미한 결과를 사용자에게 제공하는 방법을 배웠습니다. 데이터 분석은 조직의 중요한 의사 결정에 매우 유용한 정보 자원이 될 수 있습니다. 다음 장에서는 이러한 시스템의 개발 및 배포를 효과적으로 관리할 수 있는 [MLOps 관리 (MLOps Management)](09_mlops_관리__mlops_management_.md)에 대해 알아보겠습니다.
---
# Chapter 9: MLOps 관리 (MLOps Management)

이전 장에서는 [데이터 분석 전문 에이전트 (Analytics Agent)](08_데이터_분석_전문_에이전트__analytics_agent_.md)를 통해 데이터를 분석하고 의미 있는 해답을 찾는 방법을 배웠습니다. 이번 장에서는 머신러닝 모델을 관리 및 추적하여 안정적으로 운영할 수 있는 **MLOps 관리 (MLOps Management)**에 대해 알아보겠습니다.

## MLOps 관리의 필요성

머신러닝 모델은 데이터의 변화에 따라 성능이 달라질 수 있습니다. MLOps 관리는 이러한 모델의 라이프사이클을 체계적으로 관리하여 지속적으로 높은 성능을 유지하는 데 필수적입니다. 예를 들어, 새로운 데이터를 다루기 위해 모델을 재학습할 때에도 필요한 프로세스를 관리해야 합니다.

### 주요 개념

1. **모델 아티팩트 관리 (Model Artifact Management)**
   - 훈련된 모델 파일을 관리하고 버전을 기록합니다.

2. **모델 추적 (Model Tracking)**
   - 각 모델의 성능과 변경 내역을 추적하여 최적의 성능을 유지합니다.

3. **분석 결과 관리 (Analytics Result Management)**
   - 모델을 통한 분석 결과를 체계적으로 관리하여 재사용성을 높입니다.

## MLOps 관리 사용 방법

MLOps 관리의 각 단계를 간단한 예제를 통해 설명하겠습니다.

### 모델 아티팩트 관리

```python
def 모델_저장(모델_이름, 버전):
    # 모델 정보를 시스템에 저장하는 로직
    return {"메시지": f"{모델_이름} (버전 {버전})이 저장되었습니다."}
```

- `모델_저장`: 모델의 이름과 버전을 파라미터로 받아 시스템에 저장하는 함수입니다.

### 모델 추적 예제

```python
def 모델_추적(모델_이름):
    # 모델 성능을 추적하는 간단한 로직
    return {"결과": f"{모델_이름}의 성능이 기록되었습니다."}
```

- `모델_추적`: 모델의 과거 성능 데이터를 추적하고 결과를 반환하는 함수입니다.

## MLOps 관리의 내부 구현

MLOps 관리 시스템의 내부 작동 방식을 시퀀스 다이어그램으로 설명하겠습니다.

```mermaid
sequenceDiagram
    participant 사용자 as 사용자
    participant 시스템 as MLOps 관리 시스템
    사용자->>시스템: 모델 저장 요청
    시스템->>시스템: 모델 아티팩트 저장
    시스템->>사용자: 저장 완료 메시지
    사용자->>시스템: 모델 성능 추적 요청
    시스템->>시스템: 모델 성능 기록
    시스템->>사용자: 추적 완료 메시지
```

1. 사용자가 모델 아티팩트를 MLOps 시스템에 저장합니다.
2. 시스템은 모델 정보를 저장하고 사용자에게 완료 메시지를 보냅니다.
3. 사용자가 모델 추적을 요청하면, 시스템은 성능을 기록합니다.
4. 시스템은 해당 정보를 사용자에게 전달합니다.

### 내부 코드 설명

MLOps 관리를 위한 간단한 내부 구현 예제입니다.

```python
class MLOps관리:
    def __init__(self):
        self.모델들 = {}  # 모델 저장소

    def 모델_저장(self, 이름, 버전):
        # 모델을 저장소에 추가
        self.모델들[이름] = 버전
        return "모델 저장 완료"

    def 성능_추적(self, 이름):
        # 저장된 모델의 성능을 출력 (기본 구현)
        return self.모델들.get(이름, "모델 없음")

관리자 = MLOps관리()
관리자.모델_저장("모델1", "v1.0")
추적_결과 = 관리자.성능_추적("모델1")
print(추적_결과)  # 출력: v1.0
```

- `MLOps관리`: 모델 아티팩트를 저장하고 성능을 추적하는 클래스입니다.
- `모델_저장`: 모델의 버전을 저장합니다.
- `성능_추적`: 저장된 모델의 버전을 추적합니다.

## 결론

이번 장에서는 MLOps 관리 시스템의 각 요소를 이해하고, 이를 통해 머신러닝 모델을 효과적으로 관리하는 방법을 배웠습니다. 이러한 시스템은 머신러닝의 안정적 운영 및 성능 유지에 중요합니다. 이제 다음 장에서는 시스템의 환경 설정과 배포에 대한 [환경 설정 및 배포 (Environment Setup and Deployment)](10_환경_설정_및_배포__environment_setup_and_deployment_.md)에 대해 알아보겠습니다.

Relevant Code Snippets (Code itself remains unchanged):
No specific code snippets provided for this abstraction.

Instructions for the chapter (Generate content in Korean unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 10: 환경 설정 및 배포 (Environment Setup and Deployment)`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).

- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).

- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).

- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).

- Heavily use analogies and examples throughout (in Korean) to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).

- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-06-30 00:19:36,728 - INFO - Using OpenAI model: gpt-4o
2025-06-30 00:19:49,208 - INFO - RESPONSE: # Chapter 10: 환경 설정 및 배포 (Environment Setup and Deployment)

이전 장에서는 [MLOps 관리 (MLOps Management)](09_mlops_관리__mlops_management_.md)에 대해 알아보았습니다. 이번 장에서는 시스템을 운영하기 위한 환경을 설정하고, 이를 배포하는 방법에 대해 살펴볼 것입니다.

## 환경 설정 및 배포의 필요성

복잡한 시스템이나 프로젝트를 운영하기 위해서는 적절한 환경 설정과 배포가 필수적입니다. 예를 들어, 로컬에서 개발한 웹 애플리케이션을 실제 서버에 올려 많은 사용자들이 접근할 수 있도록 하려면, 이 과정이 필요합니다. 이러한 환경 설정 및 배포는 개발 환경과 운영 환경을 서로 다른 방식으로 관리할 수 있도록 돕고, 결국 시스템의 안정적이고 효율적인 운영을 가능하게 합니다.

## 주요 개념

### 1. 환경 설정 (Environment Setup)
   - 개발 환경과 운영 환경을 구성하는 모든 설정 파일을 준비합니다. 예를 들어, 데이터베이스 연결 정보 같은 것을 설정할 수 있습니다.

### 2. 배포 (Deployment)
   - 준비된 시스템을 서버에 올리고, 사용자가 실제로 사용할 수 있도록 하는 과정입니다. 예를 들어, 웹 서버 설정, 방화벽 설정 등이 포함됩니다.

## 환경 설정 및 배포 사용 방법

### 환경 설정 예제

아래는 파이썬 프로젝트에서 환경 설정을 하는 간단한 예제입니다.

```python
import os

def 설정_파일_로딩(파일_경로):
    # 설정 파일에서 환경 변수 로딩
    with open(파일_경로) as 설정_파일:
        return 설정_파일.readlines()

환경_설정 = 설정_파일_로딩(".env")
print(환경_설정)  # 출력: 설정 파일의 내용
```

- `설정_파일_로딩`: 설정 파일을 읽어 환경 변수를 로딩하는 함수입니다.
- `.env` 파일의 내용을 읽어 변수로 사용할 수 있습니다.

### 배포 설정 예제

간단한 배포 스크립트를 통해 배포하는 과정입니다.

```bash
# 배포 예제 스크립트
git fetch origin
git reset --hard origin/main
pip install -r requirements.txt
# 이후 서버 재시작
```

- `git fetch` 및 `git reset`: 최신 코드를 원격 저장소에서 가져옵니다.
- `pip install`: 필요한 패키지를 설치합니다.

## 환경 설정 및 배포의 내부 구현

환경 설정 및 배포가 실제로 어떻게 이루어지는지 시퀀스 다이어그램으로 설명하겠습니다.

```mermaid
sequenceDiagram
    participant 개발자 as 개발자
    participant 서버 as 서버
    개발자->>서버: 앱 배포 요청
    서버->>서버: 최신 코드 가져오기
    서버->>서버: 설정 및 패키지 설치
    서버->>개발자: 배포 완료 메시지
```

1. 개발자가 서버에 앱 배포를 요청합니다.
2. 서버는 최신 코드를 가져옵니다.
3. 이후 필요한 설정과 패키지를 설치합니다.
4. 서버는 개발자에게 배포가 완료되었음을 알립니다.

### 내부 코드 예제

환경 설정을 관리하는 간단한 코드 예시입니다.

```python
def 설정_파일_적용(경로):
    # 간단한 설정 파일 적용 방법
    설정 = {}
    with open(경로) as 설정_파일:
        for 줄 in 설정_파일:
            키, 값 = 줄.strip().split('=')
            설정[키] = 값
    return 설정

환경_설정 = 설정_파일_적용("config.txt")
print(환경_설정["DB_HOST"])  # 환경 변수를 불러와 사용
```

- `설정_파일_적용`: 설정 파일에서 키와 값을 읽어와 환경 변수로 저장하는 함수입니다.
- `config.txt`: 파일에서 데이터베이스 호스트 등 필요 정보를 불러옵니다.

## 결론

이번 장에서는 시스템의 올바른 환경 설정 및 배포를 위한 기본 개념과 절차에 대해 배웠습니다. 이러한 과정은 시스템이 안정적으로 동작할 수 있는 기반을 제공합니다. 다음 장에서는 프로젝트에 포함될 모든 하위 시스템과 의존성을 명확하게 설명하는 [프로젝트 문서화 (Project Documentation)](11_프로젝트_문서화__project_documentation_.md)에 대해 알아보겠습니다.
