{
    "\nAnalyze the following codebase for the project 'pydantic'.\n\nAvailable files (total 8):\n- 0 # __init__.py\n- 1 # _internal/__init__.py\n- 2 # _internal/_config.py\n- 3 # _internal/_core_metadata.py\n- 4 # _internal/_core_utils.py\n- 5 # _internal/_dataclasses.py\n- 6 # _internal/_decorators.py\n- 7 # _internal/_decorators_v1.py\n\nFull context of all files:\n--- File Index 0: __init__.py ---\nimport typing\nfrom importlib import import_module\nfrom warnings import warn\n\nfrom ._migration import getattr_migration\nfrom .version import VERSION\n\nif typing.TYPE_CHECKING:\n    # import of virtually everything is supported via `__getattr__` below,\n    # but we need them here for type checking and IDE support\n    import pydantic_core\n    from pydantic_core.core_schema import (\n        FieldSerializationInfo,\n        SerializationInfo,\n        SerializerFunctionWrapHandler,\n        ValidationInfo,\n        ValidatorFunctionWrapHandler,\n    )\n\n    from . import dataclasses\n    from .aliases import AliasChoices, AliasGenerator, AliasPath\n    from .annotated_handlers import GetCoreSchemaHandler, GetJsonSchemaHandler\n    from .config import ConfigDict, with_config\n    from .errors import *\n    from .fields import Field, PrivateAttr, computed_field\n    from .functional_serializers import (\n        PlainSerializer,\n        SerializeAsAny,\n        WrapSerializer,\n        field_serializer,\n        model_serializer,\n    )\n    from .functional_validators import (\n        AfterValidator,\n        BeforeValidator,\n        InstanceOf,\n        ModelWrapValidatorHandler,\n        PlainValidator,\n        SkipValidation,\n        WrapValidator,\n        field_validator,\n        model_validator,\n    )\n    from .json_schema import WithJsonSchema\n    from .main import *\n    from .networks import *\n    from .type_adapter import TypeAdapter\n    from .types import *\n    from .validate_call_decorator import validate_call\n    from .warnings import (\n        PydanticDeprecatedSince20,\n        PydanticDeprecatedSince26,\n        PydanticDeprecatedSince29,\n        PydanticDeprecatedSince210,\n        PydanticDeprecatedSince211,\n        PydanticDeprecationWarning,\n        PydanticExperimentalWarning,\n    )\n\n    # this encourages pycharm to import `ValidationError` from here, not pydantic_core\n    ValidationError = pydantic_core.ValidationError\n    from .deprecated.class_validators import root_validator, validator\n    from .deprecated.config import BaseConfig, Extra\n    from .deprecated.tools import *\n    from .root_model import RootModel\n\n__version__ = VERSION\n__all__ = (\n    # dataclasses\n    'dataclasses',\n    # functional validators\n    'field_validator',\n    'model_validator',\n    'AfterValidator',\n    'BeforeValidator',\n    'PlainValidator',\n    'WrapValidator',\n    'SkipValidation',\n    'InstanceOf',\n    'ModelWrapValidatorHandler',\n    # JSON Schema\n    'WithJsonSchema',\n    # deprecated V1 functional validators, these are imported via `__getattr__` below\n    'root_validator',\n    'validator',\n    # functional serializers\n    'field_serializer',\n    'model_serializer',\n    'PlainSerializer',\n    'SerializeAsAny',\n    'WrapSerializer',\n    # config\n    'ConfigDict',\n    'with_config',\n    # deprecated V1 config, these are imported via `__getattr__` below\n    'BaseConfig',\n    'Extra',\n    # validate_call\n    'validate_call',\n    # errors\n    'PydanticErrorCodes',\n    'PydanticUserError',\n    'PydanticSchemaGenerationError',\n    'PydanticImportError',\n    'PydanticUndefinedAnnotation',\n    'PydanticInvalidForJsonSchema',\n    'PydanticForbiddenQualifier',\n    # fields\n    'Field',\n    'computed_field',\n    'PrivateAttr',\n    # alias\n    'AliasChoices',\n    'AliasGenerator',\n    'AliasPath',\n    # main\n    'BaseModel',\n    'create_model',\n    # network\n    'AnyUrl',\n    'AnyHttpUrl',\n    'FileUrl',\n    'HttpUrl',\n    'FtpUrl',\n    'WebsocketUrl',\n    'AnyWebsocketUrl',\n    'UrlConstraints',\n    'EmailStr',\n    'NameEmail',\n    'IPvAnyAddress',\n    'IPvAnyInterface',\n    'IPvAnyNetwork',\n    'PostgresDsn',\n    'CockroachDsn',\n    'AmqpDsn',\n    'RedisDsn',\n    'MongoDsn',\n    'KafkaDsn',\n    'NatsDsn',\n    'MySQLDsn',\n    'MariaDBDsn',\n    'ClickHouseDsn',\n    'SnowflakeDsn',\n    'validate_email',\n    # root_model\n    'RootModel',\n    # deprecated tools, these are imported via `__getattr__` below\n    'parse_obj_as',\n    'schema_of',\n    'schema_json_of',\n    # types\n    'Strict',\n    'StrictStr',\n    'conbytes',\n    'conlist',\n    'conset',\n    'confrozenset',\n    'constr',\n    'StringConstraints',\n    'ImportString',\n    'conint',\n    'PositiveInt',\n    'NegativeInt',\n    'NonNegativeInt',\n    'NonPositiveInt',\n    'confloat',\n    'PositiveFloat',\n    'NegativeFloat',\n    'NonNegativeFloat',\n    'NonPositiveFloat',\n    'FiniteFloat',\n    'condecimal',\n    'condate',\n    'UUID1',\n    'UUID3',\n    'UUID4',\n    'UUID5',\n    'UUID6',\n    'UUID7',\n    'UUID8',\n    'FilePath',\n    'DirectoryPath',\n    'NewPath',\n    'Json',\n    'Secret',\n    'SecretStr',\n    'SecretBytes',\n    'SocketPath',\n    'StrictBool',\n    'StrictBytes',\n    'StrictInt',\n    'StrictFloat',\n    'PaymentCardNumber',\n    'ByteSize',\n    'PastDate',\n    'FutureDate',\n    'PastDatetime',\n    'FutureDatetime',\n    'AwareDatetime',\n    'NaiveDatetime',\n    'AllowInfNan',\n    'EncoderProtocol',\n    'EncodedBytes',\n    'EncodedStr',\n    'Base64Encoder',\n    'Base64Bytes',\n    'Base64Str',\n    'Base64UrlBytes',\n    'Base64UrlStr',\n    'GetPydanticSchema',\n    'Tag',\n    'Discriminator',\n    'JsonValue',\n    'FailFast',\n    # type_adapter\n    'TypeAdapter',\n    # version\n    '__version__',\n    'VERSION',\n    # warnings\n    'PydanticDeprecatedSince20',\n    'PydanticDeprecatedSince26',\n    'PydanticDeprecatedSince29',\n    'PydanticDeprecatedSince210',\n    'PydanticDeprecatedSince211',\n    'PydanticDeprecationWarning',\n    'PydanticExperimentalWarning',\n    # annotated handlers\n    'GetCoreSchemaHandler',\n    'GetJsonSchemaHandler',\n    # pydantic_core\n    'ValidationError',\n    'ValidationInfo',\n    'SerializationInfo',\n    'ValidatorFunctionWrapHandler',\n    'FieldSerializationInfo',\n    'SerializerFunctionWrapHandler',\n    'OnErrorOmit',\n)\n\n# A mapping of {<member name>: (package, <module name>)} defining dynamic imports\n_dynamic_imports: 'dict[str, tuple[str, str]]' = {\n    'dataclasses': (__spec__.parent, '__module__'),\n    # functional validators\n    'field_validator': (__spec__.parent, '.functional_validators'),\n    'model_validator': (__spec__.parent, '.functional_validators'),\n    'AfterValidator': (__spec__.parent, '.functional_validators'),\n    'BeforeValidator': (__spec__.parent, '.functional_validators'),\n    'PlainValidator': (__spec__.parent, '.functional_validators'),\n    'WrapValidator': (__spec__.parent, '.functional_validators'),\n    'SkipValidation': (__spec__.parent, '.functional_validators'),\n    'InstanceOf': (__spec__.parent, '.functional_validators'),\n    'ModelWrapValidatorHandler': (__spec__.parent, '.functional_validators'),\n    # JSON Schema\n    'WithJsonSchema': (__spec__.parent, '.json_schema'),\n    # functional serializers\n    'field_serializer': (__spec__.parent, '.functional_serializers'),\n    'model_serializer': (__spec__.parent, '.functional_serializers'),\n    'PlainSerializer': (__spec__.parent, '.functional_serializers'),\n    'SerializeAsAny': (__spec__.parent, '.functional_serializers'),\n    'WrapSerializer': (__spec__.parent, '.functional_serializers'),\n    # config\n    'ConfigDict': (__spec__.parent, '.config'),\n    'with_config': (__spec__.parent, '.config'),\n    # validate call\n    'validate_call': (__spec__.parent, '.validate_call_decorator'),\n    # errors\n    'PydanticErrorCodes': (__spec__.parent, '.errors'),\n    'PydanticUserError': (__spec__.parent, '.errors'),\n    'PydanticSchemaGenerationError': (__spec__.parent, '.errors'),\n    'PydanticImportError': (__spec__.parent, '.errors'),\n    'PydanticUndefinedAnnotation': (__spec__.parent, '.errors'),\n    'PydanticInvalidForJsonSchema': (__spec__.parent, '.errors'),\n    'PydanticForbiddenQualifier': (__spec__.parent, '.errors'),\n    # fields\n    'Field': (__spec__.parent, '.fields'),\n    'computed_field': (__spec__.parent, '.fields'),\n    'PrivateAttr': (__spec__.parent, '.fields'),\n    # alias\n    'AliasChoices': (__spec__.parent, '.aliases'),\n    'AliasGenerator': (__spec__.parent, '.aliases'),\n    'AliasPath': (__spec__.parent, '.aliases'),\n    # main\n    'BaseModel': (__spec__.parent, '.main'),\n    'create_model': (__spec__.parent, '.main'),\n    # network\n    'AnyUrl': (__spec__.parent, '.networks'),\n    'AnyHttpUrl': (__spec__.parent, '.networks'),\n    'FileUrl': (__spec__.parent, '.networks'),\n    'HttpUrl': (__spec__.parent, '.networks'),\n    'FtpUrl': (__spec__.parent, '.networks'),\n    'WebsocketUrl': (__spec__.parent, '.networks'),\n    'AnyWebsocketUrl': (__spec__.parent, '.networks'),\n    'UrlConstraints': (__spec__.parent, '.networks'),\n    'EmailStr': (__spec__.parent, '.networks'),\n    'NameEmail': (__spec__.parent, '.networks'),\n    'IPvAnyAddress': (__spec__.parent, '.networks'),\n    'IPvAnyInterface': (__spec__.parent, '.networks'),\n    'IPvAnyNetwork': (__spec__.parent, '.networks'),\n    'PostgresDsn': (__spec__.parent, '.networks'),\n    'CockroachDsn': (__spec__.parent, '.networks'),\n    'AmqpDsn': (__spec__.parent, '.networks'),\n    'RedisDsn': (__spec__.parent, '.networks'),\n    'MongoDsn': (__spec__.parent, '.networks'),\n    'KafkaDsn': (__spec__.parent, '.networks'),\n    'NatsDsn': (__spec__.parent, '.networks'),\n    'MySQLDsn': (__spec__.parent, '.networks'),\n    'MariaDBDsn': (__spec__.parent, '.networks'),\n    'ClickHouseDsn': (__spec__.parent, '.networks'),\n    'SnowflakeDsn': (__spec__.parent, '.networks'),\n    'validate_email': (__spec__.parent, '.networks'),\n    # root_model\n    'RootModel': (__spec__.parent, '.root_model'),\n    # types\n    'Strict': (__spec__.parent, '.types'),\n    'StrictStr': (__spec__.parent, '.types'),\n    'conbytes': (__spec__.parent, '.types'),\n    'conlist': (__spec__.parent, '.types'),\n    'conset': (__spec__.parent, '.types'),\n    'confrozenset': (__spec__.parent, '.types'),\n    'constr': (__spec__.parent, '.types'),\n    'StringConstraints': (__spec__.parent, '.types'),\n    'ImportString': (__spec__.parent, '.types'),\n    'conint': (__spec__.parent, '.types'),\n    'PositiveInt': (__spec__.parent, '.types'),\n    'NegativeInt': (__spec__.parent, '.types'),\n    'NonNegativeInt': (__spec__.parent, '.types'),\n    'NonPositiveInt': (__spec__.parent, '.types'),\n    'confloat': (__spec__.parent, '.types'),\n    'PositiveFloat': (__spec__.parent, '.types'),\n    'NegativeFloat': (__spec__.parent, '.types'),\n    'NonNegativeFloat': (__spec__.parent, '.types'),\n    'NonPositiveFloat': (__spec__.parent, '.types'),\n    'FiniteFloat': (__spec__.parent, '.types'),\n    'condecimal': (__spec__.parent, '.types'),\n    'condate': (__spec__.parent, '.types'),\n    'UUID1': (__spec__.parent, '.types'),\n    'UUID3': (__spec__.parent, '.types'),\n    'UUID4': (__spec__.parent, '.types'),\n    'UUID5': (__spec__.parent, '.types'),\n    'UUID6': (__spec__.parent, '.types'),\n    'UUID7': (__spec__.parent, '.types'),\n    'UUID8': (__spec__.parent, '.types'),\n    'FilePath': (__spec__.parent, '.types'),\n    'DirectoryPath': (__spec__.parent, '.types'),\n    'NewPath': (__spec__.parent, '.types'),\n    'Json': (__spec__.parent, '.types'),\n    'Secret': (__spec__.parent, '.types'),\n    'SecretStr': (__spec__.parent, '.types'),\n    'SecretBytes': (__spec__.parent, '.types'),\n    'StrictBool': (__spec__.parent, '.types'),\n    'StrictBytes': (__spec__.parent, '.types'),\n    'StrictInt': (__spec__.parent, '.types'),\n    'StrictFloat': (__spec__.parent, '.types'),\n    'PaymentCardNumber': (__spec__.parent, '.types'),\n    'ByteSize': (__spec__.parent, '.types'),\n    'PastDate': (__spec__.parent, '.types'),\n    'SocketPath': (__spec__.parent, '.types'),\n    'FutureDate': (__spec__.parent, '.types'),\n    'PastDatetime': (__spec__.parent, '.types'),\n    'FutureDatetime': (__spec__.parent, '.types'),\n    'AwareDatetime': (__spec__.parent, '.types'),\n    'NaiveDatetime': (__spec__.parent, '.types'),\n    'AllowInfNan': (__spec__.parent, '.types'),\n    'EncoderProtocol': (__spec__.parent, '.types'),\n    'EncodedBytes': (__spec__.parent, '.types'),\n    'EncodedStr': (__spec__.parent, '.types'),\n    'Base64Encoder': (__spec__.parent, '.types'),\n    'Base64Bytes': (__spec__.parent, '.types'),\n    'Base64Str': (__spec__.parent, '.types'),\n    'Base64UrlBytes': (__spec__.parent, '.types'),\n    'Base64UrlStr': (__spec__.parent, '.types'),\n    'GetPydanticSchema': (__spec__.parent, '.types'),\n    'Tag': (__spec__.parent, '.types'),\n    'Discriminator': (__spec__.parent, '.types'),\n    'JsonValue': (__spec__.parent, '.types'),\n    'OnErrorOmit': (__spec__.parent, '.types'),\n    'FailFast': (__spec__.parent, '.types'),\n    # type_adapter\n    'TypeAdapter': (__spec__.parent, '.type_adapter'),\n    # warnings\n    'PydanticDeprecatedSince20': (__spec__.parent, '.warnings'),\n    'PydanticDeprecatedSince26': (__spec__.parent, '.warnings'),\n    'PydanticDeprecatedSince29': (__spec__.parent, '.warnings'),\n    'PydanticDeprecatedSince210': (__spec__.parent, '.warnings'),\n    'PydanticDeprecatedSince211': (__spec__.parent, '.warnings'),\n    'PydanticDeprecationWarning': (__spec__.parent, '.warnings'),\n    'PydanticExperimentalWarning': (__spec__.parent, '.warnings'),\n    # annotated handlers\n    'GetCoreSchemaHandler': (__spec__.parent, '.annotated_handlers'),\n    'GetJsonSchemaHandler': (__spec__.parent, '.annotated_handlers'),\n    # pydantic_core stuff\n    'ValidationError': ('pydantic_core', '.'),\n    'ValidationInfo': ('pydantic_core', '.core_schema'),\n    'SerializationInfo': ('pydantic_core', '.core_schema'),\n    'ValidatorFunctionWrapHandler': ('pydantic_core', '.core_schema'),\n    'FieldSerializationInfo': ('pydantic_core', '.core_schema'),\n    'SerializerFunctionWrapHandler': ('pydantic_core', '.core_schema'),\n    # deprecated, mostly not included in __all__\n    'root_validator': (__spec__.parent, '.deprecated.class_validators'),\n    'validator': (__spec__.parent, '.deprecated.class_validators'),\n    'BaseConfig': (__spec__.parent, '.deprecated.config'),\n    'Extra': (__spec__.parent, '.deprecated.config'),\n    'parse_obj_as': (__spec__.parent, '.deprecated.tools'),\n    'schema_of': (__spec__.parent, '.deprecated.tools'),\n    'schema_json_of': (__spec__.parent, '.deprecated.tools'),\n    # deprecated dynamic imports\n    'FieldValidationInfo': ('pydantic_core', '.core_schema'),\n    'GenerateSchema': (__spec__.parent, '._internal._generate_schema'),\n}\n_deprecated_dynamic_imports = {'FieldValidationInfo', 'GenerateSchema'}\n\n_getattr_migration = getattr_migration(__name__)\n\n\ndef __getattr__(attr_name: str) -> object:\n    if attr_name in _deprecated_dynamic_imports:\n        warn(\n            f'Importing {attr_name} from `pydantic` is deprecated. This feature is either no longer supported, or is not public.',\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    dynamic_attr = _dynamic_imports.get(attr_name)\n    if dynamic_attr is None:\n        return _getattr_migration(attr_name)\n\n    package, module_name = dynamic_attr\n\n    if module_name == '__module__':\n        result = import_module(f'.{attr_name}', package=package)\n        globals()[attr_name] = result\n        return result\n    else:\n        module = import_module(module_name, package=package)\n        result = getattr(module, attr_name)\n        g = globals()\n        for k, (_, v_module_name) in _dynamic_imports.items():\n            if v_module_name == module_name and k not in _deprecated_dynamic_imports:\n                g[k] = getattr(module, k)\n        return result\n\n\ndef __dir__() -> 'list[str]':\n    return list(__all__)\n\n\n--- File Index 1: _internal/__init__.py ---\n\n\n--- File Index 2: _internal/_config.py ---\nfrom __future__ import annotations as _annotations\n\nimport warnings\nfrom contextlib import contextmanager\nfrom re import Pattern\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    Literal,\n    cast,\n)\n\nfrom pydantic_core import core_schema\nfrom typing_extensions import Self\n\nfrom ..aliases import AliasGenerator\nfrom ..config import ConfigDict, ExtraValues, JsonDict, JsonEncoder, JsonSchemaExtraCallable\nfrom ..errors import PydanticUserError\nfrom ..warnings import PydanticDeprecatedSince20, PydanticDeprecatedSince210\n\nif not TYPE_CHECKING:\n    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915\n    # and https://youtrack.jetbrains.com/issue/PY-51428\n    DeprecationWarning = PydanticDeprecatedSince20\n\nif TYPE_CHECKING:\n    from .._internal._schema_generation_shared import GenerateSchema\n    from ..fields import ComputedFieldInfo, FieldInfo\n\nDEPRECATION_MESSAGE = 'Support for class-based `config` is deprecated, use ConfigDict instead.'\n\n\nclass ConfigWrapper:\n    \"\"\"Internal wrapper for Config which exposes ConfigDict items as attributes.\"\"\"\n\n    __slots__ = ('config_dict',)\n\n    config_dict: ConfigDict\n\n    # all annotations are copied directly from ConfigDict, and should be kept up to date, a test will fail if they\n    # stop matching\n    title: str | None\n    str_to_lower: bool\n    str_to_upper: bool\n    str_strip_whitespace: bool\n    str_min_length: int\n    str_max_length: int | None\n    extra: ExtraValues | None\n    frozen: bool\n    populate_by_name: bool\n    use_enum_values: bool\n    validate_assignment: bool\n    arbitrary_types_allowed: bool\n    from_attributes: bool\n    # whether to use the actual key provided in the data (e.g. alias or first alias for \"field required\" errors) instead of field_names\n    # to construct error `loc`s, default `True`\n    loc_by_alias: bool\n    alias_generator: Callable[[str], str] | AliasGenerator | None\n    model_title_generator: Callable[[type], str] | None\n    field_title_generator: Callable[[str, FieldInfo | ComputedFieldInfo], str] | None\n    ignored_types: tuple[type, ...]\n    allow_inf_nan: bool\n    json_schema_extra: JsonDict | JsonSchemaExtraCallable | None\n    json_encoders: dict[type[object], JsonEncoder] | None\n\n    # new in V2\n    strict: bool\n    # whether instances of models and dataclasses (including subclass instances) should re-validate, default 'never'\n    revalidate_instances: Literal['always', 'never', 'subclass-instances']\n    ser_json_timedelta: Literal['iso8601', 'float']\n    ser_json_bytes: Literal['utf8', 'base64', 'hex']\n    val_json_bytes: Literal['utf8', 'base64', 'hex']\n    ser_json_inf_nan: Literal['null', 'constants', 'strings']\n    # whether to validate default values during validation, default False\n    validate_default: bool\n    validate_return: bool\n    protected_namespaces: tuple[str | Pattern[str], ...]\n    hide_input_in_errors: bool\n    defer_build: bool\n    plugin_settings: dict[str, object] | None\n    schema_generator: type[GenerateSchema] | None\n    json_schema_serialization_defaults_required: bool\n    json_schema_mode_override: Literal['validation', 'serialization', None]\n    coerce_numbers_to_str: bool\n    regex_engine: Literal['rust-regex', 'python-re']\n    validation_error_cause: bool\n    use_attribute_docstrings: bool\n    cache_strings: bool | Literal['all', 'keys', 'none']\n    validate_by_alias: bool\n    validate_by_name: bool\n    serialize_by_alias: bool\n\n    def __init__(self, config: ConfigDict | dict[str, Any] | type[Any] | None, *, check: bool = True):\n        if check:\n            self.config_dict = prepare_config(config)\n        else:\n            self.config_dict = cast(ConfigDict, config)\n\n    @classmethod\n    def for_model(cls, bases: tuple[type[Any], ...], namespace: dict[str, Any], kwargs: dict[str, Any]) -> Self:\n        \"\"\"Build a new `ConfigWrapper` instance for a `BaseModel`.\n\n        The config wrapper built based on (in descending order of priority):\n        - options from `kwargs`\n        - options from the `namespace`\n        - options from the base classes (`bases`)\n\n        Args:\n            bases: A tuple of base classes.\n            namespace: The namespace of the class being created.\n            kwargs: The kwargs passed to the class being created.\n\n        Returns:\n            A `ConfigWrapper` instance for `BaseModel`.\n        \"\"\"\n        config_new = ConfigDict()\n        for base in bases:\n            config = getattr(base, 'model_config', None)\n            if config:\n                config_new.update(config.copy())\n\n        config_class_from_namespace = namespace.get('Config')\n        config_dict_from_namespace = namespace.get('model_config')\n\n        raw_annotations = namespace.get('__annotations__', {})\n        if raw_annotations.get('model_config') and config_dict_from_namespace is None:\n            raise PydanticUserError(\n                '`model_config` cannot be used as a model field name. Use `model_config` for model configuration.',\n                code='model-config-invalid-field-name',\n            )\n\n        if config_class_from_namespace and config_dict_from_namespace:\n            raise PydanticUserError('\"Config\" and \"model_config\" cannot be used together', code='config-both')\n\n        config_from_namespace = config_dict_from_namespace or prepare_config(config_class_from_namespace)\n\n        config_new.update(config_from_namespace)\n\n        for k in list(kwargs.keys()):\n            if k in config_keys:\n                config_new[k] = kwargs.pop(k)\n\n        return cls(config_new)\n\n    # we don't show `__getattr__` to type checkers so missing attributes cause errors\n    if not TYPE_CHECKING:  # pragma: no branch\n\n        def __getattr__(self, name: str) -> Any:\n            try:\n                return self.config_dict[name]\n            except KeyError:\n                try:\n                    return config_defaults[name]\n                except KeyError:\n                    raise AttributeError(f'Config has no attribute {name!r}') from None\n\n    def core_config(self, title: str | None) -> core_schema.CoreConfig:\n        \"\"\"Create a pydantic-core config.\n\n        We don't use getattr here since we don't want to populate with defaults.\n\n        Args:\n            title: The title to use if not set in config.\n\n        Returns:\n            A `CoreConfig` object created from config.\n        \"\"\"\n        config = self.config_dict\n\n        if config.get('schema_generator') is not None:\n            warnings.warn(\n                'The `schema_generator` setting has been deprecated since v2.10. This setting no longer has any effect.',\n                PydanticDeprecatedSince210,\n                stacklevel=2,\n            )\n\n        if (populate_by_name := config.get('populate_by_name')) is not None:\n            # We include this patch for backwards compatibility purposes, but this config setting will be deprecated in v3.0, and likely removed in v4.0.\n            # Thus, the above warning and this patch can be removed then as well.\n            if config.get('validate_by_name') is None:\n                config['validate_by_alias'] = True\n                config['validate_by_name'] = populate_by_name\n\n        # We dynamically patch validate_by_name to be True if validate_by_alias is set to False\n        # and validate_by_name is not explicitly set.\n        if config.get('validate_by_alias') is False and config.get('validate_by_name') is None:\n            config['validate_by_name'] = True\n\n        if (not config.get('validate_by_alias', True)) and (not config.get('validate_by_name', False)):\n            raise PydanticUserError(\n                'At least one of `validate_by_alias` or `validate_by_name` must be set to True.',\n                code='validate-by-alias-and-name-false',\n            )\n\n        return core_schema.CoreConfig(\n            **{  # pyright: ignore[reportArgumentType]\n                k: v\n                for k, v in (\n                    ('title', config.get('title') or title or None),\n                    ('extra_fields_behavior', config.get('extra')),\n                    ('allow_inf_nan', config.get('allow_inf_nan')),\n                    ('str_strip_whitespace', config.get('str_strip_whitespace')),\n                    ('str_to_lower', config.get('str_to_lower')),\n                    ('str_to_upper', config.get('str_to_upper')),\n                    ('strict', config.get('strict')),\n                    ('ser_json_timedelta', config.get('ser_json_timedelta')),\n                    ('ser_json_bytes', config.get('ser_json_bytes')),\n                    ('val_json_bytes', config.get('val_json_bytes')),\n                    ('ser_json_inf_nan', config.get('ser_json_inf_nan')),\n                    ('from_attributes', config.get('from_attributes')),\n                    ('loc_by_alias', config.get('loc_by_alias')),\n                    ('revalidate_instances', config.get('revalidate_instances')),\n                    ('validate_default', config.get('validate_default')),\n                    ('str_max_length', config.get('str_max_length')),\n                    ('str_min_length', config.get('str_min_length')),\n                    ('hide_input_in_errors', config.get('hide_input_in_errors')),\n                    ('coerce_numbers_to_str', config.get('coerce_numbers_to_str')),\n                    ('regex_engine', config.get('regex_engine')),\n                    ('validation_error_cause', config.get('validation_error_cause')),\n                    ('cache_strings', config.get('cache_strings')),\n                    ('validate_by_alias', config.get('validate_by_alias')),\n                    ('validate_by_name', config.get('validate_by_name')),\n                    ('serialize_by_alias', config.get('serialize_by_alias')),\n                )\n                if v is not None\n            }\n        )\n\n    def __repr__(self):\n        c = ', '.join(f'{k}={v!r}' for k, v in self.config_dict.items())\n        return f'ConfigWrapper({c})'\n\n\nclass ConfigWrapperStack:\n    \"\"\"A stack of `ConfigWrapper` instances.\"\"\"\n\n    def __init__(self, config_wrapper: ConfigWrapper):\n        self._config_wrapper_stack: list[ConfigWrapper] = [config_wrapper]\n\n    @property\n    def tail(self) -> ConfigWrapper:\n        return self._config_wrapper_stack[-1]\n\n    @contextmanager\n    def push(self, config_wrapper: ConfigWrapper | ConfigDict | None):\n        if config_wrapper is None:\n            yield\n            return\n\n        if not isinstance(config_wrapper, ConfigWrapper):\n            config_wrapper = ConfigWrapper(config_wrapper, check=False)\n\n        self._config_wrapper_stack.append(config_wrapper)\n        try:\n            yield\n        finally:\n            self._config_wrapper_stack.pop()\n\n\nconfig_defaults = ConfigDict(\n    title=None,\n    str_to_lower=False,\n    str_to_upper=False,\n    str_strip_whitespace=False,\n    str_min_length=0,\n    str_max_length=None,\n    # let the model / dataclass decide how to handle it\n    extra=None,\n    frozen=False,\n    populate_by_name=False,\n    use_enum_values=False,\n    validate_assignment=False,\n    arbitrary_types_allowed=False,\n    from_attributes=False,\n    loc_by_alias=True,\n    alias_generator=None,\n    model_title_generator=None,\n    field_title_generator=None,\n    ignored_types=(),\n    allow_inf_nan=True,\n    json_schema_extra=None,\n    strict=False,\n    revalidate_instances='never',\n    ser_json_timedelta='iso8601',\n    ser_json_bytes='utf8',\n    val_json_bytes='utf8',\n    ser_json_inf_nan='null',\n    validate_default=False,\n    validate_return=False,\n    protected_namespaces=('model_validate', 'model_dump'),\n    hide_input_in_errors=False,\n    json_encoders=None,\n    defer_build=False,\n    schema_generator=None,\n    plugin_settings=None,\n    json_schema_serialization_defaults_required=False,\n    json_schema_mode_override=None,\n    coerce_numbers_to_str=False,\n    regex_engine='rust-regex',\n    validation_error_cause=False,\n    use_attribute_docstrings=False,\n    cache_strings=True,\n    validate_by_alias=True,\n    validate_by_name=False,\n    serialize_by_alias=False,\n)\n\n\ndef prepare_config(config: ConfigDict | dict[str, Any] | type[Any] | None) -> ConfigDict:\n    \"\"\"Create a `ConfigDict` instance from an existing dict, a class (e.g. old class-based config) or None.\n\n    Args:\n        config: The input config.\n\n    Returns:\n        A ConfigDict object created from config.\n    \"\"\"\n    if config is None:\n        return ConfigDict()\n\n    if not isinstance(config, dict):\n        warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)\n        config = {k: getattr(config, k) for k in dir(config) if not k.startswith('__')}\n\n    config_dict = cast(ConfigDict, config)\n    check_deprecated(config_dict)\n    return config_dict\n\n\nconfig_keys = set(ConfigDict.__annotations__.keys())\n\n\nV2_REMOVED_KEYS = {\n    'allow_mutation',\n    'error_msg_templates',\n    'fields',\n    'getter_dict',\n    'smart_union',\n    'underscore_attrs_are_private',\n    'json_loads',\n    'json_dumps',\n    'copy_on_model_validation',\n    'post_init_call',\n}\nV2_RENAMED_KEYS = {\n    'allow_population_by_field_name': 'validate_by_name',\n    'anystr_lower': 'str_to_lower',\n    'anystr_strip_whitespace': 'str_strip_whitespace',\n    'anystr_upper': 'str_to_upper',\n    'keep_untouched': 'ignored_types',\n    'max_anystr_length': 'str_max_length',\n    'min_anystr_length': 'str_min_length',\n    'orm_mode': 'from_attributes',\n    'schema_extra': 'json_schema_extra',\n    'validate_all': 'validate_default',\n}\n\n\ndef check_deprecated(config_dict: ConfigDict) -> None:\n    \"\"\"Check for deprecated config keys and warn the user.\n\n    Args:\n        config_dict: The input config.\n    \"\"\"\n    deprecated_removed_keys = V2_REMOVED_KEYS & config_dict.keys()\n    deprecated_renamed_keys = V2_RENAMED_KEYS.keys() & config_dict.keys()\n    if deprecated_removed_keys or deprecated_renamed_keys:\n        renamings = {k: V2_RENAMED_KEYS[k] for k in sorted(deprecated_renamed_keys)}\n        renamed_bullets = [f'* {k!r} has been renamed to {v!r}' for k, v in renamings.items()]\n        removed_bullets = [f'* {k!r} has been removed' for k in sorted(deprecated_removed_keys)]\n        message = '\\n'.join(['Valid config keys have changed in V2:'] + renamed_bullets + removed_bullets)\n        warnings.warn(message, UserWarning)\n\n\n--- File Index 3: _internal/_core_metadata.py ---\nfrom __future__ import annotations as _annotations\n\nfrom typing import TYPE_CHECKING, Any, TypedDict, cast\nfrom warnings import warn\n\nif TYPE_CHECKING:\n    from ..config import JsonDict, JsonSchemaExtraCallable\n    from ._schema_generation_shared import (\n        GetJsonSchemaFunction,\n    )\n\n\nclass CoreMetadata(TypedDict, total=False):\n    \"\"\"A `TypedDict` for holding the metadata dict of the schema.\n\n    Attributes:\n        pydantic_js_functions: List of JSON schema functions that resolve refs during application.\n        pydantic_js_annotation_functions: List of JSON schema functions that don't resolve refs during application.\n        pydantic_js_prefer_positional_arguments: Whether JSON schema generator will\n            prefer positional over keyword arguments for an 'arguments' schema.\n            custom validation function. Only applies to before, plain, and wrap validators.\n        pydantic_js_updates: key / value pair updates to apply to the JSON schema for a type.\n        pydantic_js_extra: WIP, either key/value pair updates to apply to the JSON schema, or a custom callable.\n        pydantic_internal_union_tag_key: Used internally by the `Tag` metadata to specify the tag used for a discriminated union.\n        pydantic_internal_union_discriminator: Used internally to specify the discriminator value for a discriminated union\n            when the discriminator was applied to a `'definition-ref'` schema, and that reference was missing at the time\n            of the annotation application.\n\n    TODO: Perhaps we should move this structure to pydantic-core. At the moment, though,\n    it's easier to iterate on if we leave it in pydantic until we feel there is a semi-stable API.\n\n    TODO: It's unfortunate how functionally oriented JSON schema generation is, especially that which occurs during\n    the core schema generation process. It's inevitable that we need to store some json schema related information\n    on core schemas, given that we generate JSON schemas directly from core schemas. That being said, debugging related\n    issues is quite difficult when JSON schema information is disguised via dynamically defined functions.\n    \"\"\"\n\n    pydantic_js_functions: list[GetJsonSchemaFunction]\n    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n    pydantic_js_prefer_positional_arguments: bool\n    pydantic_js_updates: JsonDict\n    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable\n    pydantic_internal_union_tag_key: str\n    pydantic_internal_union_discriminator: str\n\n\ndef update_core_metadata(\n    core_metadata: Any,\n    /,\n    *,\n    pydantic_js_functions: list[GetJsonSchemaFunction] | None = None,\n    pydantic_js_annotation_functions: list[GetJsonSchemaFunction] | None = None,\n    pydantic_js_updates: JsonDict | None = None,\n    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable | None = None,\n) -> None:\n    from ..json_schema import PydanticJsonSchemaWarning\n\n    \"\"\"Update CoreMetadata instance in place. When we make modifications in this function, they\n    take effect on the `core_metadata` reference passed in as the first (and only) positional argument.\n\n    First, cast to `CoreMetadata`, then finish with a cast to `dict[str, Any]` for core schema compatibility.\n    We do this here, instead of before / after each call to this function so that this typing hack\n    can be easily removed if/when we move `CoreMetadata` to `pydantic-core`.\n\n    For parameter descriptions, see `CoreMetadata` above.\n    \"\"\"\n    core_metadata = cast(CoreMetadata, core_metadata)\n\n    if pydantic_js_functions:\n        core_metadata.setdefault('pydantic_js_functions', []).extend(pydantic_js_functions)\n\n    if pydantic_js_annotation_functions:\n        core_metadata.setdefault('pydantic_js_annotation_functions', []).extend(pydantic_js_annotation_functions)\n\n    if pydantic_js_updates:\n        if (existing_updates := core_metadata.get('pydantic_js_updates')) is not None:\n            core_metadata['pydantic_js_updates'] = {**existing_updates, **pydantic_js_updates}\n        else:\n            core_metadata['pydantic_js_updates'] = pydantic_js_updates\n\n    if pydantic_js_extra is not None:\n        existing_pydantic_js_extra = core_metadata.get('pydantic_js_extra')\n        if existing_pydantic_js_extra is None:\n            core_metadata['pydantic_js_extra'] = pydantic_js_extra\n        if isinstance(existing_pydantic_js_extra, dict):\n            if isinstance(pydantic_js_extra, dict):\n                core_metadata['pydantic_js_extra'] = {**existing_pydantic_js_extra, **pydantic_js_extra}\n            if callable(pydantic_js_extra):\n                warn(\n                    'Composing `dict` and `callable` type `json_schema_extra` is not supported.'\n                    'The `callable` type is being ignored.'\n                    \"If you'd like support for this behavior, please open an issue on pydantic.\",\n                    PydanticJsonSchemaWarning,\n                )\n        if callable(existing_pydantic_js_extra):\n            # if ever there's a case of a callable, we'll just keep the last json schema extra spec\n            core_metadata['pydantic_js_extra'] = pydantic_js_extra\n\n\n--- File Index 4: _internal/_core_utils.py ---\nfrom __future__ import annotations\n\nimport inspect\nimport os\nfrom collections.abc import Mapping, Sequence\nfrom typing import TYPE_CHECKING, Any, Union\n\nfrom pydantic_core import CoreSchema, core_schema\nfrom pydantic_core import validate_core_schema as _validate_core_schema\nfrom typing_extensions import TypeGuard, get_args, get_origin\nfrom typing_inspection import typing_objects\n\nfrom . import _repr\nfrom ._typing_extra import is_generic_alias\n\nif TYPE_CHECKING:\n    from rich.console import Console\n\nAnyFunctionSchema = Union[\n    core_schema.AfterValidatorFunctionSchema,\n    core_schema.BeforeValidatorFunctionSchema,\n    core_schema.WrapValidatorFunctionSchema,\n    core_schema.PlainValidatorFunctionSchema,\n]\n\n\nFunctionSchemaWithInnerSchema = Union[\n    core_schema.AfterValidatorFunctionSchema,\n    core_schema.BeforeValidatorFunctionSchema,\n    core_schema.WrapValidatorFunctionSchema,\n]\n\nCoreSchemaField = Union[\n    core_schema.ModelField, core_schema.DataclassField, core_schema.TypedDictField, core_schema.ComputedField\n]\nCoreSchemaOrField = Union[core_schema.CoreSchema, CoreSchemaField]\n\n_CORE_SCHEMA_FIELD_TYPES = {'typed-dict-field', 'dataclass-field', 'model-field', 'computed-field'}\n_FUNCTION_WITH_INNER_SCHEMA_TYPES = {'function-before', 'function-after', 'function-wrap'}\n_LIST_LIKE_SCHEMA_WITH_ITEMS_TYPES = {'list', 'set', 'frozenset'}\n\n\ndef is_core_schema(\n    schema: CoreSchemaOrField,\n) -> TypeGuard[CoreSchema]:\n    return schema['type'] not in _CORE_SCHEMA_FIELD_TYPES\n\n\ndef is_core_schema_field(\n    schema: CoreSchemaOrField,\n) -> TypeGuard[CoreSchemaField]:\n    return schema['type'] in _CORE_SCHEMA_FIELD_TYPES\n\n\ndef is_function_with_inner_schema(\n    schema: CoreSchemaOrField,\n) -> TypeGuard[FunctionSchemaWithInnerSchema]:\n    return schema['type'] in _FUNCTION_WITH_INNER_SCHEMA_TYPES\n\n\ndef is_list_like_schema_with_items_schema(\n    schema: CoreSchema,\n) -> TypeGuard[core_schema.ListSchema | core_schema.SetSchema | core_schema.FrozenSetSchema]:\n    return schema['type'] in _LIST_LIKE_SCHEMA_WITH_ITEMS_TYPES\n\n\ndef get_type_ref(type_: Any, args_override: tuple[type[Any], ...] | None = None) -> str:\n    \"\"\"Produces the ref to be used for this type by pydantic_core's core schemas.\n\n    This `args_override` argument was added for the purpose of creating valid recursive references\n    when creating generic models without needing to create a concrete class.\n    \"\"\"\n    origin = get_origin(type_) or type_\n\n    args = get_args(type_) if is_generic_alias(type_) else (args_override or ())\n    generic_metadata = getattr(type_, '__pydantic_generic_metadata__', None)\n    if generic_metadata:\n        origin = generic_metadata['origin'] or origin\n        args = generic_metadata['args'] or args\n\n    module_name = getattr(origin, '__module__', '<No __module__>')\n    if typing_objects.is_typealiastype(origin):\n        type_ref = f'{module_name}.{origin.__name__}:{id(origin)}'\n    else:\n        try:\n            qualname = getattr(origin, '__qualname__', f'<No __qualname__: {origin}>')\n        except Exception:\n            qualname = getattr(origin, '__qualname__', '<No __qualname__>')\n        type_ref = f'{module_name}.{qualname}:{id(origin)}'\n\n    arg_refs: list[str] = []\n    for arg in args:\n        if isinstance(arg, str):\n            # Handle string literals as a special case; we may be able to remove this special handling if we\n            # wrap them in a ForwardRef at some point.\n            arg_ref = f'{arg}:str-{id(arg)}'\n        else:\n            arg_ref = f'{_repr.display_as_type(arg)}:{id(arg)}'\n        arg_refs.append(arg_ref)\n    if arg_refs:\n        type_ref = f'{type_ref}[{\",\".join(arg_refs)}]'\n    return type_ref\n\n\ndef get_ref(s: core_schema.CoreSchema) -> None | str:\n    \"\"\"Get the ref from the schema if it has one.\n    This exists just for type checking to work correctly.\n    \"\"\"\n    return s.get('ref', None)\n\n\ndef validate_core_schema(schema: CoreSchema) -> CoreSchema:\n    if os.getenv('PYDANTIC_VALIDATE_CORE_SCHEMAS'):\n        return _validate_core_schema(schema)\n    return schema\n\n\ndef _clean_schema_for_pretty_print(obj: Any, strip_metadata: bool = True) -> Any:  # pragma: no cover\n    \"\"\"A utility function to remove irrelevant information from a core schema.\"\"\"\n    if isinstance(obj, Mapping):\n        new_dct = {}\n        for k, v in obj.items():\n            if k == 'metadata' and strip_metadata:\n                new_metadata = {}\n\n                for meta_k, meta_v in v.items():\n                    if meta_k in ('pydantic_js_functions', 'pydantic_js_annotation_functions'):\n                        new_metadata['js_metadata'] = '<stripped>'\n                    else:\n                        new_metadata[meta_k] = _clean_schema_for_pretty_print(meta_v, strip_metadata=strip_metadata)\n\n                if list(new_metadata.keys()) == ['js_metadata']:\n                    new_metadata = {'<stripped>'}\n\n                new_dct[k] = new_metadata\n            # Remove some defaults:\n            elif k in ('custom_init', 'root_model') and not v:\n                continue\n            else:\n                new_dct[k] = _clean_schema_for_pretty_print(v, strip_metadata=strip_metadata)\n\n        return new_dct\n    elif isinstance(obj, Sequence) and not isinstance(obj, str):\n        return [_clean_schema_for_pretty_print(v, strip_metadata=strip_metadata) for v in obj]\n    else:\n        return obj\n\n\ndef pretty_print_core_schema(\n    val: Any,\n    *,\n    console: Console | None = None,\n    max_depth: int | None = None,\n    strip_metadata: bool = True,\n) -> None:  # pragma: no cover\n    \"\"\"Pretty-print a core schema using the `rich` library.\n\n    Args:\n        val: The core schema to print, or a Pydantic model/dataclass/type adapter\n            (in which case the cached core schema is fetched and printed).\n        console: A rich console to use when printing. Defaults to the global rich console instance.\n        max_depth: The number of nesting levels which may be printed.\n        strip_metadata: Whether to strip metadata in the output. If `True` any known core metadata\n            attributes will be stripped (but custom attributes are kept). Defaults to `True`.\n    \"\"\"\n    # lazy import:\n    from rich.pretty import pprint\n\n    # circ. imports:\n    from pydantic import BaseModel, TypeAdapter\n    from pydantic.dataclasses import is_pydantic_dataclass\n\n    if (inspect.isclass(val) and issubclass(val, BaseModel)) or is_pydantic_dataclass(val):\n        val = val.__pydantic_core_schema__\n    if isinstance(val, TypeAdapter):\n        val = val.core_schema\n    cleaned_schema = _clean_schema_for_pretty_print(val, strip_metadata=strip_metadata)\n\n    pprint(cleaned_schema, console=console, max_depth=max_depth)\n\n\npps = pretty_print_core_schema\n\n\n--- File Index 5: _internal/_dataclasses.py ---\n\"\"\"Private logic for creating pydantic dataclasses.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport dataclasses\nimport typing\nimport warnings\nfrom functools import partial, wraps\nfrom typing import Any, ClassVar\n\nfrom pydantic_core import (\n    ArgsKwargs,\n    SchemaSerializer,\n    SchemaValidator,\n    core_schema,\n)\nfrom typing_extensions import TypeGuard\n\nfrom ..errors import PydanticUndefinedAnnotation\nfrom ..plugin._schema_validator import PluggableSchemaValidator, create_schema_validator\nfrom ..warnings import PydanticDeprecatedSince20\nfrom . import _config, _decorators\nfrom ._fields import collect_dataclass_fields\nfrom ._generate_schema import GenerateSchema, InvalidSchemaError\nfrom ._generics import get_standard_typevars_map\nfrom ._mock_val_ser import set_dataclass_mocks\nfrom ._namespace_utils import NsResolver\nfrom ._signature import generate_pydantic_signature\nfrom ._utils import LazyClassAttribute\n\nif typing.TYPE_CHECKING:\n    from _typeshed import DataclassInstance as StandardDataclass\n\n    from ..config import ConfigDict\n    from ..fields import FieldInfo\n\n    class PydanticDataclass(StandardDataclass, typing.Protocol):\n        \"\"\"A protocol containing attributes only available once a class has been decorated as a Pydantic dataclass.\n\n        Attributes:\n            __pydantic_config__: Pydantic-specific configuration settings for the dataclass.\n            __pydantic_complete__: Whether dataclass building is completed, or if there are still undefined fields.\n            __pydantic_core_schema__: The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\n            __pydantic_decorators__: Metadata containing the decorators defined on the dataclass.\n            __pydantic_fields__: Metadata about the fields defined on the dataclass.\n            __pydantic_serializer__: The pydantic-core SchemaSerializer used to dump instances of the dataclass.\n            __pydantic_validator__: The pydantic-core SchemaValidator used to validate instances of the dataclass.\n        \"\"\"\n\n        __pydantic_config__: ClassVar[ConfigDict]\n        __pydantic_complete__: ClassVar[bool]\n        __pydantic_core_schema__: ClassVar[core_schema.CoreSchema]\n        __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos]\n        __pydantic_fields__: ClassVar[dict[str, FieldInfo]]\n        __pydantic_serializer__: ClassVar[SchemaSerializer]\n        __pydantic_validator__: ClassVar[SchemaValidator | PluggableSchemaValidator]\n\nelse:\n    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915\n    # and https://youtrack.jetbrains.com/issue/PY-51428\n    DeprecationWarning = PydanticDeprecatedSince20\n\n\ndef set_dataclass_fields(\n    cls: type[StandardDataclass],\n    ns_resolver: NsResolver | None = None,\n    config_wrapper: _config.ConfigWrapper | None = None,\n) -> None:\n    \"\"\"Collect and set `cls.__pydantic_fields__`.\n\n    Args:\n        cls: The class.\n        ns_resolver: Namespace resolver to use when getting dataclass annotations.\n        config_wrapper: The config wrapper instance, defaults to `None`.\n    \"\"\"\n    typevars_map = get_standard_typevars_map(cls)\n    fields = collect_dataclass_fields(\n        cls, ns_resolver=ns_resolver, typevars_map=typevars_map, config_wrapper=config_wrapper\n    )\n\n    cls.__pydantic_fields__ = fields  # type: ignore\n\n\ndef complete_dataclass(\n    cls: type[Any],\n    config_wrapper: _config.ConfigWrapper,\n    *,\n    raise_errors: bool = True,\n    ns_resolver: NsResolver | None = None,\n    _force_build: bool = False,\n) -> bool:\n    \"\"\"Finish building a pydantic dataclass.\n\n    This logic is called on a class which has already been wrapped in `dataclasses.dataclass()`.\n\n    This is somewhat analogous to `pydantic._internal._model_construction.complete_model_class`.\n\n    Args:\n        cls: The class.\n        config_wrapper: The config wrapper instance.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        ns_resolver: The namespace resolver instance to use when collecting dataclass fields\n            and during schema building.\n        _force_build: Whether to force building the dataclass, no matter if\n            [`defer_build`][pydantic.config.ConfigDict.defer_build] is set.\n\n    Returns:\n        `True` if building a pydantic dataclass is successfully completed, `False` otherwise.\n\n    Raises:\n        PydanticUndefinedAnnotation: If `raise_error` is `True` and there is an undefined annotations.\n    \"\"\"\n    original_init = cls.__init__\n\n    # dataclass.__init__ must be defined here so its `__qualname__` can be changed since functions can't be copied,\n    # and so that the mock validator is used if building was deferred:\n    def __init__(__dataclass_self__: PydanticDataclass, *args: Any, **kwargs: Any) -> None:\n        __tracebackhide__ = True\n        s = __dataclass_self__\n        s.__pydantic_validator__.validate_python(ArgsKwargs(args, kwargs), self_instance=s)\n\n    __init__.__qualname__ = f'{cls.__qualname__}.__init__'\n\n    cls.__init__ = __init__  # type: ignore\n    cls.__pydantic_config__ = config_wrapper.config_dict  # type: ignore\n\n    set_dataclass_fields(cls, ns_resolver, config_wrapper=config_wrapper)\n\n    if not _force_build and config_wrapper.defer_build:\n        set_dataclass_mocks(cls)\n        return False\n\n    if hasattr(cls, '__post_init_post_parse__'):\n        warnings.warn(\n            'Support for `__post_init_post_parse__` has been dropped, the method will not be called', DeprecationWarning\n        )\n\n    typevars_map = get_standard_typevars_map(cls)\n    gen_schema = GenerateSchema(\n        config_wrapper,\n        ns_resolver=ns_resolver,\n        typevars_map=typevars_map,\n    )\n\n    # set __signature__ attr only for the class, but not for its instances\n    # (because instances can define `__call__`, and `inspect.signature` shouldn't\n    # use the `__signature__` attribute and instead generate from `__call__`).\n    cls.__signature__ = LazyClassAttribute(\n        '__signature__',\n        partial(\n            generate_pydantic_signature,\n            # It's important that we reference the `original_init` here,\n            # as it is the one synthesized by the stdlib `dataclass` module:\n            init=original_init,\n            fields=cls.__pydantic_fields__,  # type: ignore\n            validate_by_name=config_wrapper.validate_by_name,\n            extra=config_wrapper.extra,\n            is_dataclass=True,\n        ),\n    )\n\n    try:\n        schema = gen_schema.generate_schema(cls)\n    except PydanticUndefinedAnnotation as e:\n        if raise_errors:\n            raise\n        set_dataclass_mocks(cls, f'`{e.name}`')\n        return False\n\n    core_config = config_wrapper.core_config(title=cls.__name__)\n\n    try:\n        schema = gen_schema.clean_schema(schema)\n    except InvalidSchemaError:\n        set_dataclass_mocks(cls)\n        return False\n\n    # We are about to set all the remaining required properties expected for this cast;\n    # __pydantic_decorators__ and __pydantic_fields__ should already be set\n    cls = typing.cast('type[PydanticDataclass]', cls)\n    # debug(schema)\n\n    cls.__pydantic_core_schema__ = schema\n    cls.__pydantic_validator__ = validator = create_schema_validator(\n        schema, cls, cls.__module__, cls.__qualname__, 'dataclass', core_config, config_wrapper.plugin_settings\n    )\n    cls.__pydantic_serializer__ = SchemaSerializer(schema, core_config)\n\n    if config_wrapper.validate_assignment:\n\n        @wraps(cls.__setattr__)\n        def validated_setattr(instance: Any, field: str, value: str, /) -> None:\n            validator.validate_assignment(instance, field, value)\n\n        cls.__setattr__ = validated_setattr.__get__(None, cls)  # type: ignore\n\n    cls.__pydantic_complete__ = True\n    return True\n\n\ndef is_builtin_dataclass(_cls: type[Any]) -> TypeGuard[type[StandardDataclass]]:\n    \"\"\"Returns True if a class is a stdlib dataclass and *not* a pydantic dataclass.\n\n    We check that\n    - `_cls` is a dataclass\n    - `_cls` does not inherit from a processed pydantic dataclass (and thus have a `__pydantic_validator__`)\n    - `_cls` does not have any annotations that are not dataclass fields\n    e.g.\n    ```python\n    import dataclasses\n\n    import pydantic.dataclasses\n\n    @dataclasses.dataclass\n    class A:\n        x: int\n\n    @pydantic.dataclasses.dataclass\n    class B(A):\n        y: int\n    ```\n    In this case, when we first check `B`, we make an extra check and look at the annotations ('y'),\n    which won't be a superset of all the dataclass fields (only the stdlib fields i.e. 'x')\n\n    Args:\n        cls: The class.\n\n    Returns:\n        `True` if the class is a stdlib dataclass, `False` otherwise.\n    \"\"\"\n    return (\n        dataclasses.is_dataclass(_cls)\n        and not hasattr(_cls, '__pydantic_validator__')\n        and set(_cls.__dataclass_fields__).issuperset(set(getattr(_cls, '__annotations__', {})))\n    )\n\n\n--- File Index 6: _internal/_decorators.py ---\n\"\"\"Logic related to validators applied to models etc. via the `@field_validator` and `@model_validator` decorators.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport types\nfrom collections import deque\nfrom collections.abc import Iterable\nfrom dataclasses import dataclass, field\nfrom functools import cached_property, partial, partialmethod\nfrom inspect import Parameter, Signature, isdatadescriptor, ismethoddescriptor, signature\nfrom itertools import islice\nfrom typing import TYPE_CHECKING, Any, Callable, ClassVar, Generic, Literal, TypeVar, Union\n\nfrom pydantic_core import PydanticUndefined, PydanticUndefinedType, core_schema\nfrom typing_extensions import TypeAlias, is_typeddict\n\nfrom ..errors import PydanticUserError\nfrom ._core_utils import get_type_ref\nfrom ._internal_dataclass import slots_true\nfrom ._namespace_utils import GlobalsNamespace, MappingNamespace\nfrom ._typing_extra import get_function_type_hints\nfrom ._utils import can_be_positional\n\nif TYPE_CHECKING:\n    from ..fields import ComputedFieldInfo\n    from ..functional_validators import FieldValidatorModes\n\n\n@dataclass(**slots_true)\nclass ValidatorDecoratorInfo:\n    \"\"\"A container for data from `@validator` so that we can access it\n    while building the pydantic-core schema.\n\n    Attributes:\n        decorator_repr: A class variable representing the decorator string, '@validator'.\n        fields: A tuple of field names the validator should be called on.\n        mode: The proposed validator mode.\n        each_item: For complex objects (sets, lists etc.) whether to validate individual\n            elements rather than the whole object.\n        always: Whether this method and other validators should be called even if the value is missing.\n        check_fields: Whether to check that the fields actually exist on the model.\n    \"\"\"\n\n    decorator_repr: ClassVar[str] = '@validator'\n\n    fields: tuple[str, ...]\n    mode: Literal['before', 'after']\n    each_item: bool\n    always: bool\n    check_fields: bool | None\n\n\n@dataclass(**slots_true)\nclass FieldValidatorDecoratorInfo:\n    \"\"\"A container for data from `@field_validator` so that we can access it\n    while building the pydantic-core schema.\n\n    Attributes:\n        decorator_repr: A class variable representing the decorator string, '@field_validator'.\n        fields: A tuple of field names the validator should be called on.\n        mode: The proposed validator mode.\n        check_fields: Whether to check that the fields actually exist on the model.\n        json_schema_input_type: The input type of the function. This is only used to generate\n            the appropriate JSON Schema (in validation mode) and can only specified\n            when `mode` is either `'before'`, `'plain'` or `'wrap'`.\n    \"\"\"\n\n    decorator_repr: ClassVar[str] = '@field_validator'\n\n    fields: tuple[str, ...]\n    mode: FieldValidatorModes\n    check_fields: bool | None\n    json_schema_input_type: Any\n\n\n@dataclass(**slots_true)\nclass RootValidatorDecoratorInfo:\n    \"\"\"A container for data from `@root_validator` so that we can access it\n    while building the pydantic-core schema.\n\n    Attributes:\n        decorator_repr: A class variable representing the decorator string, '@root_validator'.\n        mode: The proposed validator mode.\n    \"\"\"\n\n    decorator_repr: ClassVar[str] = '@root_validator'\n    mode: Literal['before', 'after']\n\n\n@dataclass(**slots_true)\nclass FieldSerializerDecoratorInfo:\n    \"\"\"A container for data from `@field_serializer` so that we can access it\n    while building the pydantic-core schema.\n\n    Attributes:\n        decorator_repr: A class variable representing the decorator string, '@field_serializer'.\n        fields: A tuple of field names the serializer should be called on.\n        mode: The proposed serializer mode.\n        return_type: The type of the serializer's return value.\n        when_used: The serialization condition. Accepts a string with values `'always'`, `'unless-none'`, `'json'`,\n            and `'json-unless-none'`.\n        check_fields: Whether to check that the fields actually exist on the model.\n    \"\"\"\n\n    decorator_repr: ClassVar[str] = '@field_serializer'\n    fields: tuple[str, ...]\n    mode: Literal['plain', 'wrap']\n    return_type: Any\n    when_used: core_schema.WhenUsed\n    check_fields: bool | None\n\n\n@dataclass(**slots_true)\nclass ModelSerializerDecoratorInfo:\n    \"\"\"A container for data from `@model_serializer` so that we can access it\n    while building the pydantic-core schema.\n\n    Attributes:\n        decorator_repr: A class variable representing the decorator string, '@model_serializer'.\n        mode: The proposed serializer mode.\n        return_type: The type of the serializer's return value.\n        when_used: The serialization condition. Accepts a string with values `'always'`, `'unless-none'`, `'json'`,\n            and `'json-unless-none'`.\n    \"\"\"\n\n    decorator_repr: ClassVar[str] = '@model_serializer'\n    mode: Literal['plain', 'wrap']\n    return_type: Any\n    when_used: core_schema.WhenUsed\n\n\n@dataclass(**slots_true)\nclass ModelValidatorDecoratorInfo:\n    \"\"\"A container for data from `@model_validator` so that we can access it\n    while building the pydantic-core schema.\n\n    Attributes:\n        decorator_repr: A class variable representing the decorator string, '@model_validator'.\n        mode: The proposed serializer mode.\n    \"\"\"\n\n    decorator_repr: ClassVar[str] = '@model_validator'\n    mode: Literal['wrap', 'before', 'after']\n\n\nDecoratorInfo: TypeAlias = \"\"\"Union[\n    ValidatorDecoratorInfo,\n    FieldValidatorDecoratorInfo,\n    RootValidatorDecoratorInfo,\n    FieldSerializerDecoratorInfo,\n    ModelSerializerDecoratorInfo,\n    ModelValidatorDecoratorInfo,\n    ComputedFieldInfo,\n]\"\"\"\n\nReturnType = TypeVar('ReturnType')\nDecoratedType: TypeAlias = (\n    'Union[classmethod[Any, Any, ReturnType], staticmethod[Any, ReturnType], Callable[..., ReturnType], property]'\n)\n\n\n@dataclass  # can't use slots here since we set attributes on `__post_init__`\nclass PydanticDescriptorProxy(Generic[ReturnType]):\n    \"\"\"Wrap a classmethod, staticmethod, property or unbound function\n    and act as a descriptor that allows us to detect decorated items\n    from the class' attributes.\n\n    This class' __get__ returns the wrapped item's __get__ result,\n    which makes it transparent for classmethods and staticmethods.\n\n    Attributes:\n        wrapped: The decorator that has to be wrapped.\n        decorator_info: The decorator info.\n        shim: A wrapper function to wrap V1 style function.\n    \"\"\"\n\n    wrapped: DecoratedType[ReturnType]\n    decorator_info: DecoratorInfo\n    shim: Callable[[Callable[..., Any]], Callable[..., Any]] | None = None\n\n    def __post_init__(self):\n        for attr in 'setter', 'deleter':\n            if hasattr(self.wrapped, attr):\n                f = partial(self._call_wrapped_attr, name=attr)\n                setattr(self, attr, f)\n\n    def _call_wrapped_attr(self, func: Callable[[Any], None], *, name: str) -> PydanticDescriptorProxy[ReturnType]:\n        self.wrapped = getattr(self.wrapped, name)(func)\n        if isinstance(self.wrapped, property):\n            # update ComputedFieldInfo.wrapped_property\n            from ..fields import ComputedFieldInfo\n\n            if isinstance(self.decorator_info, ComputedFieldInfo):\n                self.decorator_info.wrapped_property = self.wrapped\n        return self\n\n    def __get__(self, obj: object | None, obj_type: type[object] | None = None) -> PydanticDescriptorProxy[ReturnType]:\n        try:\n            return self.wrapped.__get__(obj, obj_type)\n        except AttributeError:\n            # not a descriptor, e.g. a partial object\n            return self.wrapped  # type: ignore[return-value]\n\n    def __set_name__(self, instance: Any, name: str) -> None:\n        if hasattr(self.wrapped, '__set_name__'):\n            self.wrapped.__set_name__(instance, name)  # pyright: ignore[reportFunctionMemberAccess]\n\n    def __getattr__(self, name: str, /) -> Any:\n        \"\"\"Forward checks for __isabstractmethod__ and such.\"\"\"\n        return getattr(self.wrapped, name)\n\n\nDecoratorInfoType = TypeVar('DecoratorInfoType', bound=DecoratorInfo)\n\n\n@dataclass(**slots_true)\nclass Decorator(Generic[DecoratorInfoType]):\n    \"\"\"A generic container class to join together the decorator metadata\n    (metadata from decorator itself, which we have when the\n    decorator is called but not when we are building the core-schema)\n    and the bound function (which we have after the class itself is created).\n\n    Attributes:\n        cls_ref: The class ref.\n        cls_var_name: The decorated function name.\n        func: The decorated function.\n        shim: A wrapper function to wrap V1 style function.\n        info: The decorator info.\n    \"\"\"\n\n    cls_ref: str\n    cls_var_name: str\n    func: Callable[..., Any]\n    shim: Callable[[Any], Any] | None\n    info: DecoratorInfoType\n\n    @staticmethod\n    def build(\n        cls_: Any,\n        *,\n        cls_var_name: str,\n        shim: Callable[[Any], Any] | None,\n        info: DecoratorInfoType,\n    ) -> Decorator[DecoratorInfoType]:\n        \"\"\"Build a new decorator.\n\n        Args:\n            cls_: The class.\n            cls_var_name: The decorated function name.\n            shim: A wrapper function to wrap V1 style function.\n            info: The decorator info.\n\n        Returns:\n            The new decorator instance.\n        \"\"\"\n        func = get_attribute_from_bases(cls_, cls_var_name)\n        if shim is not None:\n            func = shim(func)\n        func = unwrap_wrapped_function(func, unwrap_partial=False)\n        if not callable(func):\n            # This branch will get hit for classmethod properties\n            attribute = get_attribute_from_base_dicts(cls_, cls_var_name)  # prevents the binding call to `__get__`\n            if isinstance(attribute, PydanticDescriptorProxy):\n                func = unwrap_wrapped_function(attribute.wrapped)\n        return Decorator(\n            cls_ref=get_type_ref(cls_),\n            cls_var_name=cls_var_name,\n            func=func,\n            shim=shim,\n            info=info,\n        )\n\n    def bind_to_cls(self, cls: Any) -> Decorator[DecoratorInfoType]:\n        \"\"\"Bind the decorator to a class.\n\n        Args:\n            cls: the class.\n\n        Returns:\n            The new decorator instance.\n        \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,\n            info=self.info,\n        )\n\n\ndef get_bases(tp: type[Any]) -> tuple[type[Any], ...]:\n    \"\"\"Get the base classes of a class or typeddict.\n\n    Args:\n        tp: The type or class to get the bases.\n\n    Returns:\n        The base classes.\n    \"\"\"\n    if is_typeddict(tp):\n        return tp.__orig_bases__  # type: ignore\n    try:\n        return tp.__bases__\n    except AttributeError:\n        return ()\n\n\ndef mro(tp: type[Any]) -> tuple[type[Any], ...]:\n    \"\"\"Calculate the Method Resolution Order of bases using the C3 algorithm.\n\n    See https://www.python.org/download/releases/2.3/mro/\n    \"\"\"\n    # try to use the existing mro, for performance mainly\n    # but also because it helps verify the implementation below\n    if not is_typeddict(tp):\n        try:\n            return tp.__mro__\n        except AttributeError:\n            # GenericAlias and some other cases\n            pass\n\n    bases = get_bases(tp)\n    return (tp,) + mro_for_bases(bases)\n\n\ndef mro_for_bases(bases: tuple[type[Any], ...]) -> tuple[type[Any], ...]:\n    def merge_seqs(seqs: list[deque[type[Any]]]) -> Iterable[type[Any]]:\n        while True:\n            non_empty = [seq for seq in seqs if seq]\n            if not non_empty:\n                # Nothing left to process, we're done.\n                return\n            candidate: type[Any] | None = None\n            for seq in non_empty:  # Find merge candidates among seq heads.\n                candidate = seq[0]\n                not_head = [s for s in non_empty if candidate in islice(s, 1, None)]\n                if not_head:\n                    # Reject the candidate.\n                    candidate = None\n                else:\n                    break\n            if not candidate:\n                raise TypeError('Inconsistent hierarchy, no C3 MRO is possible')\n            yield candidate\n            for seq in non_empty:\n                # Remove candidate.\n                if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribute_from_bases(tp: type[Any] | tuple[type[Any], ...], name: str) -> Any:\n    \"\"\"Get the attribute from the next class in the MRO that has it,\n    aiming to simulate calling the method on the actual class.\n\n    The reason for iterating over the mro instead of just getting\n    the attribute (which would do that for us) is to support TypedDict,\n    which lacks a real __mro__, but can have a virtual one constructed\n    from its bases (as done here).\n\n    Args:\n        tp: The type or class to search for the attribute. If a tuple, this is treated as a set of base classes.\n        name: The name of the attribute to retrieve.\n\n    Returns:\n        Any: The attribute value, if found.\n\n    Raises:\n        AttributeError: If the attribute is not found in any class in the MRO.\n    \"\"\"\n    if isinstance(tp, tuple):\n        for base in mro_for_bases(tp):\n            attribute = base.__dict__.get(name, _sentinel)\n            if attribute is not _sentinel:\n                attribute_get = getattr(attribute, '__get__', None)\n                if attribute_get is not None:\n                    return attribute_get(None, tp)\n                return attribute\n        raise AttributeError(f'{name} not found in {tp}')\n    else:\n        try:\n            return getattr(tp, name)\n        except AttributeError:\n            return get_attribute_from_bases(mro(tp), name)\n\n\ndef get_attribute_from_base_dicts(tp: type[Any], name: str) -> Any:\n    \"\"\"Get an attribute out of the `__dict__` following the MRO.\n    This prevents the call to `__get__` on the descriptor, and allows\n    us to get the original function for classmethod properties.\n\n    Args:\n        tp: The type or class to search for the attribute.\n        name: The name of the attribute to retrieve.\n\n    Returns:\n        Any: The attribute value, if found.\n\n    Raises:\n        KeyError: If the attribute is not found in any class's `__dict__` in the MRO.\n    \"\"\"\n    for base in reversed(mro(tp)):\n        if name in base.__dict__:\n            return base.__dict__[name]\n    return tp.__dict__[name]  # raise the error\n\n\n@dataclass(**slots_true)\nclass DecoratorInfos:\n    \"\"\"Mapping of name in the class namespace to decorator info.\n\n    note that the name in the class namespace is the function or attribute name\n    not the field name!\n    \"\"\"\n\n    validators: dict[str, Decorator[ValidatorDecoratorInfo]] = field(default_factory=dict)\n    field_validators: dict[str, Decorator[FieldValidatorDecoratorInfo]] = field(default_factory=dict)\n    root_validators: dict[str, Decorator[RootValidatorDecoratorInfo]] = field(default_factory=dict)\n    field_serializers: dict[str, Decorator[FieldSerializerDecoratorInfo]] = field(default_factory=dict)\n    model_serializers: dict[str, Decorator[ModelSerializerDecoratorInfo]] = field(default_factory=dict)\n    model_validators: dict[str, Decorator[ModelValidatorDecoratorInfo]] = field(default_factory=dict)\n    computed_fields: dict[str, Decorator[ComputedFieldInfo]] = field(default_factory=dict)\n\n    @staticmethod\n    def build(model_dc: type[Any]) -> DecoratorInfos:  # noqa: C901 (ignore complexity)\n        \"\"\"We want to collect all DecFunc instances that exist as\n        attributes in the namespace of the class (a BaseModel or dataclass)\n        that called us\n        But we want to collect these in the order of the bases\n        So instead of getting them all from the leaf class (the class that called us),\n        we traverse the bases from root (the oldest ancestor class) to leaf\n        and collect all of the instances as we go, taking care to replace\n        any duplicate ones with the last one we see to mimic how function overriding\n        works with inheritance.\n        If we do replace any functions we put the replacement into the position\n        the replaced function was in; that is, we maintain the order.\n        \"\"\"\n        # reminder: dicts are ordered and replacement does not alter the order\n        res = DecoratorInfos()\n        for base in reversed(mro(model_dc)[1:]):\n            existing: DecoratorInfos | None = base.__dict__.get('__pydantic_decorators__')\n            if existing is None:\n                existing = DecoratorInfos.build(base)\n            res.validators.update({k: v.bind_to_cls(model_dc) for k, v in existing.validators.items()})\n            res.field_validators.update({k: v.bind_to_cls(model_dc) for k, v in existing.field_validators.items()})\n            res.root_validators.update({k: v.bind_to_cls(model_dc) for k, v in existing.root_validators.items()})\n            res.field_serializers.update({k: v.bind_to_cls(model_dc) for k, v in existing.field_serializers.items()})\n            res.model_serializers.update({k: v.bind_to_cls(model_dc) for k, v in existing.model_serializers.items()})\n            res.model_validators.update({k: v.bind_to_cls(model_dc) for k, v in existing.model_validators.items()})\n            res.computed_fields.update({k: v.bind_to_cls(model_dc) for k, v in existing.computed_fields.items()})\n\n        to_replace: list[tuple[str, Any]] = []\n\n        for var_name, var_value in vars(model_dc).items():\n            if isinstance(var_value, PydanticDescriptorProxy):\n                info = var_value.decorator_info\n                if isinstance(info, ValidatorDecoratorInfo):\n                    res.validators[var_name] = Decorator.build(\n                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info\n                    )\n                elif isinstance(info, FieldValidatorDecoratorInfo):\n                    res.field_validators[var_name] = Decorator.build(\n                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info\n                    )\n                elif isinstance(info, RootValidatorDecoratorInfo):\n                    res.root_validators[var_name] = Decorator.build(\n                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info\n                    )\n                elif isinstance(info, FieldSerializerDecoratorInfo):\n                    # check whether a serializer function is already registered for fields\n                    for field_serializer_decorator in res.field_serializers.values():\n                        # check that each field has at most one serializer function.\n                        # serializer functions for the same field in subclasses are allowed,\n                        # and are treated as overrides\n                        if field_serializer_decorator.cls_var_name == var_name:\n                            continue\n                        for f in info.fields:\n                            if f in field_serializer_decorator.info.fields:\n                                raise PydanticUserError(\n                                    'Multiple field serializer functions were defined '\n                                    f'for field {f!r}, this is not allowed.',\n                                    code='multiple-field-serializers',\n                                )\n                    res.field_serializers[var_name] = Decorator.build(\n                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info\n                    )\n                elif isinstance(info, ModelValidatorDecoratorInfo):\n                    res.model_validators[var_name] = Decorator.build(\n                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info\n                    )\n                elif isinstance(info, ModelSerializerDecoratorInfo):\n                    res.model_serializers[var_name] = Decorator.build(\n                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info\n                    )\n                else:\n                    from ..fields import ComputedFieldInfo\n\n                    isinstance(var_value, ComputedFieldInfo)\n                    res.computed_fields[var_name] = Decorator.build(\n                        model_dc, cls_var_name=var_name, shim=None, info=info\n                    )\n                to_replace.append((var_name, var_value.wrapped))\n        if to_replace:\n            # If we can save `__pydantic_decorators__` on the class we'll be able to check for it above\n            # so then we don't need to re-process the type, which means we can discard our descriptor wrappers\n            # and replace them with the thing they are wrapping (see the other setattr call below)\n            # which allows validator class methods to also function as regular class methods\n            model_dc.__pydantic_decorators__ = res\n            for name, value in to_replace:\n                setattr(model_dc, name, value)\n        return res\n\n\ndef inspect_validator(validator: Callable[..., Any], mode: FieldValidatorModes) -> bool:\n    \"\"\"Look at a field or model validator function and determine whether it takes an info argument.\n\n    An error is raised if the function has an invalid signature.\n\n    Args:\n        validator: The validator function to inspect.\n        mode: The proposed validator mode.\n\n    Returns:\n        Whether the validator takes an info argument.\n    \"\"\"\n    try:\n        sig = signature(validator)\n    except (ValueError, TypeError):\n        # `inspect.signature` might not be able to infer a signature, e.g. with C objects.\n        # In this case, we assume no info argument is present:\n        return False\n    n_positional = count_positional_required_params(sig)\n    if mode == 'wrap':\n        if n_positional == 3:\n            return True\n        elif n_positional == 2:\n            return False\n    else:\n        assert mode in {'before', 'after', 'plain'}, f\"invalid mode: {mode!r}, expected 'before', 'after' or 'plain\"\n        if n_positional == 2:\n            return True\n        elif n_positional == 1:\n            return False\n\n    raise PydanticUserError(\n        f'Unrecognized field_validator function signature for {validator} with `mode={mode}`:{sig}',\n        code='validator-signature',\n    )\n\n\ndef inspect_field_serializer(serializer: Callable[..., Any], mode: Literal['plain', 'wrap']) -> tuple[bool, bool]:\n    \"\"\"Look at a field serializer function and determine if it is a field serializer,\n    and whether it takes an info argument.\n\n    An error is raised if the function has an invalid signature.\n\n    Args:\n        serializer: The serializer function to inspect.\n        mode: The serializer mode, either 'plain' or 'wrap'.\n\n    Returns:\n        Tuple of (is_field_serializer, info_arg).\n    \"\"\"\n    try:\n        sig = signature(serializer)\n    except (ValueError, TypeError):\n        # `inspect.signature` might not be able to infer a signature, e.g. with C objects.\n        # In this case, we assume no info argument is present and this is not a method:\n        return (False, False)\n\n    first = next(iter(sig.parameters.values()), None)\n    is_field_serializer = first is not None and first.name == 'self'\n\n    n_positional = count_positional_required_params(sig)\n    if is_field_serializer:\n        # -1 to correct for self parameter\n        info_arg = _serializer_info_arg(mode, n_positional - 1)\n    else:\n        info_arg = _serializer_info_arg(mode, n_positional)\n\n    if info_arg is None:\n        raise PydanticUserError(\n            f'Unrecognized field_serializer function signature for {serializer} with `mode={mode}`:{sig}',\n            code='field-serializer-signature',\n        )\n\n    return is_field_serializer, info_arg\n\n\ndef inspect_annotated_serializer(serializer: Callable[..., Any], mode: Literal['plain', 'wrap']) -> bool:\n    \"\"\"Look at a serializer function used via `Annotated` and determine whether it takes an info argument.\n\n    An error is raised if the function has an invalid signature.\n\n    Args:\n        serializer: The serializer function to check.\n        mode: The serializer mode, either 'plain' or 'wrap'.\n\n    Returns:\n        info_arg\n    \"\"\"\n    try:\n        sig = signature(serializer)\n    except (ValueError, TypeError):\n        # `inspect.signature` might not be able to infer a signature, e.g. with C objects.\n        # In this case, we assume no info argument is present:\n        return False\n    info_arg = _serializer_info_arg(mode, count_positional_required_params(sig))\n    if info_arg is None:\n        raise PydanticUserError(\n            f'Unrecognized field_serializer function signature for {serializer} with `mode={mode}`:{sig}',\n            code='field-serializer-signature',\n        )\n    else:\n        return info_arg\n\n\ndef inspect_model_serializer(serializer: Callable[..., Any], mode: Literal['plain', 'wrap']) -> bool:\n    \"\"\"Look at a model serializer function and determine whether it takes an info argument.\n\n    An error is raised if the function has an invalid signature.\n\n    Args:\n        serializer: The serializer function to check.\n        mode: The serializer mode, either 'plain' or 'wrap'.\n\n    Returns:\n        `info_arg` - whether the function expects an info argument.\n    \"\"\"\n    if isinstance(serializer, (staticmethod, classmethod)) or not is_instance_method_from_sig(serializer):\n        raise PydanticUserError(\n            '`@model_serializer` must be applied to instance methods', code='model-serializer-instance-method'\n        )\n\n    sig = signature(serializer)\n    info_arg = _serializer_info_arg(mode, count_positional_required_params(sig))\n    if info_arg is None:\n        raise PydanticUserError(\n            f'Unrecognized model_serializer function signature for {serializer} with `mode={mode}`:{sig}',\n            code='model-serializer-signature',\n        )\n    else:\n        return info_arg\n\n\ndef _serializer_info_arg(mode: Literal['plain', 'wrap'], n_positional: int) -> bool | None:\n    if mode == 'plain':\n        if n_positional == 1:\n            # (input_value: Any, /) -> Any\n            return False\n        elif n_positional == 2:\n            # (model: Any, input_value: Any, /) -> Any\n            return True\n    else:\n        assert mode == 'wrap', f\"invalid mode: {mode!r}, expected 'plain' or 'wrap'\"\n        if n_positional == 2:\n            # (input_value: Any, serializer: SerializerFunctionWrapHandler, /) -> Any\n            return False\n        elif n_positional == 3:\n            # (input_value: Any, serializer: SerializerFunctionWrapHandler, info: SerializationInfo, /) -> Any\n            return True\n\n    return None\n\n\nAnyDecoratorCallable: TypeAlias = (\n    'Union[classmethod[Any, Any, Any], staticmethod[Any, Any], partialmethod[Any], Callable[..., Any]]'\n)\n\n\ndef is_instance_method_from_sig(function: AnyDecoratorCallable) -> bool:\n    \"\"\"Whether the function is an instance method.\n\n    It will consider a function as instance method if the first parameter of\n    function is `self`.\n\n    Args:\n        function: The function to check.\n\n    Returns:\n        `True` if the function is an instance method, `False` otherwise.\n    \"\"\"\n    sig = signature(unwrap_wrapped_function(function))\n    first = next(iter(sig.parameters.values()), None)\n    if first and first.name == 'self':\n        return True\n    return False\n\n\ndef ensure_classmethod_based_on_signature(function: AnyDecoratorCallable) -> Any:\n    \"\"\"Apply the `@classmethod` decorator on the function.\n\n    Args:\n        function: The function to apply the decorator on.\n\n    Return:\n        The `@classmethod` decorator applied function.\n    \"\"\"\n    if not isinstance(\n        unwrap_wrapped_function(function, unwrap_class_static_method=False), classmethod\n    ) and _is_classmethod_from_sig(function):\n        return classmethod(function)  # type: ignore[arg-type]\n    return function\n\n\ndef _is_classmethod_from_sig(function: AnyDecoratorCallable) -> bool:\n    sig = signature(unwrap_wrapped_function(function))\n    first = next(iter(sig.parameters.values()), None)\n    if first and first.name == 'cls':\n        return True\n    return False\n\n\ndef unwrap_wrapped_function(\n    func: Any,\n    *,\n    unwrap_partial: bool = True,\n    unwrap_class_static_method: bool = True,\n) -> Any:\n    \"\"\"Recursively unwraps a wrapped function until the underlying function is reached.\n    This handles property, functools.partial, functools.partialmethod, staticmethod, and classmethod.\n\n    Args:\n        func: The function to unwrap.\n        unwrap_partial: If True (default), unwrap partial and partialmethod decorators.\n        unwrap_class_static_method: If True (default), also unwrap classmethod and staticmethod\n            decorators. If False, only unwrap partial and partialmethod decorators.\n\n    Returns:\n        The underlying function of the wrapped function.\n    \"\"\"\n    # Define the types we want to check against as a single tuple.\n    unwrap_types = (\n        (property, cached_property)\n        + ((partial, partialmethod) if unwrap_partial else ())\n        + ((staticmethod, classmethod) if unwrap_class_static_method else ())\n    )\n\n    while isinstance(func, unwrap_types):\n        if unwrap_class_static_method and isinstance(func, (classmethod, staticmethod)):\n            func = func.__func__\n        elif isinstance(func, (partial, partialmethod)):\n            func = func.func\n        elif isinstance(func, property):\n            func = func.fget  # arbitrary choice, convenient for computed fields\n        else:\n            # Make coverage happy as it can only get here in the last possible case\n            assert isinstance(func, cached_property)\n            func = func.func  # type: ignore\n\n    return func\n\n\n_function_like = (\n    partial,\n    partialmethod,\n    types.FunctionType,\n    types.BuiltinFunctionType,\n    types.MethodType,\n    types.WrapperDescriptorType,\n    types.MethodWrapperType,\n    types.MemberDescriptorType,\n)\n\n\ndef get_callable_return_type(\n    callable_obj: Any,\n    globalns: GlobalsNamespace | None = None,\n    localns: MappingNamespace | None = None,\n) -> Any | PydanticUndefinedType:\n    \"\"\"Get the callable return type.\n\n    Args:\n        callable_obj: The callable to analyze.\n        globalns: The globals namespace to use during type annotation evaluation.\n        localns: The locals namespace to use during type annotation evaluation.\n\n    Returns:\n        The function return type.\n    \"\"\"\n    if isinstance(callable_obj, type):\n        # types are callables, and we assume the return type\n        # is the type itself (e.g. `int()` results in an instance of `int`).\n        return callable_obj\n\n    if not isinstance(callable_obj, _function_like):\n        call_func = getattr(type(callable_obj), '__call__', None)  # noqa: B004\n        if call_func is not None:\n            callable_obj = call_func\n\n    hints = get_function_type_hints(\n        unwrap_wrapped_function(callable_obj),\n        include_keys={'return'},\n        globalns=globalns,\n        localns=localns,\n    )\n    return hints.get('return', PydanticUndefined)\n\n\ndef count_positional_required_params(sig: Signature) -> int:\n    \"\"\"Get the number of positional (required) arguments of a signature.\n\n    This function should only be used to inspect signatures of validation and serialization functions.\n    The first argument (the value being serialized or validated) is counted as a required argument\n    even if a default value exists.\n\n    Returns:\n        The number of positional arguments of a signature.\n    \"\"\"\n    parameters = list(sig.parameters.values())\n    return sum(\n        1\n        for param in parameters\n        if can_be_positional(param)\n        # First argument is the value being validated/serialized, and can have a default value\n        # (e.g. `float`, which has signature `(x=0, /)`). We assume other parameters (the info arg\n        # for instance) should be required, and thus without any default value.\n        and (param.default is Parameter.empty or param is parameters[0])\n    )\n\n\ndef ensure_property(f: Any) -> Any:\n    \"\"\"Ensure that a function is a `property` or `cached_property`, or is a valid descriptor.\n\n    Args:\n        f: The function to check.\n\n    Returns:\n        The function, or a `property` or `cached_property` instance wrapping the function.\n    \"\"\"\n    if ismethoddescriptor(f) or isdatadescriptor(f):\n        return f\n    else:\n        return property(f)\n\n\n--- File Index 7: _internal/_decorators_v1.py ---\n\"\"\"Logic for V1 validators, e.g. `@validator` and `@root_validator`.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nfrom inspect import Parameter, signature\nfrom typing import Any, Union, cast\n\nfrom pydantic_core import core_schema\nfrom typing_extensions import Protocol\n\nfrom ..errors import PydanticUserError\nfrom ._utils import can_be_positional\n\n\nclass V1OnlyValueValidator(Protocol):\n    \"\"\"A simple validator, supported for V1 validators and V2 validators.\"\"\"\n\n    def __call__(self, __value: Any) -> Any: ...\n\n\nclass V1ValidatorWithValues(Protocol):\n    \"\"\"A validator with `values` argument, supported for V1 validators and V2 validators.\"\"\"\n\n    def __call__(self, __value: Any, values: dict[str, Any]) -> Any: ...\n\n\nclass V1ValidatorWithValuesKwOnly(Protocol):\n    \"\"\"A validator with keyword only `values` argument, supported for V1 validators and V2 validators.\"\"\"\n\n    def __call__(self, __value: Any, *, values: dict[str, Any]) -> Any: ...\n\n\nclass V1ValidatorWithKwargs(Protocol):\n    \"\"\"A validator with `kwargs` argument, supported for V1 validators and V2 validators.\"\"\"\n\n    def __call__(self, __value: Any, **kwargs: Any) -> Any: ...\n\n\nclass V1ValidatorWithValuesAndKwargs(Protocol):\n    \"\"\"A validator with `values` and `kwargs` arguments, supported for V1 validators and V2 validators.\"\"\"\n\n    def __call__(self, __value: Any, values: dict[str, Any], **kwargs: Any) -> Any: ...\n\n\nV1Validator = Union[\n    V1ValidatorWithValues, V1ValidatorWithValuesKwOnly, V1ValidatorWithKwargs, V1ValidatorWithValuesAndKwargs\n]\n\n\ndef can_be_keyword(param: Parameter) -> bool:\n    return param.kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.KEYWORD_ONLY)\n\n\ndef make_generic_v1_field_validator(validator: V1Validator) -> core_schema.WithInfoValidatorFunction:\n    \"\"\"Wrap a V1 style field validator for V2 compatibility.\n\n    Args:\n        validator: The V1 style field validator.\n\n    Returns:\n        A wrapped V2 style field validator.\n\n    Raises:\n        PydanticUserError: If the signature is not supported or the parameters are\n            not available in Pydantic V2.\n    \"\"\"\n    sig = signature(validator)\n\n    needs_values_kw = False\n\n    for param_num, (param_name, parameter) in enumerate(sig.parameters.items()):\n        if can_be_keyword(parameter) and param_name in ('field', 'config'):\n            raise PydanticUserError(\n                'The `field` and `config` parameters are not available in Pydantic V2, '\n                'please use the `info` parameter instead.',\n                code='validator-field-config-info',\n            )\n        if parameter.kind is Parameter.VAR_KEYWORD:\n            needs_values_kw = True\n        elif can_be_keyword(parameter) and param_name == 'values':\n            needs_values_kw = True\n        elif can_be_positional(parameter) and param_num == 0:\n            # value\n            continue\n        elif parameter.default is Parameter.empty:  # ignore params with defaults e.g. bound by functools.partial\n            raise PydanticUserError(\n                f'Unsupported signature for V1 style validator {validator}: {sig} is not supported.',\n                code='validator-v1-signature',\n            )\n\n    if needs_values_kw:\n        # (v, **kwargs), (v, values, **kwargs), (v, *, values, **kwargs) or (v, *, values)\n        val1 = cast(V1ValidatorWithValues, validator)\n\n        def wrapper1(value: Any, info: core_schema.ValidationInfo) -> Any:\n            return val1(value, values=info.data)\n\n        return wrapper1\n    else:\n        val2 = cast(V1OnlyValueValidator, validator)\n\n        def wrapper2(value: Any, _: core_schema.ValidationInfo) -> Any:\n            return val2(value)\n\n        return wrapper2\n\n\nRootValidatorValues = dict[str, Any]\n# technically tuple[model_dict, model_extra, fields_set] | tuple[dataclass_dict, init_vars]\nRootValidatorFieldsTuple = tuple[Any, ...]\n\n\nclass V1RootValidatorFunction(Protocol):\n    \"\"\"A simple root validator, supported for V1 validators and V2 validators.\"\"\"\n\n    def __call__(self, __values: RootValidatorValues) -> RootValidatorValues: ...\n\n\nclass V2CoreBeforeRootValidator(Protocol):\n    \"\"\"V2 validator with mode='before'.\"\"\"\n\n    def __call__(self, __values: RootValidatorValues, __info: core_schema.ValidationInfo) -> RootValidatorValues: ...\n\n\nclass V2CoreAfterRootValidator(Protocol):\n    \"\"\"V2 validator with mode='after'.\"\"\"\n\n    def __call__(\n        self, __fields_tuple: RootValidatorFieldsTuple, __info: core_schema.ValidationInfo\n    ) -> RootValidatorFieldsTuple: ...\n\n\ndef make_v1_generic_root_validator(\n    validator: V1RootValidatorFunction, pre: bool\n) -> V2CoreBeforeRootValidator | V2CoreAfterRootValidator:\n    \"\"\"Wrap a V1 style root validator for V2 compatibility.\n\n    Args:\n        validator: The V1 style field validator.\n        pre: Whether the validator is a pre validator.\n\n    Returns:\n        A wrapped V2 style validator.\n    \"\"\"\n    if pre is True:\n        # mode='before' for pydantic-core\n        def _wrapper1(values: RootValidatorValues, _: core_schema.ValidationInfo) -> RootValidatorValues:\n            return validator(values)\n\n        return _wrapper1\n\n    # mode='after' for pydantic-core\n    def _wrapper2(fields_tuple: RootValidatorFieldsTuple, _: core_schema.ValidationInfo) -> RootValidatorFieldsTuple:\n        if len(fields_tuple) == 2:\n            # dataclass, this is easy\n            values, init_vars = fields_tuple\n            values = validator(values)\n            return values, init_vars\n        else:\n            # ugly hack: to match v1 behaviour, we merge values and model_extra, then split them up based on fields\n            # afterwards\n            model_dict, model_extra, fields_set = fields_tuple\n            if model_extra:\n                fields = set(model_dict.keys())\n                model_dict.update(model_extra)\n                model_dict_new = validator(model_dict)\n                for k in list(model_dict_new.keys()):\n                    if k not in fields:\n                        model_extra[k] = model_dict_new.pop(k)\n            else:\n                model_dict_new = validator(model_dict)\n            return model_dict_new, model_extra, fields_set\n\n    return _wrapper2\n\n\n\n\nBased on the provided codebase, identify the key abstractions that are central to understanding this project. \nThese abstractions should represent the core components, modules, or concepts.\n\nDesired output format is a YAML list of objects, where each object has:\n- 'name': A concise name for the abstraction (in korean).\n- 'description': A brief explanation of what this abstraction represents and its role (in korean).\n- 'file_indices': A list of integer file indices that are most relevant to this abstraction. Choose from the file list above.\n\nReturn at most 10 key abstractions.\n\nExample for a different project (simple web server):\n```yaml\n- name: \"HTTP   (HTTP Request Handler)\"\n  description: \" HTTP       . (Component that processes incoming HTTP requests and generates appropriate responses.)\"\n  file_indices: [0, 2]\n- name: \"  (Routing Configuration)\"\n  description: \"URL        . (Defines rules for mapping URL paths to specific request handler functions.)\"\n  file_indices: [1]\n```\n\nYour response should be only the YAML list, enclosed in triple backticks (```yaml ... ```).\nEnsure the output is valid YAML.\n": "```yaml\n- name: \"  (Config Wrapper)\"\n  description: \"Pydantic     , ConfigDict         .\"\n  file_indices: [2]\n\n- name: \"  (Core Metadata)\"\n  description: \"   , JSON              .\"\n  file_indices: [3]\n\n- name: \"  (Decorator Info)\"\n  description: \"              ,     .\"\n  file_indices: [6, 7]\n\n- name: \"  (Internal Utils)\"\n  description: \"         , Pydantic    .\"\n  file_indices: [4]\n\n- name: \"   (Dataclass Creator)\"\n  description: \"Pydantic         Python   Pydantic   .\"\n  file_indices: [5]\n\n- name: \"   (Dynamic Import Functionality)\"\n  description: \"      Pydantic        .\"\n  file_indices: [0]\n\n- name: \"  (Warning System)\"\n  description: \"Pydantic   deprecated           .\"\n  file_indices: [2]\n\n- name: \"  (Schema Generator)\"\n  description: \"      JSON         .\"\n  file_indices: [5]\n```",
    "\nBased on the following abstractions and relevant code snippets from the project `pydantic`:\n\nList of Abstraction Indices and Names (Names might be in Korean):\n0 #   (Config Wrapper)\n1 #   (Core Metadata)\n2 #   (Decorator Info)\n3 #   (Internal Utils)\n4 #    (Dataclass Creator)\n5 #    (Dynamic Import Functionality)\n6 #   (Warning System)\n7 #   (Schema Generator)\n\nContext (Abstractions, Descriptions, Code):\nIdentified Abstractions:\n- Index 0:   (Config Wrapper) (Relevant file indices: [2])\n  Description: Pydantic     , ConfigDict         .\n- Index 1:   (Core Metadata) (Relevant file indices: [3])\n  Description:    , JSON              .\n- Index 2:   (Decorator Info) (Relevant file indices: [6, 7])\n  Description:               ,     .\n- Index 3:   (Internal Utils) (Relevant file indices: [4])\n  Description:          , Pydantic    .\n- Index 4:    (Dataclass Creator) (Relevant file indices: [5])\n  Description: Pydantic         Python   Pydantic   .\n- Index 5:    (Dynamic Import Functionality) (Relevant file indices: [0])\n  Description:       Pydantic        .\n- Index 6:   (Warning System) (Relevant file indices: [2])\n  Description: Pydantic   deprecated           .\n- Index 7:   (Schema Generator) (Relevant file indices: [5])\n  Description:       JSON         .\n\nRelevant File Snippets (Referenced by Index and Path):\n--- File: 0 # __init__.py ---\nimport typing\nfrom importlib import import_module\nfrom warnings import warn\n\nfrom ._migration import getattr_migration\nfrom .version import VERSION\n\nif typing.TYPE_CHECKING:\n    # import of virtually everything is supported via `__getattr__` below,\n    # but we need them here for type checking and IDE support\n    import pydantic_core\n    from pydantic_core.core_schema import (\n        FieldSerializationInfo,\n        SerializationInfo,\n        SerializerFunctionWrapHandler,\n        ValidationInfo,\n        ValidatorFunctionWrapHandler,\n    )\n\n    from . import dataclasses\n    from .aliases import AliasChoices, AliasGenerator, AliasPath\n    from .annotated_handlers import GetCoreSchemaHandler, GetJsonSchemaHandler\n    from .config import ConfigDict, with_config\n    from .errors import *\n    from .fields import Field, PrivateAttr, computed_field\n    from .functional_serializers import (\n        PlainSerializer,\n        SerializeAsAny,\n        WrapSerializer,\n        field_serializer,\n        model_serializer,\n    )\n    from .functional_validators import (\n        AfterValidator,\n        BeforeValidator,\n        InstanceOf,\n        ModelWrapValidatorHandler,\n        PlainValidator,\n        SkipValidation,\n        WrapValidator,\n        field_validator,\n        model_validator,\n    )\n    from .json_schema import WithJsonSchema\n    from .main import *\n    from .networks import *\n    from .type_adapter import TypeAdapter\n    from .types import *\n    from .validate_call_decorator import validate_call\n    from .warnings import (\n        PydanticDeprecatedSince20,\n        PydanticDeprecatedSince26,\n        PydanticDeprecatedSince29,\n        PydanticDeprecatedSince210,\n        PydanticDeprecatedSince211,\n        PydanticDeprecationWarning,\n        PydanticExperimentalWarning,\n    )\n\n    # this encourages pycharm to import `ValidationError` from here, not pydantic_core\n    ValidationError = pydantic_core.ValidationError\n    from .deprecated.class_validators import root_validator, validator\n    from .deprecated.config import BaseConfig, Extra\n    from .deprecated.tools import *\n    from .root_model import RootModel\n\n__version__ = VERSION\n__all__ = (\n    # dataclasses\n    'dataclasses',\n    # functional validators\n    'field_validator',\n    'model_validator',\n    'AfterValidator',\n    'BeforeValidator',\n    'PlainValidator',\n    'WrapValidator',\n    'SkipValidation',\n    'InstanceOf',\n    'ModelWrapValidatorHandler',\n    # JSON Schema\n    'WithJsonSchema',\n    # deprecated V1 functional validators, these are imported via `__getattr__` below\n    'root_validator',\n    'validator',\n    # functional serializers\n    'field_serializer',\n    'model_serializer',\n    'PlainSerializer',\n    'SerializeAsAny',\n    'WrapSerializer',\n    # config\n    'ConfigDict',\n    'with_config',\n    # deprecated V1 config, these are imported via `__getattr__` below\n    'BaseConfig',\n    'Extra',\n    # validate_call\n    'validate_call',\n    # errors\n    'PydanticErrorCodes',\n    'PydanticUserError',\n    'PydanticSchemaGenerationError',\n    'PydanticImportError',\n    'PydanticUndefinedAnnotation',\n    'PydanticInvalidForJsonSchema',\n    'PydanticForbiddenQualifier',\n    # fields\n    'Field',\n    'computed_field',\n    'PrivateAttr',\n    # alias\n    'AliasChoices',\n    'AliasGenerator',\n    'AliasPath',\n    # main\n    'BaseModel',\n    'create_model',\n    # network\n    'AnyUrl',\n    'AnyHttpUrl',\n    'FileUrl',\n    'HttpUrl',\n    'FtpUrl',\n    'WebsocketUrl',\n    'AnyWebsocketUrl',\n    'UrlConstraints',\n    'EmailStr',\n    'NameEmail',\n    'IPvAnyAddress',\n    'IPvAnyInterface',\n    'IPvAnyNetwork',\n    'PostgresDsn',\n    'CockroachDsn',\n    'AmqpDsn',\n    'RedisDsn',\n    'MongoDsn',\n    'KafkaDsn',\n    'NatsDsn',\n    'MySQLDsn',\n    'MariaDBDsn',\n    'ClickHouseDsn',\n    'SnowflakeDsn',\n    'validate_email',\n    # root_model\n    'RootModel',\n    # deprecated tools, these are imported via `__getattr__` below\n    'parse_obj_as',\n    'schema_of',\n    'schema_json_of',\n    # types\n    'Strict',\n    'StrictStr',\n    'conbytes',\n    'conlist',\n    'conset',\n    'confrozenset',\n    'constr',\n    'StringConstraints',\n    'ImportString',\n    'conint',\n    'PositiveInt',\n    'NegativeInt',\n    'NonNegativeInt',\n    'NonPositiveInt',\n    'confloat',\n    'PositiveFloat',\n    'NegativeFloat',\n    'NonNegativeFloat',\n    'NonPositiveFloat',\n    'FiniteFloat',\n    'condecimal',\n    'condate',\n    'UUID1',\n    'UUID3',\n    'UUID4',\n    'UUID5',\n    'UUID6',\n    'UUID7',\n    'UUID8',\n    'FilePath',\n    'DirectoryPath',\n    'NewPath',\n    'Json',\n    'Secret',\n    'SecretStr',\n    'SecretBytes',\n    'SocketPath',\n    'StrictBool',\n    'StrictBytes',\n    'StrictInt',\n    'StrictFloat',\n    'PaymentCardNumber',\n    'ByteSize',\n    'PastDate',\n    'FutureDate',\n    'PastDatetime',\n    'FutureDatetime',\n    'AwareDatetime',\n    'NaiveDatetime',\n    'AllowInfNan',\n    'EncoderProtocol',\n    'EncodedBytes',\n    'EncodedStr',\n    'Base64Encoder',\n    'Base64Bytes',\n    'Base64Str',\n    'Base64UrlBytes',\n    'Base64UrlStr',\n    'GetPydanticSchema',\n    'Tag',\n    'Discriminator',\n    'JsonValue',\n    'FailFast',\n    # type_adapter\n    'TypeAdapter',\n    # version\n    '__version__',\n    'VERSION',\n    # warnings\n    'PydanticDeprecatedSince20',\n    'PydanticDeprecatedSince26',\n    'PydanticDeprecatedSince29',\n    'PydanticDeprecatedSince210',\n    'PydanticDeprecatedSince211',\n    'PydanticDeprecationWarning',\n    'PydanticExperimentalWarning',\n    # annotated handlers\n    'GetCoreSchemaHandler',\n    'GetJsonSchemaHandler',\n    # pydantic_core\n    'ValidationError',\n    'ValidationInfo',\n    'SerializationInfo',\n    'ValidatorFunctionWrapHandler',\n    'FieldSerializationInfo',\n    'SerializerFunctionWrapHandler',\n    'OnErrorOmit',\n)\n\n# A mapping of {<member name>: (package, <module name>)} defining dynamic imports\n_dynamic_imports: 'dict[str, tuple[str, str]]' = {\n    'dataclasses': (__spec__.parent, '__module__'),\n    # functional validators\n    'field_validator': (__spec__.parent, '.functional_validators'),\n    'model_validator': (__spec__.parent, '.functional_validators'),\n    'AfterValidator': (__spec__.parent, '.functional_validators'),\n    'BeforeValidator': (__spec__.parent, '.functional_validators'),\n    'PlainValidator': (__spec__.parent, '.functional_validators'),\n    'WrapValidator': (__spec__.parent, '.functional_validators'),\n    'SkipValidation': (__spec__.parent, '.functional_validators'),\n    'InstanceOf': (__spec__.parent, '.functional_validators'),\n    'ModelWrapValidatorHandler': (__spec__.parent, '.functional_validators'),\n    # JSON Schema\n    'WithJsonSchema': (__spec__.parent, '.json_schema'),\n    # functional serializers\n    'field_serializer': (__spec__.parent, '.functional_serializers'),\n    'model_serializer': (__spec__.parent, '.functional_serializers'),\n    'PlainSerializer': (__spec__.parent, '.functional_serializers'),\n    'SerializeAsAny': (__spec__.parent, '.functional_serializers'),\n    'WrapSerializer': (__spec__.parent, '.functional_serializers'),\n    # config\n    'ConfigDict': (__spec__.parent, '.config'),\n    'with_config': (__spec__.parent, '.config'),\n    # validate call\n    'validate_call': (__spec__.parent, '.validate_call_decorator'),\n    # errors\n    'PydanticErrorCodes': (__spec__.parent, '.errors'),\n    'PydanticUserError': (__spec__.parent, '.errors'),\n    'PydanticSchemaGenerationError': (__spec__.parent, '.errors'),\n    'PydanticImportError': (__spec__.parent, '.errors'),\n    'PydanticUndefinedAnnotation': (__spec__.parent, '.errors'),\n    'PydanticInvalidForJsonSchema': (__spec__.parent, '.errors'),\n    'PydanticForbiddenQualifier': (__spec__.parent, '.errors'),\n    # fields\n    'Field': (__spec__.parent, '.fields'),\n    'computed_field': (__spec__.parent, '.fields'),\n    'PrivateAttr': (__spec__.parent, '.fields'),\n    # alias\n    'AliasChoices': (__spec__.parent, '.aliases'),\n    'AliasGenerator': (__spec__.parent, '.aliases'),\n    'AliasPath': (__spec__.parent, '.aliases'),\n    # main\n    'BaseModel': (__spec__.parent, '.main'),\n    'create_model': (__spec__.parent, '.main'),\n    # network\n    'AnyUrl': (__spec__.parent, '.networks'),\n    'AnyHttpUrl': (__spec__.parent, '.networks'),\n    'FileUrl': (__spec__.parent, '.networks'),\n    'HttpUrl': (__spec__.parent, '.networks'),\n    'FtpUrl': (__spec__.parent, '.networks'),\n    'WebsocketUrl': (__spec__.parent, '.networks'),\n    'AnyWebsocketUrl': (__spec__.parent, '.networks'),\n    'UrlConstraints': (__spec__.parent, '.networks'),\n    'EmailStr': (__spec__.parent, '.networks'),\n    'NameEmail': (__spec__.parent, '.networks'),\n    'IPvAnyAddress': (__spec__.parent, '.networks'),\n    'IPvAnyInterface': (__spec__.parent, '.networks'),\n    'IPvAnyNetwork': (__spec__.parent, '.networks'),\n    'PostgresDsn': (__spec__.parent, '.networks'),\n    'CockroachDsn': (__spec__.parent, '.networks'),\n    'AmqpDsn': (__spec__.parent, '.networks'),\n    'RedisDsn': (__spec__.parent, '.networks'),\n    'MongoDsn': (__spec__.parent, '.networks'),\n    'KafkaDsn': (__spec__.parent, '.networks'),\n    'NatsDsn': (__spec__.parent, '.networks'),\n    'MySQLDsn': (__spec__.parent, '.networks'),\n    'MariaDBDsn': (__spec__.parent, '.networks'),\n    'ClickHouseDsn': (__spec__.parent, '.networks'),\n    'SnowflakeDsn': (__spec__.parent, '.networks'),\n    'validate_email': (__spec__.parent, '.networks'),\n    # root_model\n    'RootModel': (__spec__.parent, '.root_model'),\n    # types\n    'Strict': (__spec__.parent, '.types'),\n    'StrictStr': (__spec__.parent, '.types'),\n    'conbytes': (__spec__.parent, '.types'),\n    'conlist': (__spec__.parent, '.types'),\n    'conset': (__spec__.parent, '.types'),\n    'confrozenset': (__spec__.parent, '.types'),\n    'constr': (__spec__.parent, '.types'),\n    'StringConstraints': (__spec__.parent, '.types'),\n    'ImportString': (__spec__.parent, '.types'),\n    'conint': (__spec__.parent, '.types'),\n    'PositiveInt': (__spec__.parent, '.types'),\n    'NegativeInt': (__spec__.parent, '.types'),\n    'NonNegativeInt': (__spec__.parent, '.types'),\n    'NonPositiveInt': (__spec__.parent, '.types'),\n    'confloat': (__spec__.parent, '.types'),\n    'PositiveFloat': (__spec__.parent, '.types'),\n    'NegativeFloat': (__spec__.parent, '.types'),\n    'NonNegativeFloat': (__spec__.parent, '.types'),\n    'NonPositiveFloat': (__spec__.parent, '.types'),\n    'FiniteFloat': (__spec__.parent, '.types'),\n    'condecimal': (__spec__.parent, '.types'),\n    'condate': (__spec__.parent, '.types'),\n    'UUID1': (__spec__.parent, '.types'),\n    'UUID3': (__spec__.parent, '.types'),\n    'UUID4': (__spec__.parent, '.types'),\n    'UUID5': (__spec__.parent, '.types'),\n    'UUID6': (__spec__.parent, '.types'),\n    'UUID7': (__spec__.parent, '.types'),\n    'UUID8': (__spec__.parent, '.types'),\n    'FilePath': (__spec__.parent, '.types'),\n    'DirectoryPath': (__spec__.parent, '.types'),\n    'NewPath': (__spec__.parent, '.types'),\n    'Json': (__spec__.parent, '.types'),\n    'Secret': (__spec__.parent, '.types'),\n    'SecretStr': (__spec__.parent, '.types'),\n    'SecretBytes': (__spec__.parent, '.types'),\n    'StrictBool': (__spec__.parent, '.types'),\n    'StrictBytes': (__spec__.parent, '.types'),\n    'StrictInt': (__spec__.parent, '.types'),\n    'StrictFloat': (__spec__.parent, '.types'),\n    'PaymentCardNumber': (__spec__.parent, '.types'),\n    'ByteSize': (__spec__.parent, '.types'),\n    'PastDate': (__spec__.parent, '.types'),\n    'SocketPath': (__spec__.parent, '.types'),\n    'FutureDate': (__spec__.parent, '.types'),\n    'PastDatetime': (__spec__.parent, '.types'),\n    'FutureDatetime': (__spec__.parent, '.types'),\n    'AwareDatetime': (__spec__.parent, '.types'),\n    'NaiveDatetime': (__spec__.parent, '.types'),\n    'AllowInfNan': (__spec__.parent, '.types'),\n    'EncoderProtocol': (__spec__.parent, '.types'),\n    'EncodedBytes': (__spec__.parent, '.types'),\n    'EncodedStr': (__spec__.parent, '.types'),\n    'Base64Encoder': (__spec__.parent, '.types'),\n    'Base64Bytes': (__spec__.parent, '.types'),\n    'Base64Str': (__spec__.parent, '.types'),\n    'Base64UrlBytes': (__spec__.parent, '.types'),\n    'Base64UrlStr': (__spec__.parent, '.types'),\n    'GetPydanticSchema': (__spec__.parent, '.types'),\n    'Tag': (__spec__.parent, '.types'),\n    'Discriminator': (__spec__.parent, '.types'),\n    'JsonValue': (__spec__.parent, '.types'),\n    'OnErrorOmit': (__spec__.parent, '.types'),\n    'FailFast': (__spec__.parent, '.types'),\n    # type_adapter\n    'TypeAdapter': (__spec__.parent, '.type_adapter'),\n    # warnings\n    'PydanticDeprecatedSince20': (__spec__.parent, '.warnings'),\n    'PydanticDeprecatedSince26': (__spec__.parent, '.warnings'),\n    'PydanticDeprecatedSince29': (__spec__.parent, '.warnings'),\n    'PydanticDeprecatedSince210': (__spec__.parent, '.warnings'),\n    'PydanticDeprecatedSince211': (__spec__.parent, '.warnings'),\n    'PydanticDeprecationWarning': (__spec__.parent, '.warnings'),\n    'PydanticExperimentalWarning': (__spec__.parent, '.warnings'),\n    # annotated handlers\n    'GetCoreSchemaHandler': (__spec__.parent, '.annotated_handlers'),\n    'GetJsonSchemaHandler': (__spec__.parent, '.annotated_handlers'),\n    # pydantic_core stuff\n    'ValidationError': ('pydantic_core', '.'),\n    'ValidationInfo': ('pydantic_core', '.core_schema'),\n    'SerializationInfo': ('pydantic_core', '.core_schema'),\n    'ValidatorFunctionWrapHandler': ('pydantic_core', '.core_schema'),\n    'FieldSerializationInfo': ('pydantic_core', '.core_schema'),\n    'SerializerFunctionWrapHandler': ('pydantic_core', '.core_schema'),\n    # deprecated, mostly not included in __all__\n    'root_validator': (__spec__.parent, '.deprecated.class_validators'),\n    'validator': (__spec__.parent, '.deprecated.class_validators'),\n    'BaseConfig': (__spec__.parent, '.deprecated.config'),\n    'Extra': (__spec__.parent, '.deprecated.config'),\n    'parse_obj_as': (__spec__.parent, '.deprecated.tools'),\n    'schema_of': (__spec__.parent, '.deprecated.tools'),\n    'schema_json_of': (__spec__.parent, '.deprecated.tools'),\n    # deprecated dynamic imports\n    'FieldValidationInfo': ('pydantic_core', '.core_schema'),\n    'GenerateSchema': (__spec__.parent, '._internal._generate_schema'),\n}\n_deprecated_dynamic_imports = {'FieldValidationInfo', 'GenerateSchema'}\n\n_getattr_migration = getattr_migration(__name__)\n\n\ndef __getattr__(attr_name: str) -> object:\n    if attr_name in _deprecated_dynamic_imports:\n        warn(\n            f'Importing {attr_name} from `pydantic` is deprecated. This feature is either no longer supported, or is not public.',\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    dynamic_attr = _dynamic_imports.get(attr_name)\n    if dynamic_attr is None:\n        return _getattr_migration(attr_name)\n\n    package, module_name = dynamic_attr\n\n    if module_name == '__module__':\n        result = import_module(f'.{attr_name}', package=package)\n        globals()[attr_name] = result\n        return result\n    else:\n        module = import_module(module_name, package=package)\n        result = getattr(module, attr_name)\n        g = globals()\n        for k, (_, v_module_name) in _dynamic_imports.items():\n            if v_module_name == module_name and k not in _deprecated_dynamic_imports:\n                g[k] = getattr(module, k)\n        return result\n\n\ndef __dir__() -> 'list[str]':\n    return list(__all__)\n\n\n--- File: 2 # _internal/_config.py ---\nfrom __future__ import annotations as _annotations\n\nimport warnings\nfrom contextlib import contextmanager\nfrom re import Pattern\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    Literal,\n    cast,\n)\n\nfrom pydantic_core import core_schema\nfrom typing_extensions import Self\n\nfrom ..aliases import AliasGenerator\nfrom ..config import ConfigDict, ExtraValues, JsonDict, JsonEncoder, JsonSchemaExtraCallable\nfrom ..errors import PydanticUserError\nfrom ..warnings import PydanticDeprecatedSince20, PydanticDeprecatedSince210\n\nif not TYPE_CHECKING:\n    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915\n    # and https://youtrack.jetbrains.com/issue/PY-51428\n    DeprecationWarning = PydanticDeprecatedSince20\n\nif TYPE_CHECKING:\n    from .._internal._schema_generation_shared import GenerateSchema\n    from ..fields import ComputedFieldInfo, FieldInfo\n\nDEPRECATION_MESSAGE = 'Support for class-based `config` is deprecated, use ConfigDict instead.'\n\n\nclass ConfigWrapper:\n    \"\"\"Internal wrapper for Config which exposes ConfigDict items as attributes.\"\"\"\n\n    __slots__ = ('config_dict',)\n\n    config_dict: ConfigDict\n\n    # all annotations are copied directly from ConfigDict, and should be kept up to date, a test will fail if they\n    # stop matching\n    title: str | None\n    str_to_lower: bool\n    str_to_upper: bool\n    str_strip_whitespace: bool\n    str_min_length: int\n    str_max_length: int | None\n    extra: ExtraValues | None\n    frozen: bool\n    populate_by_name: bool\n    use_enum_values: bool\n    validate_assignment: bool\n    arbitrary_types_allowed: bool\n    from_attributes: bool\n    # whether to use the actual key provided in the data (e.g. alias or first alias for \"field required\" errors) instead of field_names\n    # to construct error `loc`s, default `True`\n    loc_by_alias: bool\n    alias_generator: Callable[[str], str] | AliasGenerator | None\n    model_title_generator: Callable[[type], str] | None\n    field_title_generator: Callable[[str, FieldInfo | ComputedFieldInfo], str] | None\n    ignored_types: tuple[type, ...]\n    allow_inf_nan: bool\n    json_schema_extra: JsonDict | JsonSchemaExtraCallable | None\n    json_encoders: dict[type[object], JsonEncoder] | None\n\n    # new in V2\n    strict: bool\n    # whether instances of models and dataclasses (including subclass instances) should re-validate, default 'never'\n    revalidate_instances: Literal['always', 'never', 'subclass-instances']\n    ser_json_timedelta: Literal['iso8601', 'float']\n    ser_json_bytes: Literal['utf8', 'base64', 'hex']\n    val_json_bytes: Literal['utf8', 'base64', 'hex']\n    ser_json_inf_nan: Literal['null', 'constants', 'strings']\n    # whether to validate default values during validation, default False\n    validate_default: bool\n    validate_return: bool\n    protected_namespaces: tuple[str | Pattern[str], ...]\n    hide_input_in_errors: bool\n    defer_build: bool\n    plugin_settings: dict[str, object] | None\n    schema_generator: type[GenerateSchema] | None\n    json_schema_serialization_defaults_required: bool\n    json_schema_mode_override: Literal['validation', 'serialization', None]\n    coerce_numbers_to_str: bool\n    regex_engine: Literal['rust-regex', 'python-re']\n    validation_error_cause: bool\n    use_attribute_docstrings: bool\n    cache_strings: bool | Literal['all', 'keys', 'none']\n    validate_by_alias: bool\n    validate_by_name: bool\n    serialize_by_alias: bool\n\n    def __init__(self, config: ConfigDict | dict[str, Any] | type[Any] | None, *, check: bool = True):\n        if check:\n            self.config_dict = prepare_config(config)\n        else:\n            self.config_dict = cast(ConfigDict, config)\n\n    @classmethod\n    def for_model(cls, bases: tuple[type[Any], ...], namespace: dict[str, Any], kwargs: dict[str, Any]) -> Self:\n        \"\"\"Build a new `ConfigWrapper` instance for a `BaseModel`.\n\n        The config wrapper built based on (in descending order of priority):\n        - options from `kwargs`\n        - options from the `namespace`\n        - options from the base classes (`bases`)\n\n        Args:\n            bases: A tuple of base classes.\n            namespace: The namespace of the class being created.\n            kwargs: The kwargs passed to the class being created.\n\n        Returns:\n            A `ConfigWrapper` instance for `BaseModel`.\n        \"\"\"\n        config_new = ConfigDict()\n        for base in bases:\n            config = getattr(base, 'model_config', None)\n            if config:\n                config_new.update(config.copy())\n\n        config_class_from_namespace = namespace.get('Config')\n        config_dict_from_namespace = namespace.get('model_config')\n\n        raw_annotations = namespace.get('__annotations__', {})\n        if raw_annotations.get('model_config') and config_dict_from_namespace is None:\n            raise PydanticUserError(\n                '`model_config` cannot be used as a model field name. Use `model_config` for model configuration.',\n                code='model-config-invalid-field-name',\n            )\n\n        if config_class_from_namespace and config_dict_from_namespace:\n            raise PydanticUserError('\"Config\" and \"model_config\" cannot be used together', code='config-both')\n\n        config_from_namespace = config_dict_from_namespace or prepare_config(config_class_from_namespace)\n\n        config_new.update(config_from_namespace)\n\n        for k in list(kwargs.keys()):\n            if k in config_keys:\n                config_new[k] = kwargs.pop(k)\n\n        return cls(config_new)\n\n    # we don't show `__getattr__` to type checkers so missing attributes cause errors\n    if not TYPE_CHECKING:  # pragma: no branch\n\n        def __getattr__(self, name: str) -> Any:\n            try:\n                return self.config_dict[name]\n            except KeyError:\n                try:\n                    return config_defaults[name]\n                except KeyError:\n                    raise AttributeError(f'Config has no attribute {name!r}') from None\n\n    def core_config(self, title: str | None) -> core_schema.CoreConfig:\n        \"\"\"Create a pydantic-core config.\n\n        We don't use getattr here since we don't want to populate with defaults.\n\n        Args:\n            title: The title to use if not set in config.\n\n        Returns:\n            A `CoreConfig` object created from config.\n        \"\"\"\n        config = self.config_dict\n\n        if config.get('schema_generator') is not None:\n            warnings.warn(\n                'The `schema_generator` setting has been deprecated since v2.10. This setting no longer has any effect.',\n                PydanticDeprecatedSince210,\n                stacklevel=2,\n            )\n\n        if (populate_by_name := config.get('populate_by_name')) is not None:\n            # We include this patch for backwards compatibility purposes, but this config setting will be deprecated in v3.0, and likely removed in v4.0.\n            # Thus, the above warning and this patch can be removed then as well.\n            if config.get('validate_by_name') is None:\n                config['validate_by_alias'] = True\n                config['validate_by_name'] = populate_by_name\n\n        # We dynamically patch validate_by_name to be True if validate_by_alias is set to False\n        # and validate_by_name is not explicitly set.\n        if config.get('validate_by_alias') is False and config.get('validate_by_name') is None:\n            config['validate_by_name'] = True\n\n        if (not config.get('validate_by_alias', True)) and (not config.get('validate_by_name', False)):\n            raise PydanticUserError(\n                'At least one of `validate_by_alias` or `validate_by_name` must be set to True.',\n                code='validate-by-alias-and-name-false',\n            )\n\n        return core_schema.CoreConfig(\n            **{  # pyright: ignore[reportArgumentType]\n                k: v\n                for k, v in (\n                    ('title', config.get('title') or title or None),\n                    ('extra_fields_behavior', config.get('extra')),\n                    ('allow_inf_nan', config.get('allow_inf_nan')),\n                    ('str_strip_whitespace', config.get('str_strip_whitespace')),\n                    ('str_to_lower', config.get('str_to_lower')),\n                    ('str_to_upper', config.get('str_to_upper')),\n                    ('strict', config.get('strict')),\n                    ('ser_json_timedelta', config.get('ser_json_timedelta')),\n                    ('ser_json_bytes', config.get('ser_json_bytes')),\n                    ('val_json_bytes', config.get('val_json_bytes')),\n                    ('ser_json_inf_nan', config.get('ser_json_inf_nan')),\n                    ('from_attributes', config.get('from_attributes')),\n                    ('loc_by_alias', config.get('loc_by_alias')),\n                    ('revalidate_instances', config.get('revalidate_instances')),\n                    ('validate_default', config.get('validate_default')),\n                    ('str_max_length', config.get('str_max_length')),\n                    ('str_min_length', config.get('str_min_length')),\n                    ('hide_input_in_errors', config.get('hide_input_in_errors')),\n                    ('coerce_numbers_to_str', config.get('coerce_numbers_to_str')),\n                    ('regex_engine', config.get('regex_engine')),\n                    ('validation_error_cause', config.get('validation_error_cause')),\n                    ('cache_strings', config.get('cache_strings')),\n                    ('validate_by_alias', config.get('validate_by_alias')),\n                    ('validate_by_name', config.get('validate_by_name')),\n                    ('serialize_by_alias', config.get('serialize_by_alias')),\n                )\n                if v is not None\n            }\n        )\n\n    def __repr__(self):\n        c = ', '.join(f'{k}={v!r}' for k, v in self.config_dict.items())\n        return f'ConfigWrapper({c})'\n\n\nclass ConfigWrapperStack:\n    \"\"\"A stack of `ConfigWrapper` instances.\"\"\"\n\n    def __init__(self, config_wrapper: ConfigWrapper):\n        self._config_wrapper_stack: list[ConfigWrapper] = [config_wrapper]\n\n    @property\n    def tail(self) -> ConfigWrapper:\n        return self._config_wrapper_stack[-1]\n\n    @contextmanager\n    def push(self, config_wrapper: ConfigWrapper | ConfigDict | None):\n        if config_wrapper is None:\n            yield\n            return\n\n        if not isinstance(config_wrapper, ConfigWrapper):\n            config_wrapper = ConfigWrapper(config_wrapper, check=False)\n\n        self._config_wrapper_stack.append(config_wrapper)\n        try:\n            yield\n        finally:\n            self._config_wrapper_stack.pop()\n\n\nconfig_defaults = ConfigDict(\n    title=None,\n    str_to_lower=False,\n    str_to_upper=False,\n    str_strip_whitespace=False,\n    str_min_length=0,\n    str_max_length=None,\n    # let the model / dataclass decide how to handle it\n    extra=None,\n    frozen=False,\n    populate_by_name=False,\n    use_enum_values=False,\n    validate_assignment=False,\n    arbitrary_types_allowed=False,\n    from_attributes=False,\n    loc_by_alias=True,\n    alias_generator=None,\n    model_title_generator=None,\n    field_title_generator=None,\n    ignored_types=(),\n    allow_inf_nan=True,\n    json_schema_extra=None,\n    strict=False,\n    revalidate_instances='never',\n    ser_json_timedelta='iso8601',\n    ser_json_bytes='utf8',\n    val_json_bytes='utf8',\n    ser_json_inf_nan='null',\n    validate_default=False,\n    validate_return=False,\n    protected_namespaces=('model_validate', 'model_dump'),\n    hide_input_in_errors=False,\n    json_encoders=None,\n    defer_build=False,\n    schema_generator=None,\n    plugin_settings=None,\n    json_schema_serialization_defaults_required=False,\n    json_schema_mode_override=None,\n    coerce_numbers_to_str=False,\n    regex_engine='rust-regex',\n    validation_error_cause=False,\n    use_attribute_docstrings=False,\n    cache_strings=True,\n    validate_by_alias=True,\n    validate_by_name=False,\n    serialize_by_alias=False,\n)\n\n\ndef prepare_config(config: ConfigDict | dict[str, Any] | type[Any] | None) -> ConfigDict:\n    \"\"\"Create a `ConfigDict` instance from an existing dict, a class (e.g. old class-based config) or None.\n\n    Args:\n        config: The input config.\n\n    Returns:\n        A ConfigDict object created from config.\n    \"\"\"\n    if config is None:\n        return ConfigDict()\n\n    if not isinstance(config, dict):\n        warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)\n        config = {k: getattr(config, k) for k in dir(config) if not k.startswith('__')}\n\n    config_dict = cast(ConfigDict, config)\n    check_deprecated(config_dict)\n    return config_dict\n\n\nconfig_keys = set(ConfigDict.__annotations__.keys())\n\n\nV2_REMOVED_KEYS = {\n    'allow_mutation',\n    'error_msg_templates',\n    'fields',\n    'getter_dict',\n    'smart_union',\n    'underscore_attrs_are_private',\n    'json_loads',\n    'json_dumps',\n    'copy_on_model_validation',\n    'post_init_call',\n}\nV2_RENAMED_KEYS = {\n    'allow_population_by_field_name': 'validate_by_name',\n    'anystr_lower': 'str_to_lower',\n    'anystr_strip_whitespace': 'str_strip_whitespace',\n    'anystr_upper': 'str_to_upper',\n    'keep_untouched': 'ignored_types',\n    'max_anystr_length': 'str_max_length',\n    'min_anystr_length': 'str_min_length',\n    'orm_mode': 'from_attributes',\n    'schema_extra': 'json_schema_extra',\n    'validate_all': 'validate_default',\n}\n\n\ndef check_deprecated(config_dict: ConfigDict) -> None:\n    \"\"\"Check for deprecated config keys and warn the user.\n\n    Args:\n        config_dict: The input config.\n    \"\"\"\n    deprecated_removed_keys = V2_REMOVED_KEYS & config_dict.keys()\n    deprecated_renamed_keys = V2_RENAMED_KEYS.keys() & config_dict.keys()\n    if deprecated_removed_keys or deprecated_renamed_keys:\n        renamings = {k: V2_RENAMED_KEYS[k] for k in sorted(deprecated_renamed_keys)}\n        renamed_bullets = [f'* {k!r} has been renamed to {v!r}' for k, v in renamings.items()]\n        removed_bullets = [f'* {k!r} has been removed' for k in sorted(deprecated_removed_keys)]\n        message = '\\n'.join(['Valid config keys have changed in V2:'] + renamed_bullets + removed_bullets)\n        warnings.warn(message, UserWarning)\n\n\n--- File: 3 # _internal/_core_metadata.py ---\nfrom __future__ import annotations as _annotations\n\nfrom typing import TYPE_CHECKING, Any, TypedDict, cast\nfrom warnings import warn\n\nif TYPE_CHECKING:\n    from ..config import JsonDict, JsonSchemaExtraCallable\n    from ._schema_generation_shared import (\n        GetJsonSchemaFunction,\n    )\n\n\nclass CoreMetadata(TypedDict, total=False):\n    \"\"\"A `TypedDict` for holding the metadata dict of the schema.\n\n    Attributes:\n        pydantic_js_functions: List of JSON schema functions that resolve refs during application.\n        pydantic_js_annotation_functions: List of JSON schema functions that don't resolve refs during application.\n        pydantic_js_prefer_positional_arguments: Whether JSON schema generator will\n            prefer positional over keyword arguments for an 'arguments' schema.\n            custom validation function. Only applies to before, plain, and wrap validators.\n        pydantic_js_updates: key / value pair updates to apply to the JSON schema for a type.\n        pydantic_js_extra: WIP, either key/value pair updates to apply to the JSON schema, or a custom callable.\n        pydantic_internal_union_tag_key: Used internally by the `Tag` metadata to specify the tag used for a discriminated union.\n        pydantic_internal_union_discriminator: Used internally to specify the discriminator value for a discriminated union\n            when the discriminator was applied to a `'definition-ref'` schema, and that reference was missing at the time\n            of the annotation application.\n\n    TODO: Perhaps we should move this structure to pydantic-core. At the moment, though,\n    it's easier to iterate on if we leave it in pydantic until we feel there is a semi-stable API.\n\n    TODO: It's unfortunate how functionally oriented JSON schema generation is, especially that which occurs during\n    the core schema generation process. It's inevitable that we need to store some json schema related information\n    on core schemas, given that we generate JSON schemas directly from core schemas. That being said, debugging related\n    issues is quite difficult when JSON schema information is disguised via dynamically defined functions.\n    \"\"\"\n\n    pydantic_js_functions: list[GetJsonSchemaFunction]\n    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n    pydantic_js_prefer_positional_arguments: bool\n    pydantic_js_updates: JsonDict\n    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable\n    pydantic_internal_union_tag_key: str\n    pydantic_internal_union_discriminator: str\n\n\ndef update_core_metadata(\n    core_metadata: Any,\n    /,\n    *,\n    pydantic_js_functions: list[GetJsonSchemaFunction] | None = None,\n    pydantic_js_annotation_functions: list[GetJsonSchemaFunction] | None = None,\n    pydantic_js_updates: JsonDict | None = None,\n    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable | None = None,\n) -> None:\n    from ..json_schema import PydanticJsonSchemaWarning\n\n    \"\"\"Update CoreMetadata instance in place. When we make modifications in this function, they\n    take effect on the `core_metadata` reference passed in as the first (and only) positional argument.\n\n    First, cast to `CoreMetadata`, then finish with a cast to `dict[str, Any]` for core schema compatibility.\n    We do this here, instead of before / after each call to this function so that this typing hack\n    can be easily removed if/when we move `CoreMetadata` to `pydantic-core`.\n\n    For parameter descriptions, see `CoreMetadata` above.\n    \"\"\"\n    core_metadata = cast(CoreMetadata, core_metadata)\n\n    if pydantic_js_functions:\n        core_metadata.setdefault('pydantic_js_functions', []).extend(pydantic_js_functions)\n\n    if pydantic_js_annotation_functions:\n        core_metadata.setdefault('pydantic_js_annotation_functions', []).extend(pydantic_js_annotation_functions)\n\n    if pydantic_js_updates:\n        if (existing_updates := core_metadata.get('pydantic_js_updates')) is not None:\n            core_metadata['pydantic_js_updates'] = {**existing_updates, **pydantic_js_updates}\n        else:\n            core_metadata['pydantic_js_updates'] = pydantic_js_updates\n\n    if pydantic_js_extra is not None:\n        existing_pydantic_js_extra = core_metadata.get('pydantic_js_extra')\n        if existing_pydantic_js_extra is None:\n            core_metadata['pydantic_js_extra'] = pydantic_js_extra\n        if isinstance(existing_pydantic_js_extra, dict):\n            if isinstance(pydantic_js_extra, dict):\n                core_metadata['pydantic_js_extra'] = {**existing_pydantic_js_extra, **pydantic_js_extra}\n            if callable(pydantic_js_extra):\n                warn(\n                    'Composing `dict` and `callable` type `json_schema_extra` is not supported.'\n                    'The `callable` type is being ignored.'\n                    \"If you'd like support for this behavior, please open an issue on pydantic.\",\n                    PydanticJsonSchemaWarning,\n                )\n        if callable(existing_pydantic_js_extra):\n            # if ever there's a case of a callable, we'll just keep the last json schema extra spec\n            core_metadata['pydantic_js_extra'] = pydantic_js_extra\n\n\n--- File: 4 # _internal/_core_utils.py ---\nfrom __future__ import annotations\n\nimport inspect\nimport os\nfrom collections.abc import Mapping, Sequence\nfrom typing import TYPE_CHECKING, Any, Union\n\nfrom pydantic_core import CoreSchema, core_schema\nfrom pydantic_core import validate_core_schema as _validate_core_schema\nfrom typing_extensions import TypeGuard, get_args, get_origin\nfrom typing_inspection import typing_objects\n\nfrom . import _repr\nfrom ._typing_extra import is_generic_alias\n\nif TYPE_CHECKING:\n    from rich.console import Console\n\nAnyFunctionSchema = Union[\n    core_schema.AfterValidatorFunctionSchema,\n    core_schema.BeforeValidatorFunctionSchema,\n    core_schema.WrapValidatorFunctionSchema,\n    core_schema.PlainValidatorFunctionSchema,\n]\n\n\nFunctionSchemaWithInnerSchema = Union[\n    core_schema.AfterValidatorFunctionSchema,\n    core_schema.BeforeValidatorFunctionSchema,\n    core_schema.WrapValidatorFunctionSchema,\n]\n\nCoreSchemaField = Union[\n    core_schema.ModelField, core_schema.DataclassField, core_schema.TypedDictField, core_schema.ComputedField\n]\nCoreSchemaOrField = Union[core_schema.CoreSchema, CoreSchemaField]\n\n_CORE_SCHEMA_FIELD_TYPES = {'typed-dict-field', 'dataclass-field', 'model-field', 'computed-field'}\n_FUNCTION_WITH_INNER_SCHEMA_TYPES = {'function-before', 'function-after', 'function-wrap'}\n_LIST_LIKE_SCHEMA_WITH_ITEMS_TYPES = {'list', 'set', 'frozenset'}\n\n\ndef is_core_schema(\n    schema: CoreSchemaOrField,\n) -> TypeGuard[CoreSchema]:\n    return schema['type'] not in _CORE_SCHEMA_FIELD_TYPES\n\n\ndef is_core_schema_field(\n    schema: CoreSchemaOrField,\n) -> TypeGuard[CoreSchemaField]:\n    return schema['type'] in _CORE_SCHEMA_FIELD_TYPES\n\n\ndef is_function_with_inner_schema(\n    schema: CoreSchemaOrField,\n) -> TypeGuard[FunctionSchemaWithInnerSchema]:\n    return schema['type'] in _FUNCTION_WITH_INNER_SCHEMA_TYPES\n\n\ndef is_list_like_schema_with_items_schema(\n    schema: CoreSchema,\n) -> TypeGuard[core_schema.ListSchema | core_schema.SetSchema | core_schema.FrozenSetSchema]:\n    return schema['type'] in _LIST_LIKE_SCHEMA_WITH_ITEMS_TYPES\n\n\ndef get_type_ref(type_: Any, args_override: tuple[type[Any], ...] | None = None) -> str:\n    \"\"\"Produces the ref to be used for this type by pydantic_core's core schemas.\n\n    This `args_override` argument was added for the purpose of creating valid recursive references\n    when creating generic models without needing to create a concrete class.\n    \"\"\"\n    origin = get_origin(type_) or type_\n\n    args = get_args(type_) if is_generic_alias(type_) else (args_override or ())\n    generic_metadata = getattr(type_, '__pydantic_generic_metadata__', None)\n    if generic_metadata:\n        origin = generic_metadata['origin'] or origin\n        args = generic_metadata['args'] or args\n\n    module_name = getattr(origin, '__module__', '<No __module__>')\n    if typing_objects.is_typealiastype(origin):\n        type_ref = f'{module_name}.{origin.__name__}:{id(origin)}'\n    else:\n        try:\n            qualname = getattr(origin, '__qualname__', f'<No __qualname__: {origin}>')\n        except Exception:\n            qualname = getattr(origin, '__qualname__', '<No __qualname__>')\n        type_ref = f'{module_name}.{qualname}:{id(origin)}'\n\n    arg_refs: list[str] = []\n    for arg in args:\n        if isinstance(arg, str):\n            # Handle string literals as a special case; we may be able to remove this special handling if we\n            # wrap them in a ForwardRef at some point.\n            arg_ref = f'{arg}:str-{id(arg)}'\n        else:\n            arg_ref = f'{_repr.display_as_type(arg)}:{id(arg)}'\n        arg_refs.append(arg_ref)\n    if arg_refs:\n        type_ref = f'{type_ref}[{\",\".join(arg_refs)}]'\n    return type_ref\n\n\ndef get_ref(s: core_schema.CoreSchema) -> None | str:\n    \"\"\"Get the ref from the schema if it has one.\n    This exists just for type checking to work correctly.\n    \"\"\"\n    return s.get('ref', None)\n\n\ndef validate_core_schema(schema: CoreSchema) -> CoreSchema:\n    if os.getenv('PYDANTIC_VALIDATE_CORE_SCHEMAS'):\n        return _validate_core_schema(schema)\n    return schema\n\n\ndef _clean_schema_for_pretty_print(obj: Any, strip_metadata: bool = True) -> Any:  # pragma: no cover\n    \"\"\"A utility function to remove irrelevant information from a core schema.\"\"\"\n    if isinstance(obj, Mapping):\n        new_dct = {}\n        for k, v in obj.items():\n            if k == 'metadata' and strip_metadata:\n                new_metadata = {}\n\n                for meta_k, meta_v in v.items():\n                    if meta_k in ('pydantic_js_functions', 'pydantic_js_annotation_functions'):\n                        new_metadata['js_metadata'] = '<stripped>'\n                    else:\n                        new_metadata[meta_k] = _clean_schema_for_pretty_print(meta_v, strip_metadata=strip_metadata)\n\n                if list(new_metadata.keys()) == ['js_metadata']:\n                    new_metadata = {'<stripped>'}\n\n                new_dct[k] = new_metadata\n            # Remove some defaults:\n            elif k in ('custom_init', 'root_model') and not v:\n                continue\n            else:\n                new_dct[k] = _clean_schema_for_pretty_print(v, strip_metadata=strip_metadata)\n\n        return new_dct\n    elif isinstance(obj, Sequence) and not isinstance(obj, str):\n        return [_clean_schema_for_pretty_print(v, strip_metadata=strip_metadata) for v in obj]\n    else:\n        return obj\n\n\ndef pretty_print_core_schema(\n    val: Any,\n    *,\n    console: Console | None = None,\n    max_depth: int | None = None,\n    strip_metadata: bool = True,\n) -> None:  # pragma: no cover\n    \"\"\"Pretty-print a core schema using the `rich` library.\n\n    Args:\n        val: The core schema to print, or a Pydantic model/dataclass/type adapter\n            (in which case the cached core schema is fetched and printed).\n        console: A rich console to use when printing. Defaults to the global rich console instance.\n        max_depth: The number of nesting levels which may be printed.\n        strip_metadata: Whether to strip metadata in the output. If `True` any known core metadata\n            attributes will be stripped (but custom attributes are kept). Defaults to `True`.\n    \"\"\"\n    # lazy import:\n    from rich.pretty import pprint\n\n    # circ. imports:\n    from pydantic import BaseModel, TypeAdapter\n    from pydantic.dataclasses import is_pydantic_dataclass\n\n    if (inspect.isclass(val) and issubclass(val, BaseModel)) or is_pydantic_dataclass(val):\n        val = val.__pydantic_core_schema__\n    if isinstance(val, TypeAdapter):\n        val = val.core_schema\n    cleaned_schema = _clean_schema_for_pretty_print(val, strip_metadata=strip_metadata)\n\n    pprint(cleaned_schema, console=console, max_depth=max_depth)\n\n\npps = pretty_print_core_schema\n\n\n--- File: 5 # _internal/_dataclasses.py ---\n\"\"\"Private logic for creating pydantic dataclasses.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport dataclasses\nimport typing\nimport warnings\nfrom functools import partial, wraps\nfrom typing import Any, ClassVar\n\nfrom pydantic_core import (\n    ArgsKwargs,\n    SchemaSerializer,\n    SchemaValidator,\n    core_schema,\n)\nfrom typing_extensions import TypeGuard\n\nfrom ..errors import PydanticUndefinedAnnotation\nfrom ..plugin._schema_validator import PluggableSchemaValidator, create_schema_validator\nfrom ..warnings import PydanticDeprecatedSince20\nfrom . import _config, _decorators\nfrom ._fields import collect_dataclass_fields\nfrom ._generate_schema import GenerateSchema, InvalidSchemaError\nfrom ._generics import get_standard_typevars_map\nfrom ._mock_val_ser import set_dataclass_mocks\nfrom ._namespace_utils import NsResolver\nfrom ._signature import generate_pydantic_signature\nfrom ._utils import LazyClassAttribute\n\nif typing.TYPE_CHECKING:\n    from _typeshed import DataclassInstance as StandardDataclass\n\n    from ..config import ConfigDict\n    from ..fields import FieldInfo\n\n    class PydanticDataclass(StandardDataclass, typing.Protocol):\n        \"\"\"A protocol containing attributes only available once a class has been decorated as a Pydantic dataclass.\n\n        Attributes:\n            __pydantic_config__: Pydantic-specific configuration settings for the dataclass.\n            __pydantic_complete__: Whether dataclass building is completed, or if there are still undefined fields.\n            __pydantic_core_schema__: The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\n            __pydantic_decorators__: Metadata containing the decorators defined on the dataclass.\n            __pydantic_fields__: Metadata about the fields defined on the dataclass.\n            __pydantic_serializer__: The pydantic-core SchemaSerializer used to dump instances of the dataclass.\n            __pydantic_validator__: The pydantic-core SchemaValidator used to validate instances of the dataclass.\n        \"\"\"\n\n        __pydantic_config__: ClassVar[ConfigDict]\n        __pydantic_complete__: ClassVar[bool]\n        __pydantic_core_schema__: ClassVar[core_schema.CoreSchema]\n        __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos]\n        __pydantic_fields__: ClassVar[dict[str, FieldInfo]]\n        __pydantic_serializer__: ClassVar[SchemaSerializer]\n        __pydantic_validator__: ClassVar[SchemaValidator | PluggableSchemaValidator]\n\nelse:\n    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915\n    # and https://youtrack.jetbrains.com/issue/PY-51428\n    DeprecationWarning = PydanticDeprecatedSince20\n\n\ndef set_dataclass_fields(\n    cls: type[StandardDataclass],\n    ns_resolver: NsResolver | None = None,\n    config_wrapper: _config.ConfigWrapper | None = None,\n) -> None:\n    \"\"\"Collect and set `cls.__pydantic_fields__`.\n\n    Args:\n        cls: The class.\n        ns_resolver: Namespace resolver to use when getting dataclass annotations.\n        config_wrapper: The config wrapper instance, defaults to `None`.\n    \"\"\"\n    typevars_map = get_standard_typevars_map(cls)\n    fields = collect_dataclass_fields(\n        cls, ns_resolver=ns_resolver, typevars_map=typevars_map, config_wrapper=config_wrapper\n    )\n\n    cls.__pydantic_fields__ = fields  # type: ignore\n\n\ndef complete_dataclass(\n    cls: type[Any],\n    config_wrapper: _config.ConfigWrapper,\n    *,\n    raise_errors: bool = True,\n    ns_resolver: NsResolver | None = None,\n    _force_build: bool = False,\n) -> bool:\n    \"\"\"Finish building a pydantic dataclass.\n\n    This logic is called on a class which has already been wrapped in `dataclasses.dataclass()`.\n\n    This is somewhat analogous to `pydantic._internal._model_construction.complete_model_class`.\n\n    Args:\n        cls: The class.\n        config_wrapper: The config wrapper instance.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        ns_resolver: The namespace resolver instance to use when collecting dataclass fields\n            and during schema building.\n        _force_build: Whether to force building the dataclass, no matter if\n            [`defer_build`][pydantic.config.ConfigDict.defer_build] is set.\n\n    Returns:\n        `True` if building a pydantic dataclass is successfully completed, `False` otherwise.\n\n    Raises:\n        PydanticUndefinedAnnotation: If `raise_error` is `True` and there is an undefined annotations.\n    \"\"\"\n    original_init = cls.__init__\n\n    # dataclass.__init__ must be defined here so its `__qualname__` can be changed since functions can't be copied,\n    # and so that the mock validator is used if building was deferred:\n    def __init__(__dataclass_self__: PydanticDataclass, *args: Any, **kwargs: Any) -> None:\n        __tracebackhide__ = True\n        s = __dataclass_self__\n        s.__pydantic_validator__.validate_python(ArgsKwargs(args, kwargs), self_instance=s)\n\n    __init__.__qualname__ = f'{cls.__qualname__}.__init__'\n\n    cls.__init__ = __init__  # type: ignore\n    cls.__pydantic_config__ = config_wrapper.config_dict  # type: ignore\n\n    set_dataclass_fields(cls, ns_resolver, config_wrapper=config_wrapper)\n\n    if not _force_build and config_wrapper.defer_build:\n        set_dataclass_mocks(cls)\n        return False\n\n    if hasattr(cls, '__post_init_post_parse__'):\n        warnings.warn(\n            'Support for `__post_init_post_parse__` has been dropped, the method will not be called', DeprecationWarning\n        )\n\n    typevars_map = get_standard_typevars_map(cls)\n    gen_schema = GenerateSchema(\n        config_wrapper,\n        ns_resolver=ns_resolver,\n        typevars_map=typevars_map,\n    )\n\n    # set __signature__ attr only for the class, but not for its instances\n    # (because instances can define `__call__`, and `inspect.signature` shouldn't\n    # use the `__signature__` attribute and instead generate from `__call__`).\n    cls.__signature__ = LazyClassAttribute(\n        '__signature__',\n        partial(\n            generate_pydantic_signature,\n            # It's important that we reference the `original_init` here,\n            # as it is the one synthesized by the stdlib `dataclass` module:\n            init=original_init,\n            fields=cls.__pydantic_fields__,  # type: ignore\n            validate_by_name=config_wrapper.validate_by_name,\n            extra=config_wrapper.extra,\n            is_dataclass=True,\n        ),\n    )\n\n    try:\n        schema = gen_schema.generate_schema(cls)\n    except PydanticUndefinedAnnotation as e:\n        if raise_errors:\n            raise\n        set_dataclass_mocks(cls, f'`{e.name}`')\n        return False\n\n    core_config = config_wrapper.core_config(title=cls.__name__)\n\n    try:\n        schema = gen_schema.clean_schema(schema)\n    except InvalidSchemaError:\n        set_dataclass_mocks(cls)\n        return False\n\n    # We are about to set all the remaining required properties expected for this cast;\n    # __pydantic_decorators__ and __pydantic_fields__ should already be set\n    cls = typing.cast('type[PydanticDataclass]', cls)\n    # debug(schema)\n\n    cls.__pydantic_core_schema__ = schema\n    cls.__pydantic_validator__ = validator = create_schema_validator(\n        schema, cls, cls.__module__, cls.__qualname__, 'dataclass', core_config, config_wrapper.plugin_settings\n    )\n    cls.__pydantic_serializer__ = SchemaSerializer(schema, core_config)\n\n    if config_wrapper.validate_assignment:\n\n        @wraps(cls.__setattr__)\n        def validated_setattr(instance: Any, field: str, value: str, /) -> None:\n            validator.validate_assignment(instance, field, value)\n\n        cls.__setattr__ = validated_setattr.__get__(None, cls)  # type: ignore\n\n    cls.__pydantic_complete__ = True\n    return True\n\n\ndef is_builtin_dataclass(_cls: type[Any]) -> TypeGuard[type[StandardDataclass]]:\n    \"\"\"Returns True if a class is a stdlib dataclass and *not* a pydantic dataclass.\n\n    We check that\n    - `_cls` is a dataclass\n    - `_cls` does not inherit from a processed pydantic dataclass (and thus have a `__pydantic_validator__`)\n    - `_cls` does not have any annotations that are not dataclass fields\n    e.g.\n    ```python\n    import dataclasses\n\n    import pydantic.dataclasses\n\n    @dataclasses.dataclass\n    class A:\n        x: int\n\n    @pydantic.dataclasses.dataclass\n    class B(A):\n        y: int\n    ```\n    In this case, when we first check `B`, we make an extra check and look at the annotations ('y'),\n    which won't be a superset of all the dataclass fields (only the stdlib fields i.e. 'x')\n\n    Args:\n        cls: The class.\n\n    Returns:\n        `True` if the class is a stdlib dataclass, `False` otherwise.\n    \"\"\"\n    return (\n        dataclasses.is_dataclass(_cls)\n        and not hasattr(_cls, '__pydantic_validator__')\n        and set(_cls.__dataclass_fields__).issuperset(set(getattr(_cls, '__annotations__', {})))\n    )\n\n\n--- File: 6 # _internal/_decorators.py ---\n\"\"\"Logic related to validators applied to models etc. via the `@field_validator` and `@model_validator` decorators.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport types\nfrom collections import deque\nfrom collections.abc import Iterable\nfrom dataclasses import dataclass, field\nfrom functools import cached_property, partial, partialmethod\nfrom inspect import Parameter, Signature, isdatadescriptor, ismethoddescriptor, signature\nfrom itertools import islice\nfrom typing import TYPE_CHECKING, Any, Callable, ClassVar, Generic, Literal, TypeVar, Union\n\nfrom pydantic_core import PydanticUndefined, PydanticUndefinedType, core_schema\nfrom typing_extensions import TypeAlias, is_typeddict\n\nfrom ..errors import PydanticUserError\nfrom ._core_utils import get_type_ref\nfrom ._internal_dataclass import slots_true\nfrom ._namespace_utils import GlobalsNamespace, MappingNamespace\nfrom ._typing_extra import get_function_type_hints\nfrom ._utils import can_be_positional\n\nif TYPE_CHECKING:\n    from ..fields import ComputedFieldInfo\n    from ..functional_validators import FieldValidatorModes\n\n\n@dataclass(**slots_true)\nclass ValidatorDecoratorInfo:\n    \"\"\"A container for data from `@validator` so that we can access it\n    while building the pydantic-core schema.\n\n    Attributes:\n        decorator_repr: A class variable representing the decorator string, '@validator'.\n        fields: A tuple of field names the validator should be called on.\n        mode: The proposed validator mode.\n        each_item: For complex objects (sets, lists etc.) whether to validate individual\n            elements rather than the whole object.\n        always: Whether this method and other validators should be called even if the value is missing.\n        check_fields: Whether to check that the fields actually exist on the model.\n    \"\"\"\n\n    decorator_repr: ClassVar[str] = '@validator'\n\n    fields: tuple[str, ...]\n    mode: Literal['before', 'after']\n    each_item: bool\n    always: bool\n    check_fields: bool | None\n\n\n@dataclass(**slots_true)\nclass FieldValidatorDecoratorInfo:\n    \"\"\"A container for data from `@field_validator` so that we can access it\n    while building the pydantic-core schema.\n\n    Attributes:\n        decorator_repr: A class variable representing the decorator string, '@field_validator'.\n        fields: A tuple of field names the validator should be called on.\n        mode: The proposed validator mode.\n        check_fields: Whether to check that the fields actually exist on the model.\n        json_schema_input_type: The input type of the function. This is only used to generate\n            the appropriate JSON Schema (in validation mode) and can only specified\n            when `mode` is either `'before'`, `'plain'` or `'wrap'`.\n    \"\"\"\n\n    decorator_repr: ClassVar[str] = '@field_validator'\n\n    fields: tuple[str, ...]\n    mode: FieldValidatorModes\n    check_fields: bool | None\n    json_schema_input_type: Any\n\n\n@dataclass(**slots_true)\nclass RootValidatorDecoratorInfo:\n    \"\"\"A container for data from `@root_validator` so that we can access it\n    while building the pydantic-core schema.\n\n    Attributes:\n        decorator_repr: A class variable representing the decorator string, '@root_validator'.\n        mode: The proposed validator mode.\n    \"\"\"\n\n    decorator_repr: ClassVar[str] = '@root_validator'\n    mode: Literal['before', 'after']\n\n\n@dataclass(**slots_true)\nclass FieldSerializerDecoratorInfo:\n    \"\"\"A container for data from `@field_serializer` so that we can access it\n    while building the pydantic-core schema.\n\n    Attributes:\n        decorator_repr: A class variable representing the decorator string, '@field_serializer'.\n        fields: A tuple of field names the serializer should be called on.\n        mode: The proposed serializer mode.\n        return_type: The type of the serializer's return value.\n        when_used: The serialization condition. Accepts a string with values `'always'`, `'unless-none'`, `'json'`,\n            and `'json-unless-none'`.\n        check_fields: Whether to check that the fields actually exist on the model.\n    \"\"\"\n\n    decorator_repr: ClassVar[str] = '@field_serializer'\n    fields: tuple[str, ...]\n    mode: Literal['plain', 'wrap']\n    return_type: Any\n    when_used: core_schema.WhenUsed\n    check_fields: bool | None\n\n\n@dataclass(**slots_true)\nclass ModelSerializerDecoratorInfo:\n    \"\"\"A container for data from `@model_serializer` so that we can access it\n    while building the pydantic-core schema.\n\n    Attributes:\n        decorator_repr: A class variable representing the decorator string, '@model_serializer'.\n        mode: The proposed serializer mode.\n        return_type: The type of the serializer's return value.\n        when_used: The serialization condition. Accepts a string with values `'always'`, `'unless-none'`, `'json'`,\n            and `'json-unless-none'`.\n    \"\"\"\n\n    decorator_repr: ClassVar[str] = '@model_serializer'\n    mode: Literal['plain', 'wrap']\n    return_type: Any\n    when_used: core_schema.WhenUsed\n\n\n@dataclass(**slots_true)\nclass ModelValidatorDecoratorInfo:\n    \"\"\"A container for data from `@model_validator` so that we can access it\n    while building the pydantic-core schema.\n\n    Attributes:\n        decorator_repr: A class variable representing the decorator string, '@model_validator'.\n        mode: The proposed serializer mode.\n    \"\"\"\n\n    decorator_repr: ClassVar[str] = '@model_validator'\n    mode: Literal['wrap', 'before', 'after']\n\n\nDecoratorInfo: TypeAlias = \"\"\"Union[\n    ValidatorDecoratorInfo,\n    FieldValidatorDecoratorInfo,\n    RootValidatorDecoratorInfo,\n    FieldSerializerDecoratorInfo,\n    ModelSerializerDecoratorInfo,\n    ModelValidatorDecoratorInfo,\n    ComputedFieldInfo,\n]\"\"\"\n\nReturnType = TypeVar('ReturnType')\nDecoratedType: TypeAlias = (\n    'Union[classmethod[Any, Any, ReturnType], staticmethod[Any, ReturnType], Callable[..., ReturnType], property]'\n)\n\n\n@dataclass  # can't use slots here since we set attributes on `__post_init__`\nclass PydanticDescriptorProxy(Generic[ReturnType]):\n    \"\"\"Wrap a classmethod, staticmethod, property or unbound function\n    and act as a descriptor that allows us to detect decorated items\n    from the class' attributes.\n\n    This class' __get__ returns the wrapped item's __get__ result,\n    which makes it transparent for classmethods and staticmethods.\n\n    Attributes:\n        wrapped: The decorator that has to be wrapped.\n        decorator_info: The decorator info.\n        shim: A wrapper function to wrap V1 style function.\n    \"\"\"\n\n    wrapped: DecoratedType[ReturnType]\n    decorator_info: DecoratorInfo\n    shim: Callable[[Callable[..., Any]], Callable[..., Any]] | None = None\n\n    def __post_init__(self):\n        for attr in 'setter', 'deleter':\n            if hasattr(self.wrapped, attr):\n                f = partial(self._call_wrapped_attr, name=attr)\n                setattr(self, attr, f)\n\n    def _call_wrapped_attr(self, func: Callable[[Any], None], *, name: str) -> PydanticDescriptorProxy[ReturnType]:\n        self.wrapped = getattr(self.wrapped, name)(func)\n        if isinstance(self.wrapped, property):\n            # update ComputedFieldInfo.wrapped_property\n            from ..fields import ComputedFieldInfo\n\n            if isinstance(self.decorator_info, ComputedFieldInfo):\n                self.decorator_info.wrapped_property = self.wrapped\n        return self\n\n    def __get__(self, obj: object | None, obj_type: type[object] | None = None) -> PydanticDescriptorProxy[ReturnType]:\n        try:\n            return self.wrapped.__get__(obj, obj_type)\n        except AttributeError:\n            # not a descriptor, e.g. a partial object\n            return self.wrapped  # type: ignore[return-value]\n\n    def __set_name__(self, instance: Any, name: str) -> None:\n        if hasattr(self.wrapped, '__set_name__'):\n            self.wrapped.__set_name__(instance, name)  # pyright: ignore[reportFunctionMemberAccess]\n\n    def __getattr__(self, name: str, /) -> Any:\n        \"\"\"Forward checks for __isabstractmethod__ and such.\"\"\"\n        return getattr(self.wrapped, name)\n\n\nDecoratorInfoType = TypeVar('DecoratorInfoType', bound=DecoratorInfo)\n\n\n@dataclass(**slots_true)\nclass Decorator(Generic[DecoratorInfoType]):\n    \"\"\"A generic container class to join together the decorator metadata\n    (metadata from decorator itself, which we have when the\n    decorator is called but not when we are building the core-schema)\n    and the bound function (which we have after the class itself is created).\n\n    Attributes:\n        cls_ref: The class ref.\n        cls_var_name: The decorated function name.\n        func: The decorated function.\n        shim: A wrapper function to wrap V1 style function.\n        info: The decorator info.\n    \"\"\"\n\n    cls_ref: str\n    cls_var_name: str\n    func: Callable[..., Any]\n    shim: Callable[[Any], Any] | None\n    info: DecoratorInfoType\n\n    @staticmethod\n    def build(\n        cls_: Any,\n        *,\n        cls_var_name: str,\n        shim: Callable[[Any], Any] | None,\n        info: DecoratorInfoType,\n    ) -> Decorator[DecoratorInfoType]:\n        \"\"\"Build a new decorator.\n\n        Args:\n            cls_: The class.\n            cls_var_name: The decorated function name.\n            shim: A wrapper function to wrap V1 style function.\n            info: The decorator info.\n\n        Returns:\n            The new decorator instance.\n        \"\"\"\n        func = get_attribute_from_bases(cls_, cls_var_name)\n        if shim is not None:\n            func = shim(func)\n        func = unwrap_wrapped_function(func, unwrap_partial=False)\n        if not callable(func):\n            # This branch will get hit for classmethod properties\n            attribute = get_attribute_from_base_dicts(cls_, cls_var_name)  # prevents the binding call to `__get__`\n            if isinstance(attribute, PydanticDescriptorProxy):\n                func = unwrap_wrapped_function(attribute.wrapped)\n        return Decorator(\n            cls_ref=get_type_ref(cls_),\n            cls_var_name=cls_var_name,\n            func=func,\n            shim=shim,\n            info=info,\n        )\n\n    def bind_to_cls(self, cls: Any) -> Decorator[DecoratorInfoType]:\n        \"\"\"Bind the decorator to a class.\n\n        Args:\n            cls: the class.\n\n        Returns:\n            The new decorator instance.\n        \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,\n            info=self.info,\n        )\n\n\ndef get_bases(tp: type[Any]) -> tuple[type[Any], ...]:\n    \"\"\"Get the base classes of a class or typeddict.\n\n    Args:\n        tp: The type or class to get the bases.\n\n    Returns:\n        The base classes.\n    \"\"\"\n    if is_typeddict(tp):\n        return tp.__orig_bases__  # type: ignore\n    try:\n        return tp.__bases__\n    except AttributeError:\n        return ()\n\n\ndef mro(tp: type[Any]) -> tuple[type[Any], ...]:\n    \"\"\"Calculate the Method Resolution Order of bases using the C3 algorithm.\n\n    See https://www.python.org/download/releases/2.3/mro/\n    \"\"\"\n    # try to use the existing mro, for performance mainly\n    # but also because it helps verify the implementation below\n    if not is_typeddict(tp):\n        try:\n            return tp.__mro__\n        except AttributeError:\n            # GenericAlias and some other cases\n            pass\n\n    bases = get_bases(tp)\n    return (tp,) + mro_for_bases(bases)\n\n\ndef mro_for_bases(bases: tuple[type[Any], ...]) -> tuple[type[Any], ...]:\n    def merge_seqs(seqs: list[deque[type[Any]]]) -> Iterable[type[Any]]:\n        while True:\n            non_empty = [seq for seq in seqs if seq]\n            if not non_empty:\n                # Nothing left to process, we're done.\n                return\n            candidate: type[Any] | None = None\n            for seq in non_empty:  # Find merge candidates among seq heads.\n                candidate = seq[0]\n                not_head = [s for s in non_empty if candidate in islice(s, 1, None)]\n                if not_head:\n                    # Reject the candidate.\n                    candidate = None\n                else:\n                    break\n            if not candidate:\n                raise TypeError('Inconsistent hierarchy, no C3 MRO is possible')\n            yield candidate\n            for seq in non_empty:\n                # Remove candidate.\n                if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribute_from_bases(tp: type[Any] | tuple[type[Any], ...], name: str) -> Any:\n    \"\"\"Get the attribute from the next class in the MRO that has it,\n    aiming to simulate calling the method on the actual class.\n\n    The reason for iterating over the mro instead of just getting\n    the attribute (which would do that for us) is to support TypedDict,\n    which lacks a real __mro__, but can have a virtual one constructed\n    from its bases (as done here).\n\n    Args:\n        tp: The type or class to search for the attribute. If a tuple, this is treated as a set of base classes.\n        name: The name of the attribute to retrieve.\n\n    Returns:\n        Any: The attribute value, if found.\n\n    Raises:\n        AttributeError: If the attribute is not found in any class in the MRO.\n    \"\"\"\n    if isinstance(tp, tuple):\n        for base in mro_for_bases(tp):\n            attribute = base.__dict__.get(name, _sentinel)\n            if attribute is not _sentinel:\n                attribute_get = getattr(attribute, '__get__', None)\n                if attribute_get is not None:\n                    return attribute_get(None, tp)\n                return attribute\n        raise AttributeError(f'{name} not found in {tp}')\n    else:\n        try:\n            return getattr(tp, name)\n        except AttributeError:\n            return get_attribute_from_bases(mro(tp), name)\n\n\ndef get_attribute_from_base_dicts(tp: type[Any], name: str) -> Any:\n    \"\"\"Get an attribute out of the `__dict__` following the MRO.\n    This prevents the call to `__get__` on the descriptor, and allows\n    us to get the original function for classmethod properties.\n\n    Args:\n        tp: The type or class to search for the attribute.\n        name: The name of the attribute to retrieve.\n\n    Returns:\n        Any: The attribute value, if found.\n\n    Raises:\n        KeyError: If the attribute is not found in any class's `__dict__` in the MRO.\n    \"\"\"\n    for base in reversed(mro(tp)):\n        if name in base.__dict__:\n            return base.__dict__[name]\n    return tp.__dict__[name]  # raise the error\n\n\n@dataclass(**slots_true)\nclass DecoratorInfos:\n    \"\"\"Mapping of name in the class namespace to decorator info.\n\n    note that the name in the class namespace is the function or attribute name\n    not the field name!\n    \"\"\"\n\n    validators: dict[str, Decorator[ValidatorDecoratorInfo]] = field(default_factory=dict)\n    field_validators: dict[str, Decorator[FieldValidatorDecoratorInfo]] = field(default_factory=dict)\n    root_validators: dict[str, Decorator[RootValidatorDecoratorInfo]] = field(default_factory=dict)\n    field_serializers: dict[str, Decorator[FieldSerializerDecoratorInfo]] = field(default_factory=dict)\n    model_serializers: dict[str, Decorator[ModelSerializerDecoratorInfo]] = field(default_factory=dict)\n    model_validators: dict[str, Decorator[ModelValidatorDecoratorInfo]] = field(default_factory=dict)\n    computed_fields: dict[str, Decorator[ComputedFieldInfo]] = field(default_factory=dict)\n\n    @staticmethod\n    def build(model_dc: type[Any]) -> DecoratorInfos:  # noqa: C901 (ignore complexity)\n        \"\"\"We want to collect all DecFunc instances that exist as\n        attributes in the namespace of the class (a BaseModel or dataclass)\n        that called us\n        But we want to collect these in the order of the bases\n        So instead of getting them all from the leaf class (the class that called us),\n        we traverse the bases from root (the oldest ancestor class) to leaf\n        and collect all of the instances as we go, taking care to replace\n        any duplicate ones with the last one we see to mimic how function overriding\n        works with inheritance.\n        If we do replace any functions we put the replacement into the position\n        the replaced function was in; that is, we maintain the order.\n        \"\"\"\n        # reminder: dicts are ordered and replacement does not alter the order\n        res = DecoratorInfos()\n        for base in reversed(mro(model_dc)[1:]):\n            existing: DecoratorInfos | None = base.__dict__.get('__pydantic_decorators__')\n            if existing is None:\n                existing = DecoratorInfos.build(base)\n            res.validators.update({k: v.bind_to_cls(model_dc) for k, v in existing.validators.items()})\n            res.field_validators.update({k: v.bind_to_cls(model_dc) for k, v in existing.field_validators.items()})\n            res.root_validators.update({k: v.bind_to_cls(model_dc) for k, v in existing.root_validators.items()})\n            res.field_serializers.update({k: v.bind_to_cls(model_dc) for k, v in existing.field_serializers.items()})\n            res.model_serializers.update({k: v.bind_to_cls(model_dc) for k, v in existing.model_serializers.items()})\n            res.model_validators.update({k: v.bind_to_cls(model_dc) for k, v in existing.model_validators.items()})\n            res.computed_fields.update({k: v.bind_to_cls(model_dc) for k, v in existing.computed_fields.items()})\n\n        to_replace: list[tuple[str, Any]] = []\n\n        for var_name, var_value in vars(model_dc).items():\n            if isinstance(var_value, PydanticDescriptorProxy):\n                info = var_value.decorator_info\n                if isinstance(info, ValidatorDecoratorInfo):\n                    res.validators[var_name] = Decorator.build(\n                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info\n                    )\n                elif isinstance(info, FieldValidatorDecoratorInfo):\n                    res.field_validators[var_name] = Decorator.build(\n                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info\n                    )\n                elif isinstance(info, RootValidatorDecoratorInfo):\n                    res.root_validators[var_name] = Decorator.build(\n                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info\n                    )\n                elif isinstance(info, FieldSerializerDecoratorInfo):\n                    # check whether a serializer function is already registered for fields\n                    for field_serializer_decorator in res.field_serializers.values():\n                        # check that each field has at most one serializer function.\n                        # serializer functions for the same field in subclasses are allowed,\n                        # and are treated as overrides\n                        if field_serializer_decorator.cls_var_name == var_name:\n                            continue\n                        for f in info.fields:\n                            if f in field_serializer_decorator.info.fields:\n                                raise PydanticUserError(\n                                    'Multiple field serializer functions were defined '\n                                    f'for field {f!r}, this is not allowed.',\n                                    code='multiple-field-serializers',\n                                )\n                    res.field_serializers[var_name] = Decorator.build(\n                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info\n                    )\n                elif isinstance(info, ModelValidatorDecoratorInfo):\n                    res.model_validators[var_name] = Decorator.build(\n                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info\n                    )\n                elif isinstance(info, ModelSerializerDecoratorInfo):\n                    res.model_serializers[var_name] = Decorator.build(\n                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info\n                    )\n                else:\n                    from ..fields import ComputedFieldInfo\n\n                    isinstance(var_value, ComputedFieldInfo)\n                    res.computed_fields[var_name] = Decorator.build(\n                        model_dc, cls_var_name=var_name, shim=None, info=info\n                    )\n                to_replace.append((var_name, var_value.wrapped))\n        if to_replace:\n            # If we can save `__pydantic_decorators__` on the class we'll be able to check for it above\n            # so then we don't need to re-process the type, which means we can discard our descriptor wrappers\n            # and replace them with the thing they are wrapping (see the other setattr call below)\n            # which allows validator class methods to also function as regular class methods\n            model_dc.__pydantic_decorators__ = res\n            for name, value in to_replace:\n                setattr(model_dc, name, value)\n        return res\n\n\ndef inspect_validator(validator: Callable[..., Any], mode: FieldValidatorModes) -> bool:\n    \"\"\"Look at a field or model validator function and determine whether it takes an info argument.\n\n    An error is raised if the function has an invalid signature.\n\n    Args:\n        validator: The validator function to inspect.\n        mode: The proposed validator mode.\n\n    Returns:\n        Whether the validator takes an info argument.\n    \"\"\"\n    try:\n        sig = signature(validator)\n    except (ValueError, TypeError):\n        # `inspect.signature` might not be able to infer a signature, e.g. with C objects.\n        # In this case, we assume no info argument is present:\n        return False\n    n_positional = count_positional_required_params(sig)\n    if mode == 'wrap':\n        if n_positional == 3:\n            return True\n        elif n_positional == 2:\n            return False\n    else:\n        assert mode in {'before', 'after', 'plain'}, f\"invalid mode: {mode!r}, expected 'before', 'after' or 'plain\"\n        if n_positional == 2:\n            return True\n        elif n_positional == 1:\n            return False\n\n    raise PydanticUserError(\n        f'Unrecognized field_validator function signature for {validator} with `mode={mode}`:{sig}',\n        code='validator-signature',\n    )\n\n\ndef inspect_field_serializer(serializer: Callable[..., Any], mode: Literal['plain', 'wrap']) -> tuple[bool, bool]:\n    \"\"\"Look at a field serializer function and determine if it is a field serializer,\n    and whether it takes an info argument.\n\n    An error is raised if the function has an invalid signature.\n\n    Args:\n        serializer: The serializer function to inspect.\n        mode: The serializer mode, either 'plain' or 'wrap'.\n\n    Returns:\n        Tuple of (is_field_serializer, info_arg).\n    \"\"\"\n    try:\n        sig = signature(serializer)\n    except (ValueError, TypeError):\n        # `inspect.signature` might not be able to infer a signature, e.g. with C objects.\n        # In this case, we assume no info argument is present and this is not a method:\n        return (False, False)\n\n    first = next(iter(sig.parameters.values()), None)\n    is_field_serializer = first is not None and first.name == 'self'\n\n    n_positional = count_positional_required_params(sig)\n    if is_field_serializer:\n        # -1 to correct for self parameter\n        info_arg = _serializer_info_arg(mode, n_positional - 1)\n    else:\n        info_arg = _serializer_info_arg(mode, n_positional)\n\n    if info_arg is None:\n        raise PydanticUserError(\n            f'Unrecognized field_serializer function signature for {serializer} with `mode={mode}`:{sig}',\n            code='field-serializer-signature',\n        )\n\n    return is_field_serializer, info_arg\n\n\ndef inspect_annotated_serializer(serializer: Callable[..., Any], mode: Literal['plain', 'wrap']) -> bool:\n    \"\"\"Look at a serializer function used via `Annotated` and determine whether it takes an info argument.\n\n    An error is raised if the function has an invalid signature.\n\n    Args:\n        serializer: The serializer function to check.\n        mode: The serializer mode, either 'plain' or 'wrap'.\n\n    Returns:\n        info_arg\n    \"\"\"\n    try:\n        sig = signature(serializer)\n    except (ValueError, TypeError):\n        # `inspect.signature` might not be able to infer a signature, e.g. with C objects.\n        # In this case, we assume no info argument is present:\n        return False\n    info_arg = _serializer_info_arg(mode, count_positional_required_params(sig))\n    if info_arg is None:\n        raise PydanticUserError(\n            f'Unrecognized field_serializer function signature for {serializer} with `mode={mode}`:{sig}',\n            code='field-serializer-signature',\n        )\n    else:\n        return info_arg\n\n\ndef inspect_model_serializer(serializer: Callable[..., Any], mode: Literal['plain', 'wrap']) -> bool:\n    \"\"\"Look at a model serializer function and determine whether it takes an info argument.\n\n    An error is raised if the function has an invalid signature.\n\n    Args:\n        serializer: The serializer function to check.\n        mode: The serializer mode, either 'plain' or 'wrap'.\n\n    Returns:\n        `info_arg` - whether the function expects an info argument.\n    \"\"\"\n    if isinstance(serializer, (staticmethod, classmethod)) or not is_instance_method_from_sig(serializer):\n        raise PydanticUserError(\n            '`@model_serializer` must be applied to instance methods', code='model-serializer-instance-method'\n        )\n\n    sig = signature(serializer)\n    info_arg = _serializer_info_arg(mode, count_positional_required_params(sig))\n    if info_arg is None:\n        raise PydanticUserError(\n            f'Unrecognized model_serializer function signature for {serializer} with `mode={mode}`:{sig}',\n            code='model-serializer-signature',\n        )\n    else:\n        return info_arg\n\n\ndef _serializer_info_arg(mode: Literal['plain', 'wrap'], n_positional: int) -> bool | None:\n    if mode == 'plain':\n        if n_positional == 1:\n            # (input_value: Any, /) -> Any\n            return False\n        elif n_positional == 2:\n            # (model: Any, input_value: Any, /) -> Any\n            return True\n    else:\n        assert mode == 'wrap', f\"invalid mode: {mode!r}, expected 'plain' or 'wrap'\"\n        if n_positional == 2:\n            # (input_value: Any, serializer: SerializerFunctionWrapHandler, /) -> Any\n            return False\n        elif n_positional == 3:\n            # (input_value: Any, serializer: SerializerFunctionWrapHandler, info: SerializationInfo, /) -> Any\n            return True\n\n    return None\n\n\nAnyDecoratorCallable: TypeAlias = (\n    'Union[classmethod[Any, Any, Any], staticmethod[Any, Any], partialmethod[Any], Callable[..., Any]]'\n)\n\n\ndef is_instance_method_from_sig(function: AnyDecoratorCallable) -> bool:\n    \"\"\"Whether the function is an instance method.\n\n    It will consider a function as instance method if the first parameter of\n    function is `self`.\n\n    Args:\n        function: The function to check.\n\n    Returns:\n        `True` if the function is an instance method, `False` otherwise.\n    \"\"\"\n    sig = signature(unwrap_wrapped_function(function))\n    first = next(iter(sig.parameters.values()), None)\n    if first and first.name == 'self':\n        return True\n    return False\n\n\ndef ensure_classmethod_based_on_signature(function: AnyDecoratorCallable) -> Any:\n    \"\"\"Apply the `@classmethod` decorator on the function.\n\n    Args:\n        function: The function to apply the decorator on.\n\n    Return:\n        The `@classmethod` decorator applied function.\n    \"\"\"\n    if not isinstance(\n        unwrap_wrapped_function(function, unwrap_class_static_method=False), classmethod\n    ) and _is_classmethod_from_sig(function):\n        return classmethod(function)  # type: ignore[arg-type]\n    return function\n\n\ndef _is_classmethod_from_sig(function: AnyDecoratorCallable) -> bool:\n    sig = signature(unwrap_wrapped_function(function))\n    first = next(iter(sig.parameters.values()), None)\n    if first and first.name == 'cls':\n        return True\n    return False\n\n\ndef unwrap_wrapped_function(\n    func: Any,\n    *,\n    unwrap_partial: bool = True,\n    unwrap_class_static_method: bool = True,\n) -> Any:\n    \"\"\"Recursively unwraps a wrapped function until the underlying function is reached.\n    This handles property, functools.partial, functools.partialmethod, staticmethod, and classmethod.\n\n    Args:\n        func: The function to unwrap.\n        unwrap_partial: If True (default), unwrap partial and partialmethod decorators.\n        unwrap_class_static_method: If True (default), also unwrap classmethod and staticmethod\n            decorators. If False, only unwrap partial and partialmethod decorators.\n\n    Returns:\n        The underlying function of the wrapped function.\n    \"\"\"\n    # Define the types we want to check against as a single tuple.\n    unwrap_types = (\n        (property, cached_property)\n        + ((partial, partialmethod) if unwrap_partial else ())\n        + ((staticmethod, classmethod) if unwrap_class_static_method else ())\n    )\n\n    while isinstance(func, unwrap_types):\n        if unwrap_class_static_method and isinstance(func, (classmethod, staticmethod)):\n            func = func.__func__\n        elif isinstance(func, (partial, partialmethod)):\n            func = func.func\n        elif isinstance(func, property):\n            func = func.fget  # arbitrary choice, convenient for computed fields\n        else:\n            # Make coverage happy as it can only get here in the last possible case\n            assert isinstance(func, cached_property)\n            func = func.func  # type: ignore\n\n    return func\n\n\n_function_like = (\n    partial,\n    partialmethod,\n    types.FunctionType,\n    types.BuiltinFunctionType,\n    types.MethodType,\n    types.WrapperDescriptorType,\n    types.MethodWrapperType,\n    types.MemberDescriptorType,\n)\n\n\ndef get_callable_return_type(\n    callable_obj: Any,\n    globalns: GlobalsNamespace | None = None,\n    localns: MappingNamespace | None = None,\n) -> Any | PydanticUndefinedType:\n    \"\"\"Get the callable return type.\n\n    Args:\n        callable_obj: The callable to analyze.\n        globalns: The globals namespace to use during type annotation evaluation.\n        localns: The locals namespace to use during type annotation evaluation.\n\n    Returns:\n        The function return type.\n    \"\"\"\n    if isinstance(callable_obj, type):\n        # types are callables, and we assume the return type\n        # is the type itself (e.g. `int()` results in an instance of `int`).\n        return callable_obj\n\n    if not isinstance(callable_obj, _function_like):\n        call_func = getattr(type(callable_obj), '__call__', None)  # noqa: B004\n        if call_func is not None:\n            callable_obj = call_func\n\n    hints = get_function_type_hints(\n        unwrap_wrapped_function(callable_obj),\n        include_keys={'return'},\n        globalns=globalns,\n        localns=localns,\n    )\n    return hints.get('return', PydanticUndefined)\n\n\ndef count_positional_required_params(sig: Signature) -> int:\n    \"\"\"Get the number of positional (required) arguments of a signature.\n\n    This function should only be used to inspect signatures of validation and serialization functions.\n    The first argument (the value being serialized or validated) is counted as a required argument\n    even if a default value exists.\n\n    Returns:\n        The number of positional arguments of a signature.\n    \"\"\"\n    parameters = list(sig.parameters.values())\n    return sum(\n        1\n        for param in parameters\n        if can_be_positional(param)\n        # First argument is the value being validated/serialized, and can have a default value\n        # (e.g. `float`, which has signature `(x=0, /)`). We assume other parameters (the info arg\n        # for instance) should be required, and thus without any default value.\n        and (param.default is Parameter.empty or param is parameters[0])\n    )\n\n\ndef ensure_property(f: Any) -> Any:\n    \"\"\"Ensure that a function is a `property` or `cached_property`, or is a valid descriptor.\n\n    Args:\n        f: The function to check.\n\n    Returns:\n        The function, or a `property` or `cached_property` instance wrapping the function.\n    \"\"\"\n    if ismethoddescriptor(f) or isdatadescriptor(f):\n        return f\n    else:\n        return property(f)\n\n\n--- File: 7 # _internal/_decorators_v1.py ---\n\"\"\"Logic for V1 validators, e.g. `@validator` and `@root_validator`.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nfrom inspect import Parameter, signature\nfrom typing import Any, Union, cast\n\nfrom pydantic_core import core_schema\nfrom typing_extensions import Protocol\n\nfrom ..errors import PydanticUserError\nfrom ._utils import can_be_positional\n\n\nclass V1OnlyValueValidator(Protocol):\n    \"\"\"A simple validator, supported for V1 validators and V2 validators.\"\"\"\n\n    def __call__(self, __value: Any) -> Any: ...\n\n\nclass V1ValidatorWithValues(Protocol):\n    \"\"\"A validator with `values` argument, supported for V1 validators and V2 validators.\"\"\"\n\n    def __call__(self, __value: Any, values: dict[str, Any]) -> Any: ...\n\n\nclass V1ValidatorWithValuesKwOnly(Protocol):\n    \"\"\"A validator with keyword only `values` argument, supported for V1 validators and V2 validators.\"\"\"\n\n    def __call__(self, __value: Any, *, values: dict[str, Any]) -> Any: ...\n\n\nclass V1ValidatorWithKwargs(Protocol):\n    \"\"\"A validator with `kwargs` argument, supported for V1 validators and V2 validators.\"\"\"\n\n    def __call__(self, __value: Any, **kwargs: Any) -> Any: ...\n\n\nclass V1ValidatorWithValuesAndKwargs(Protocol):\n    \"\"\"A validator with `values` and `kwargs` arguments, supported for V1 validators and V2 validators.\"\"\"\n\n    def __call__(self, __value: Any, values: dict[str, Any], **kwargs: Any) -> Any: ...\n\n\nV1Validator = Union[\n    V1ValidatorWithValues, V1ValidatorWithValuesKwOnly, V1ValidatorWithKwargs, V1ValidatorWithValuesAndKwargs\n]\n\n\ndef can_be_keyword(param: Parameter) -> bool:\n    return param.kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.KEYWORD_ONLY)\n\n\ndef make_generic_v1_field_validator(validator: V1Validator) -> core_schema.WithInfoValidatorFunction:\n    \"\"\"Wrap a V1 style field validator for V2 compatibility.\n\n    Args:\n        validator: The V1 style field validator.\n\n    Returns:\n        A wrapped V2 style field validator.\n\n    Raises:\n        PydanticUserError: If the signature is not supported or the parameters are\n            not available in Pydantic V2.\n    \"\"\"\n    sig = signature(validator)\n\n    needs_values_kw = False\n\n    for param_num, (param_name, parameter) in enumerate(sig.parameters.items()):\n        if can_be_keyword(parameter) and param_name in ('field', 'config'):\n            raise PydanticUserError(\n                'The `field` and `config` parameters are not available in Pydantic V2, '\n                'please use the `info` parameter instead.',\n                code='validator-field-config-info',\n            )\n        if parameter.kind is Parameter.VAR_KEYWORD:\n            needs_values_kw = True\n        elif can_be_keyword(parameter) and param_name == 'values':\n            needs_values_kw = True\n        elif can_be_positional(parameter) and param_num == 0:\n            # value\n            continue\n        elif parameter.default is Parameter.empty:  # ignore params with defaults e.g. bound by functools.partial\n            raise PydanticUserError(\n                f'Unsupported signature for V1 style validator {validator}: {sig} is not supported.',\n                code='validator-v1-signature',\n            )\n\n    if needs_values_kw:\n        # (v, **kwargs), (v, values, **kwargs), (v, *, values, **kwargs) or (v, *, values)\n        val1 = cast(V1ValidatorWithValues, validator)\n\n        def wrapper1(value: Any, info: core_schema.ValidationInfo) -> Any:\n            return val1(value, values=info.data)\n\n        return wrapper1\n    else:\n        val2 = cast(V1OnlyValueValidator, validator)\n\n        def wrapper2(value: Any, _: core_schema.ValidationInfo) -> Any:\n            return val2(value)\n\n        return wrapper2\n\n\nRootValidatorValues = dict[str, Any]\n# technically tuple[model_dict, model_extra, fields_set] | tuple[dataclass_dict, init_vars]\nRootValidatorFieldsTuple = tuple[Any, ...]\n\n\nclass V1RootValidatorFunction(Protocol):\n    \"\"\"A simple root validator, supported for V1 validators and V2 validators.\"\"\"\n\n    def __call__(self, __values: RootValidatorValues) -> RootValidatorValues: ...\n\n\nclass V2CoreBeforeRootValidator(Protocol):\n    \"\"\"V2 validator with mode='before'.\"\"\"\n\n    def __call__(self, __values: RootValidatorValues, __info: core_schema.ValidationInfo) -> RootValidatorValues: ...\n\n\nclass V2CoreAfterRootValidator(Protocol):\n    \"\"\"V2 validator with mode='after'.\"\"\"\n\n    def __call__(\n        self, __fields_tuple: RootValidatorFieldsTuple, __info: core_schema.ValidationInfo\n    ) -> RootValidatorFieldsTuple: ...\n\n\ndef make_v1_generic_root_validator(\n    validator: V1RootValidatorFunction, pre: bool\n) -> V2CoreBeforeRootValidator | V2CoreAfterRootValidator:\n    \"\"\"Wrap a V1 style root validator for V2 compatibility.\n\n    Args:\n        validator: The V1 style field validator.\n        pre: Whether the validator is a pre validator.\n\n    Returns:\n        A wrapped V2 style validator.\n    \"\"\"\n    if pre is True:\n        # mode='before' for pydantic-core\n        def _wrapper1(values: RootValidatorValues, _: core_schema.ValidationInfo) -> RootValidatorValues:\n            return validator(values)\n\n        return _wrapper1\n\n    # mode='after' for pydantic-core\n    def _wrapper2(fields_tuple: RootValidatorFieldsTuple, _: core_schema.ValidationInfo) -> RootValidatorFieldsTuple:\n        if len(fields_tuple) == 2:\n            # dataclass, this is easy\n            values, init_vars = fields_tuple\n            values = validator(values)\n            return values, init_vars\n        else:\n            # ugly hack: to match v1 behaviour, we merge values and model_extra, then split them up based on fields\n            # afterwards\n            model_dict, model_extra, fields_set = fields_tuple\n            if model_extra:\n                fields = set(model_dict.keys())\n                model_dict.update(model_extra)\n                model_dict_new = validator(model_dict)\n                for k in list(model_dict_new.keys()):\n                    if k not in fields:\n                        model_extra[k] = model_dict_new.pop(k)\n            else:\n                model_dict_new = validator(model_dict)\n            return model_dict_new, model_extra, fields_set\n\n    return _wrapper2\n\n\nIMPORTANT: Generate the `summary` and relationship `label` fields in **Korean** language. Do NOT use English for these fields.\n\nPlease provide:\n1. A high-level `summary` of the project's main purpose and functionality in a few beginner-friendly sentences (in Korean). Use markdown formatting with **bold** and *italic* text to highlight important concepts.\n2. A list (`relationships`) describing the key interactions between these abstractions. For each relationship, specify:\n    - `from_abstraction`: Index of the source abstraction (e.g., `0 # AbstractionName1`)\n    - `to_abstraction`: Index of the target abstraction (e.g., `1 # AbstractionName2`)\n    - `label`: A brief label for the interaction **in just a few words** (in Korean) (e.g., \"Manages\", \"Inherits\", \"Uses\").\n    Ideally the relationship should be backed by one abstraction calling or passing parameters to another.\n    Simplify the relationship and exclude those non-important ones.\n\nIMPORTANT: Make sure EVERY abstraction is involved in at least ONE relationship (either as source or target). Each abstraction index must appear at least once across all relationships.\n\nFormat the output as YAML:\n\n```yaml\nsummary: |\n  A brief, simple explanation of the project (in Korean).\n  Can span multiple lines with **bold** and *italic* for emphasis.\nrelationships:\n  - from_abstraction: 0 # AbstractionName1\n    to_abstraction: 1 # AbstractionName2\n    label: \"Manages\" (in Korean)\n  - from_abstraction: 2 # AbstractionName3\n    to_abstraction: 0 # AbstractionName1\n    label: \"Provides config\" (in Korean)\n  # ... other relationships\n```\n\nNow, provide the YAML output:\n": "```yaml\nsummary: |\n  **Pydantic**  *Python*        . \n    ****    ,  , \n  **  **      .\n       ** **     .\nrelationships:\n  - from_abstraction: 0 #   (Config Wrapper)\n    to_abstraction: 1 #   (Core Metadata)\n    label: \" \"\n  - from_abstraction: 4 #    (Dataclass Creator)\n    to_abstraction: 0 #   (Config Wrapper)\n    label: \"\"\n  - from_abstraction: 5 #    (Dynamic Import Functionality)\n    to_abstraction: 6 #   (Warning System)\n    label: \" \"\n  - from_abstraction: 3 #   (Internal Utils)\n    to_abstraction: 4 #    (Dataclass Creator)\n    label: \"\"\n  - from_abstraction: 2 #   (Decorator Info)\n    to_abstraction: 0 #   (Config Wrapper)\n    label: \" \"\n  - from_abstraction: 7 #   (Schema Generator)\n    to_abstraction: 1 #   (Core Metadata)\n    label: \" \"\n  - from_abstraction: 6 #   (Warning System)\n    to_abstraction: 0 #   (Config Wrapper)\n    label: \" \"\n  - from_abstraction: 5 #    (Dynamic Import Functionality)\n    to_abstraction: 7 #   (Schema Generator)\n    label: \" \"\n```",
    "\nGiven the following project abstractions and their relationships for the project ```` pydantic ````:\n\nAbstractions (Index # Name) (Names might be in Korean):\n- 0 #   (Config Wrapper)\n- 1 #   (Core Metadata)\n- 2 #   (Decorator Info)\n- 3 #   (Internal Utils)\n- 4 #    (Dataclass Creator)\n- 5 #    (Dynamic Import Functionality)\n- 6 #   (Warning System)\n- 7 #   (Schema Generator)\n\nContext about relationships and project summary:\nProject Summary (Note: Project Summary might be in Korean):\n**Pydantic**  *Python*        . \n  ****    ,  , \n**  **      .\n     ** **     .\n\n\nRelationships (Indices refer to abstractions above):\n- From 0 (  (Config Wrapper)) to 1 (  (Core Metadata)):  \n- From 4 (   (Dataclass Creator)) to 0 (  (Config Wrapper)): \n- From 5 (   (Dynamic Import Functionality)) to 6 (  (Warning System)):  \n- From 3 (  (Internal Utils)) to 4 (   (Dataclass Creator)): \n- From 2 (  (Decorator Info)) to 0 (  (Config Wrapper)):  \n- From 7 (  (Schema Generator)) to 1 (  (Core Metadata)):  \n- From 6 (  (Warning System)) to 0 (  (Config Wrapper)):  \n- From 5 (   (Dynamic Import Functionality)) to 7 (  (Schema Generator)):  \n\n\nIf you are going to make a tutorial for ```` pydantic ````, what is the best order to explain these abstractions, from first to last?\nIdeally, first explain those that are the most important or foundational, perhaps user-facing concepts or entry points. Then move to more detailed, lower-level implementation details or supporting concepts.\n\nOutput the ordered list of abstraction indices, including the name in a comment for clarity. Use the format `idx # AbstractionName`.\n\n```yaml\n- 2 # FoundationalConcept\n- 0 # CoreClassA\n- 1 # CoreClassB (uses CoreClassA)\n- ...\n```\n\nNow, provide the YAML output:\n": "```yaml\n- 0 #   (Config Wrapper)\n- 1 #   (Core Metadata)\n- 7 #   (Schema Generator)\n- 4 #    (Dataclass Creator)\n- 3 #   (Internal Utils)\n- 5 #    (Dynamic Import Functionality)\n- 6 #   (Warning System)\n- 2 #   (Decorator Info)\n```",
    "\nIMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.\n\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `pydantic` about the concept: \"  (Config Wrapper)\". This is Chapter 1.\n\nConcept Details (Note: Provided in Korean):\n- Name:   (Config Wrapper)\n- Description:\nPydantic     , ConfigDict         .\n\nComplete Tutorial Structure (Note: Chapter names might be in Korean):\n1. [  (Config Wrapper)](01____config_wrapper_.md)\n2. [  (Core Metadata)](02____core_metadata_.md)\n3. [  (Schema Generator)](03____schema_generator_.md)\n4. [   (Dataclass Creator)](04_____dataclass_creator_.md)\n5. [  (Internal Utils)](05____internal_utils_.md)\n6. [   (Dynamic Import Functionality)](06_____dynamic_import_functionality_.md)\n7. [  (Warning System)](07____warning_system_.md)\n8. [  (Decorator Info)](08____decorator_info_.md)\n\nContext from previous chapters (Note: This summary might be in Korean):\nThis is the first chapter.\n\nRelevant Code Snippets (Code itself remains unchanged):\nNo specific code snippets provided for this abstraction.\n\nInstructions for the chapter (Generate content in Korean unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 1:   (Config Wrapper)`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).\n\n- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).\n\n- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).\n\n- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).\n\n- Heavily use analogies and examples throughout (in Korean) to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "#  1:   (Config Wrapper)\n\nPydantic           .   Pydantic \"  (Config Wrapper)\"  .   Pydantic          .     .\n\n##  \n\n  Pydantic        .        ,       .\n\n ,               .           .\n\n##    \n\n        .\n\n### 1. ConfigDict\n\n  ConfigDict (dictionary)    . ConfigDict    ,        .\n\n```python\nfrom pydantic import BaseModel\n\nclass MyModel(BaseModel):\n    class Config:\n        any_config_option = True  #    \n```\n\n  `Config`    `MyModel`  .\n\n### 2.  \n\n  ConfigDict    .        .\n\n### 3.   \n\n           .       .\n\n##    \n\n         .\n\n```python\nfrom pydantic import BaseModel\n\nclass UserModel(BaseModel):\n    name: str\n    age: int\n\n    class Config:\n        anystr_strip_whitespace = True  #    \n```\n\n  `UserModel`        .       .\n\n##   \n\n     . Pydantic     Config     .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    ->>:    \n    ->>:  \n```\n\n          ,     .\n\n## \n\n  Pydantic    .    Pydantic    ,     .   [  (Core Metadata)](02____core_metadata_.md)  Pydantic    . Pydantic    !",
    "\nIMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.\n\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `pydantic` about the concept: \"  (Core Metadata)\". This is Chapter 2.\n\nConcept Details (Note: Provided in Korean):\n- Name:   (Core Metadata)\n- Description:\n   , JSON              .\n\nComplete Tutorial Structure (Note: Chapter names might be in Korean):\n1. [  (Config Wrapper)](01____config_wrapper_.md)\n2. [  (Core Metadata)](02____core_metadata_.md)\n3. [  (Schema Generator)](03____schema_generator_.md)\n4. [   (Dataclass Creator)](04_____dataclass_creator_.md)\n5. [  (Internal Utils)](05____internal_utils_.md)\n6. [   (Dynamic Import Functionality)](06_____dynamic_import_functionality_.md)\n7. [  (Warning System)](07____warning_system_.md)\n8. [  (Decorator Info)](08____decorator_info_.md)\n\nContext from previous chapters (Note: This summary might be in Korean):\n# Chapter 1:   (Config Wrapper)\n\nPydantic           .   Pydantic \"  (Config Wrapper)\"  .   Pydantic          .     .\n\n##  \n\n  Pydantic        .        ,       .\n\n ,               .           .\n\n##    \n\n        .\n\n### 1. ConfigDict\n\n  ConfigDict (dictionary)    . ConfigDict    ,        .\n\n```python\nfrom pydantic import BaseModel\n\nclass MyModel(BaseModel):\n    class Config:\n        any_config_option = True  #    \n```\n\n  `Config`    `MyModel`  .\n\n### 2.  \n\n  ConfigDict    .        .\n\n### 3.   \n\n           .       .\n\n##    \n\n         .\n\n```python\nfrom pydantic import BaseModel\n\nclass UserModel(BaseModel):\n    name: str\n    age: int\n\n    class Config:\n        anystr_strip_whitespace = True  #    \n```\n\n  `UserModel`        .       .\n\n##   \n\n     . Pydantic     Config     .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    ->>:    \n    ->>:  \n```\n\n          ,     .\n\n## \n\n  Pydantic    .    Pydantic    ,     .   [  (Core Metadata)](02____core_metadata_.md)  Pydantic    . Pydantic    !\n\nRelevant Code Snippets (Code itself remains unchanged):\nNo specific code snippets provided for this abstraction.\n\nInstructions for the chapter (Generate content in Korean unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 2:   (Core Metadata)`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).\n\n- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).\n\n- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).\n\n- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).\n\n- Heavily use analogies and examples throughout (in Korean) to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 2:   (Core Metadata)\n\n[ :   (Config Wrapper)](01____config_wrapper_.md) Pydantic          .  [  (Core Metadata)]  .\n\n##  \n\n  Pydantic        .    ,        .             .\n\n##  \n\n        .\n\n### 1.   \n\n     (dictionary)  .   JSON       ,       .\n\n ,   JSON    ,            .\n\n```python\nfrom pydantic import BaseModel, Field\n\nclass Product(BaseModel):\n    name: str = Field(description='')\n    price: float = Field(ge=0, description='')\n\n# `Product`     .\nschema = Product.schema()\nprint(schema)\n```\n\n  `Product`    .   JSON,       .\n\n### 2.   \n\n   (Reference)     .  ,             .\n\n### 3.   \n\n           .         .\n\n##   \n\n        . Pydantic         .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant \n    ->>: JSON  \n    ->>:   \n    -->>:   \n    -->>: JSON  \n```\n\n    JSON  ,          .\n\n## \n\n  Pydantic       ,         .   [  (Schema Generator)](03____schema_generator_.md)        .  !",
    "\nIMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.\n\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `pydantic` about the concept: \"  (Schema Generator)\". This is Chapter 3.\n\nConcept Details (Note: Provided in Korean):\n- Name:   (Schema Generator)\n- Description:\n      JSON         .\n\nComplete Tutorial Structure (Note: Chapter names might be in Korean):\n1. [  (Config Wrapper)](01____config_wrapper_.md)\n2. [  (Core Metadata)](02____core_metadata_.md)\n3. [  (Schema Generator)](03____schema_generator_.md)\n4. [   (Dataclass Creator)](04_____dataclass_creator_.md)\n5. [  (Internal Utils)](05____internal_utils_.md)\n6. [   (Dynamic Import Functionality)](06_____dynamic_import_functionality_.md)\n7. [  (Warning System)](07____warning_system_.md)\n8. [  (Decorator Info)](08____decorator_info_.md)\n\nContext from previous chapters (Note: This summary might be in Korean):\n# Chapter 1:   (Config Wrapper)\n\nPydantic           .   Pydantic \"  (Config Wrapper)\"  .   Pydantic          .     .\n\n##  \n\n  Pydantic        .        ,       .\n\n ,               .           .\n\n##    \n\n        .\n\n### 1. ConfigDict\n\n  ConfigDict (dictionary)    . ConfigDict    ,        .\n\n```python\nfrom pydantic import BaseModel\n\nclass MyModel(BaseModel):\n    class Config:\n        any_config_option = True  #    \n```\n\n  `Config`    `MyModel`  .\n\n### 2.  \n\n  ConfigDict    .        .\n\n### 3.   \n\n           .       .\n\n##    \n\n         .\n\n```python\nfrom pydantic import BaseModel\n\nclass UserModel(BaseModel):\n    name: str\n    age: int\n\n    class Config:\n        anystr_strip_whitespace = True  #    \n```\n\n  `UserModel`        .       .\n\n##   \n\n     . Pydantic     Config     .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    ->>:    \n    ->>:  \n```\n\n          ,     .\n\n## \n\n  Pydantic    .    Pydantic    ,     .   [  (Core Metadata)](02____core_metadata_.md)  Pydantic    . Pydantic    !\n---\n# Chapter 2:   (Core Metadata)\n\n[ :   (Config Wrapper)](01____config_wrapper_.md) Pydantic          .  [  (Core Metadata)]  .\n\n##  \n\n  Pydantic        .    ,        .             .\n\n##  \n\n        .\n\n### 1.   \n\n     (dictionary)  .   JSON       ,       .\n\n ,   JSON    ,            .\n\n```python\nfrom pydantic import BaseModel, Field\n\nclass Product(BaseModel):\n    name: str = Field(description='')\n    price: float = Field(ge=0, description='')\n\n# `Product`     .\nschema = Product.schema()\nprint(schema)\n```\n\n  `Product`    .   JSON,       .\n\n### 2.   \n\n   (Reference)     .  ,             .\n\n### 3.   \n\n           .         .\n\n##   \n\n        . Pydantic         .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant \n    ->>: JSON  \n    ->>:   \n    -->>:   \n    -->>: JSON  \n```\n\n    JSON  ,          .\n\n## \n\n  Pydantic       ,         .   [  (Schema Generator)](03____schema_generator_.md)        .  !\n\nRelevant Code Snippets (Code itself remains unchanged):\nNo specific code snippets provided for this abstraction.\n\nInstructions for the chapter (Generate content in Korean unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 3:   (Schema Generator)`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).\n\n- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).\n\n- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).\n\n- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).\n\n- Heavily use analogies and examples throughout (in Korean) to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 3:   (Schema Generator)\n\n[ :   (Core Metadata)](02____core_metadata_.md) Pydantic          .   '  (Schema Generator)' ,   JSON    .\n\n##  \n\n  Pydantic   JSON          .           .\n\n ,                   .      .\n\n##  \n\n### 1. JSON  \n\n      JSON   .     ,    .\n\n ,         .\n\n```python\nfrom pydantic import BaseModel\n\nclass Product(BaseModel):\n    name: str\n    price: float\n\n# JSON  \nschema = Product.schema_json(indent=2)\nprint(schema)\n```\n\n  `Product`  JSON   .    `name` `price`   .\n\n### 2.   \n\n            .       .\n\n```python\nfrom pydantic import Field\n\nclass DetailedProduct(Product):\n    name: str = Field(description='')\n    price: float = Field(ge=0, description=' (0 )')\n\n#   JSON  \ndetailed_schema = DetailedProduct.schema_json(indent=2)\nprint(detailed_schema)\n```\n\n `DetailedProduct`    `description`       .\n\n##   \n\n       .        .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant  \n    ->>:  \n    ->> :   \n     -->>: JSON  \n    -->>: JSON  \n```\n\n     ,         JSON  .\n\n## \n\n  Pydantic      JSON     .       ,      .   [   (Dataclass Creator)](04_____dataclass_creator_.md)  .  !",
    "\nIMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.\n\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `pydantic` about the concept: \"   (Dataclass Creator)\". This is Chapter 4.\n\nConcept Details (Note: Provided in Korean):\n- Name:    (Dataclass Creator)\n- Description:\nPydantic         Python   Pydantic   .\n\nComplete Tutorial Structure (Note: Chapter names might be in Korean):\n1. [  (Config Wrapper)](01____config_wrapper_.md)\n2. [  (Core Metadata)](02____core_metadata_.md)\n3. [  (Schema Generator)](03____schema_generator_.md)\n4. [   (Dataclass Creator)](04_____dataclass_creator_.md)\n5. [  (Internal Utils)](05____internal_utils_.md)\n6. [   (Dynamic Import Functionality)](06_____dynamic_import_functionality_.md)\n7. [  (Warning System)](07____warning_system_.md)\n8. [  (Decorator Info)](08____decorator_info_.md)\n\nContext from previous chapters (Note: This summary might be in Korean):\n# Chapter 1:   (Config Wrapper)\n\nPydantic           .   Pydantic \"  (Config Wrapper)\"  .   Pydantic          .     .\n\n##  \n\n  Pydantic        .        ,       .\n\n ,               .           .\n\n##    \n\n        .\n\n### 1. ConfigDict\n\n  ConfigDict (dictionary)    . ConfigDict    ,        .\n\n```python\nfrom pydantic import BaseModel\n\nclass MyModel(BaseModel):\n    class Config:\n        any_config_option = True  #    \n```\n\n  `Config`    `MyModel`  .\n\n### 2.  \n\n  ConfigDict    .        .\n\n### 3.   \n\n           .       .\n\n##    \n\n         .\n\n```python\nfrom pydantic import BaseModel\n\nclass UserModel(BaseModel):\n    name: str\n    age: int\n\n    class Config:\n        anystr_strip_whitespace = True  #    \n```\n\n  `UserModel`        .       .\n\n##   \n\n     . Pydantic     Config     .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    ->>:    \n    ->>:  \n```\n\n          ,     .\n\n## \n\n  Pydantic    .    Pydantic    ,     .   [  (Core Metadata)](02____core_metadata_.md)  Pydantic    . Pydantic    !\n---\n# Chapter 2:   (Core Metadata)\n\n[ :   (Config Wrapper)](01____config_wrapper_.md) Pydantic          .  [  (Core Metadata)]  .\n\n##  \n\n  Pydantic        .    ,        .             .\n\n##  \n\n        .\n\n### 1.   \n\n     (dictionary)  .   JSON       ,       .\n\n ,   JSON    ,            .\n\n```python\nfrom pydantic import BaseModel, Field\n\nclass Product(BaseModel):\n    name: str = Field(description='')\n    price: float = Field(ge=0, description='')\n\n# `Product`     .\nschema = Product.schema()\nprint(schema)\n```\n\n  `Product`    .   JSON,       .\n\n### 2.   \n\n   (Reference)     .  ,             .\n\n### 3.   \n\n           .         .\n\n##   \n\n        . Pydantic         .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant \n    ->>: JSON  \n    ->>:   \n    -->>:   \n    -->>: JSON  \n```\n\n    JSON  ,          .\n\n## \n\n  Pydantic       ,         .   [  (Schema Generator)](03____schema_generator_.md)        .  !\n---\n# Chapter 3:   (Schema Generator)\n\n[ :   (Core Metadata)](02____core_metadata_.md) Pydantic          .   '  (Schema Generator)' ,   JSON    .\n\n##  \n\n  Pydantic   JSON          .           .\n\n ,                   .      .\n\n##  \n\n### 1. JSON  \n\n      JSON   .     ,    .\n\n ,         .\n\n```python\nfrom pydantic import BaseModel\n\nclass Product(BaseModel):\n    name: str\n    price: float\n\n# JSON  \nschema = Product.schema_json(indent=2)\nprint(schema)\n```\n\n  `Product`  JSON   .    `name` `price`   .\n\n### 2.   \n\n            .       .\n\n```python\nfrom pydantic import Field\n\nclass DetailedProduct(Product):\n    name: str = Field(description='')\n    price: float = Field(ge=0, description=' (0 )')\n\n#   JSON  \ndetailed_schema = DetailedProduct.schema_json(indent=2)\nprint(detailed_schema)\n```\n\n `DetailedProduct`    `description`       .\n\n##   \n\n       .        .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant  \n    ->>:  \n    ->> :   \n     -->>: JSON  \n    -->>: JSON  \n```\n\n     ,         JSON  .\n\n## \n\n  Pydantic      JSON     .       ,      .   [   (Dataclass Creator)](04_____dataclass_creator_.md)  .  !\n\nRelevant Code Snippets (Code itself remains unchanged):\nNo specific code snippets provided for this abstraction.\n\nInstructions for the chapter (Generate content in Korean unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 4:    (Dataclass Creator)`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).\n\n- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).\n\n- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).\n\n- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).\n\n- Heavily use analogies and examples throughout (in Korean) to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 4:    (Dataclass Creator)\n\n[ :   (Schema Generator)](03____schema_generator_.md)   JSON    .   '   (Dataclass Creator)'   Python   Pydantic     .\n\n##  \n\n               Pydantic       .          .\n\n ,     ,             .\n\n##  \n\n          .\n\n### 1.  Python  \n\n  Python    .   `@dataclass`    ,        .\n\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n```\n\n   Python   .         .\n\n### 2. Pydantic  \n\nPydantic         .         .\n\n```python\nfrom pydantic.dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n```\n\n    Pydantic    .     .\n\n##  \n\n       Pydantic     .\n\n###  \n\n   ,       .\n\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\nfrom pydantic import dataclasses\n\nUser = dataclasses.dataclass(User)\n```\n\n     `User`   `pydantic.dataclasses.dataclass`    .\n\n  `User`   Pydantic      .\n\n###  \n\n Pydantic          .\n\n```python\ntry:\n    user = User(name=None, age='not_a_number')\nexcept ValueError as e:\n    print(e)\n```\n\n  `name` `None`, `age`       ,    .\n\n##   \n\nPydantic       .         .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Pydantic\n    ->>:    \n    ->>Pydantic:    \n    Pydantic-->>: Pydantic   \n```\n\n       ,  Pydantic   Pydantic      .\n\n## \n\n   Python   Pydantic         .      Pydantic      .   [  (Internal Utils)](05____internal_utils_.md)   .  !",
    "\nIMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.\n\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `pydantic` about the concept: \"  (Internal Utils)\". This is Chapter 5.\n\nConcept Details (Note: Provided in Korean):\n- Name:   (Internal Utils)\n- Description:\n         , Pydantic    .\n\nComplete Tutorial Structure (Note: Chapter names might be in Korean):\n1. [  (Config Wrapper)](01____config_wrapper_.md)\n2. [  (Core Metadata)](02____core_metadata_.md)\n3. [  (Schema Generator)](03____schema_generator_.md)\n4. [   (Dataclass Creator)](04_____dataclass_creator_.md)\n5. [  (Internal Utils)](05____internal_utils_.md)\n6. [   (Dynamic Import Functionality)](06_____dynamic_import_functionality_.md)\n7. [  (Warning System)](07____warning_system_.md)\n8. [  (Decorator Info)](08____decorator_info_.md)\n\nContext from previous chapters (Note: This summary might be in Korean):\n# Chapter 1:   (Config Wrapper)\n\nPydantic           .   Pydantic \"  (Config Wrapper)\"  .   Pydantic          .     .\n\n##  \n\n  Pydantic        .        ,       .\n\n ,               .           .\n\n##    \n\n        .\n\n### 1. ConfigDict\n\n  ConfigDict (dictionary)    . ConfigDict    ,        .\n\n```python\nfrom pydantic import BaseModel\n\nclass MyModel(BaseModel):\n    class Config:\n        any_config_option = True  #    \n```\n\n  `Config`    `MyModel`  .\n\n### 2.  \n\n  ConfigDict    .        .\n\n### 3.   \n\n           .       .\n\n##    \n\n         .\n\n```python\nfrom pydantic import BaseModel\n\nclass UserModel(BaseModel):\n    name: str\n    age: int\n\n    class Config:\n        anystr_strip_whitespace = True  #    \n```\n\n  `UserModel`        .       .\n\n##   \n\n     . Pydantic     Config     .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    ->>:    \n    ->>:  \n```\n\n          ,     .\n\n## \n\n  Pydantic    .    Pydantic    ,     .   [  (Core Metadata)](02____core_metadata_.md)  Pydantic    . Pydantic    !\n---\n# Chapter 2:   (Core Metadata)\n\n[ :   (Config Wrapper)](01____config_wrapper_.md) Pydantic          .  [  (Core Metadata)]  .\n\n##  \n\n  Pydantic        .    ,        .             .\n\n##  \n\n        .\n\n### 1.   \n\n     (dictionary)  .   JSON       ,       .\n\n ,   JSON    ,            .\n\n```python\nfrom pydantic import BaseModel, Field\n\nclass Product(BaseModel):\n    name: str = Field(description='')\n    price: float = Field(ge=0, description='')\n\n# `Product`     .\nschema = Product.schema()\nprint(schema)\n```\n\n  `Product`    .   JSON,       .\n\n### 2.   \n\n   (Reference)     .  ,             .\n\n### 3.   \n\n           .         .\n\n##   \n\n        . Pydantic         .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant \n    ->>: JSON  \n    ->>:   \n    -->>:   \n    -->>: JSON  \n```\n\n    JSON  ,          .\n\n## \n\n  Pydantic       ,         .   [  (Schema Generator)](03____schema_generator_.md)        .  !\n---\n# Chapter 3:   (Schema Generator)\n\n[ :   (Core Metadata)](02____core_metadata_.md) Pydantic          .   '  (Schema Generator)' ,   JSON    .\n\n##  \n\n  Pydantic   JSON          .           .\n\n ,                   .      .\n\n##  \n\n### 1. JSON  \n\n      JSON   .     ,    .\n\n ,         .\n\n```python\nfrom pydantic import BaseModel\n\nclass Product(BaseModel):\n    name: str\n    price: float\n\n# JSON  \nschema = Product.schema_json(indent=2)\nprint(schema)\n```\n\n  `Product`  JSON   .    `name` `price`   .\n\n### 2.   \n\n            .       .\n\n```python\nfrom pydantic import Field\n\nclass DetailedProduct(Product):\n    name: str = Field(description='')\n    price: float = Field(ge=0, description=' (0 )')\n\n#   JSON  \ndetailed_schema = DetailedProduct.schema_json(indent=2)\nprint(detailed_schema)\n```\n\n `DetailedProduct`    `description`       .\n\n##   \n\n       .        .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant  \n    ->>:  \n    ->> :   \n     -->>: JSON  \n    -->>: JSON  \n```\n\n     ,         JSON  .\n\n## \n\n  Pydantic      JSON     .       ,      .   [   (Dataclass Creator)](04_____dataclass_creator_.md)  .  !\n---\n# Chapter 4:    (Dataclass Creator)\n\n[ :   (Schema Generator)](03____schema_generator_.md)   JSON    .   '   (Dataclass Creator)'   Python   Pydantic     .\n\n##  \n\n               Pydantic       .          .\n\n ,     ,             .\n\n##  \n\n          .\n\n### 1.  Python  \n\n  Python    .   `@dataclass`    ,        .\n\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n```\n\n   Python   .         .\n\n### 2. Pydantic  \n\nPydantic         .         .\n\n```python\nfrom pydantic.dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n```\n\n    Pydantic    .     .\n\n##  \n\n       Pydantic     .\n\n###  \n\n   ,       .\n\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\nfrom pydantic import dataclasses\n\nUser = dataclasses.dataclass(User)\n```\n\n     `User`   `pydantic.dataclasses.dataclass`    .\n\n  `User`   Pydantic      .\n\n###  \n\n Pydantic          .\n\n```python\ntry:\n    user = User(name=None, age='not_a_number')\nexcept ValueError as e:\n    print(e)\n```\n\n  `name` `None`, `age`       ,    .\n\n##   \n\nPydantic       .         .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Pydantic\n    ->>:    \n    ->>Pydantic:    \n    Pydantic-->>: Pydantic   \n```\n\n       ,  Pydantic   Pydantic      .\n\n## \n\n   Python   Pydantic         .      Pydantic      .   [  (Internal Utils)](05____internal_utils_.md)   .  !\n\nRelevant Code Snippets (Code itself remains unchanged):\nNo specific code snippets provided for this abstraction.\n\nInstructions for the chapter (Generate content in Korean unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 5:   (Internal Utils)`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).\n\n- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).\n\n- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).\n\n- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).\n\n- Heavily use analogies and examples throughout (in Korean) to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 5:   (Internal Utils)\n\n[ :    (Dataclass Creator)](04_____dataclass_creator_.md)  Python   Pydantic         .   '  (Internal Utils)'  Pydantic         .\n\n##  \n\n           . Pydantic          .                .\n\n##  \n\n### 1.   \n\n       .  ,       .     .\n\n```python\nfrom pydantic.utils import is_integer\n\nprint(is_integer(123))  # True\nprint(is_integer('123'))  # False\n```\n\n  `is_integer`     .  `123` ,  `'123'`  .\n\n### 2.   \n\n          .   Pydantic        .\n\n##  \n\n       . Pydantic           .\n\n###  \n\n       .\n\n```python\nfrom pydantic.utils import lenient_issubclass\n\nclass Base:\n    pass\n\nclass Sub(Base):\n    pass\n\nprint(lenient_issubclass(Sub, Base))  # True\nprint(lenient_issubclass(Base, Sub))  # False\n```\n\n  `lenient_issubclass`         .\n\n###  \n\n        .           .\n\n##   \n\n   ,         .         .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    ->>:    \n    -->>:   \n```\n\n             .\n\n###  \n\n    .\n\n```python\n# pseudo-module.py\ndef is_string(value):\n    return isinstance(value, str)\n\n#  :\nprint(is_string(\"Hello\"))  # True\n```\n\n      `is_string`  ,       .\n\n## \n\n          . Pydantic           .   [   (Dynamic Import Functionality)](06_____dynamic_import_functionality_.md)  .  !",
    "\nIMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.\n\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `pydantic` about the concept: \"   (Dynamic Import Functionality)\". This is Chapter 6.\n\nConcept Details (Note: Provided in Korean):\n- Name:    (Dynamic Import Functionality)\n- Description:\n      Pydantic        .\n\nComplete Tutorial Structure (Note: Chapter names might be in Korean):\n1. [  (Config Wrapper)](01____config_wrapper_.md)\n2. [  (Core Metadata)](02____core_metadata_.md)\n3. [  (Schema Generator)](03____schema_generator_.md)\n4. [   (Dataclass Creator)](04_____dataclass_creator_.md)\n5. [  (Internal Utils)](05____internal_utils_.md)\n6. [   (Dynamic Import Functionality)](06_____dynamic_import_functionality_.md)\n7. [  (Warning System)](07____warning_system_.md)\n8. [  (Decorator Info)](08____decorator_info_.md)\n\nContext from previous chapters (Note: This summary might be in Korean):\n# Chapter 1:   (Config Wrapper)\n\nPydantic           .   Pydantic \"  (Config Wrapper)\"  .   Pydantic          .     .\n\n##  \n\n  Pydantic        .        ,       .\n\n ,               .           .\n\n##    \n\n        .\n\n### 1. ConfigDict\n\n  ConfigDict (dictionary)    . ConfigDict    ,        .\n\n```python\nfrom pydantic import BaseModel\n\nclass MyModel(BaseModel):\n    class Config:\n        any_config_option = True  #    \n```\n\n  `Config`    `MyModel`  .\n\n### 2.  \n\n  ConfigDict    .        .\n\n### 3.   \n\n           .       .\n\n##    \n\n         .\n\n```python\nfrom pydantic import BaseModel\n\nclass UserModel(BaseModel):\n    name: str\n    age: int\n\n    class Config:\n        anystr_strip_whitespace = True  #    \n```\n\n  `UserModel`        .       .\n\n##   \n\n     . Pydantic     Config     .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    ->>:    \n    ->>:  \n```\n\n          ,     .\n\n## \n\n  Pydantic    .    Pydantic    ,     .   [  (Core Metadata)](02____core_metadata_.md)  Pydantic    . Pydantic    !\n---\n# Chapter 2:   (Core Metadata)\n\n[ :   (Config Wrapper)](01____config_wrapper_.md) Pydantic          .  [  (Core Metadata)]  .\n\n##  \n\n  Pydantic        .    ,        .             .\n\n##  \n\n        .\n\n### 1.   \n\n     (dictionary)  .   JSON       ,       .\n\n ,   JSON    ,            .\n\n```python\nfrom pydantic import BaseModel, Field\n\nclass Product(BaseModel):\n    name: str = Field(description='')\n    price: float = Field(ge=0, description='')\n\n# `Product`     .\nschema = Product.schema()\nprint(schema)\n```\n\n  `Product`    .   JSON,       .\n\n### 2.   \n\n   (Reference)     .  ,             .\n\n### 3.   \n\n           .         .\n\n##   \n\n        . Pydantic         .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant \n    ->>: JSON  \n    ->>:   \n    -->>:   \n    -->>: JSON  \n```\n\n    JSON  ,          .\n\n## \n\n  Pydantic       ,         .   [  (Schema Generator)](03____schema_generator_.md)        .  !\n---\n# Chapter 3:   (Schema Generator)\n\n[ :   (Core Metadata)](02____core_metadata_.md) Pydantic          .   '  (Schema Generator)' ,   JSON    .\n\n##  \n\n  Pydantic   JSON          .           .\n\n ,                   .      .\n\n##  \n\n### 1. JSON  \n\n      JSON   .     ,    .\n\n ,         .\n\n```python\nfrom pydantic import BaseModel\n\nclass Product(BaseModel):\n    name: str\n    price: float\n\n# JSON  \nschema = Product.schema_json(indent=2)\nprint(schema)\n```\n\n  `Product`  JSON   .    `name` `price`   .\n\n### 2.   \n\n            .       .\n\n```python\nfrom pydantic import Field\n\nclass DetailedProduct(Product):\n    name: str = Field(description='')\n    price: float = Field(ge=0, description=' (0 )')\n\n#   JSON  \ndetailed_schema = DetailedProduct.schema_json(indent=2)\nprint(detailed_schema)\n```\n\n `DetailedProduct`    `description`       .\n\n##   \n\n       .        .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant  \n    ->>:  \n    ->> :   \n     -->>: JSON  \n    -->>: JSON  \n```\n\n     ,         JSON  .\n\n## \n\n  Pydantic      JSON     .       ,      .   [   (Dataclass Creator)](04_____dataclass_creator_.md)  .  !\n---\n# Chapter 4:    (Dataclass Creator)\n\n[ :   (Schema Generator)](03____schema_generator_.md)   JSON    .   '   (Dataclass Creator)'   Python   Pydantic     .\n\n##  \n\n               Pydantic       .          .\n\n ,     ,             .\n\n##  \n\n          .\n\n### 1.  Python  \n\n  Python    .   `@dataclass`    ,        .\n\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n```\n\n   Python   .         .\n\n### 2. Pydantic  \n\nPydantic         .         .\n\n```python\nfrom pydantic.dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n```\n\n    Pydantic    .     .\n\n##  \n\n       Pydantic     .\n\n###  \n\n   ,       .\n\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\nfrom pydantic import dataclasses\n\nUser = dataclasses.dataclass(User)\n```\n\n     `User`   `pydantic.dataclasses.dataclass`    .\n\n  `User`   Pydantic      .\n\n###  \n\n Pydantic          .\n\n```python\ntry:\n    user = User(name=None, age='not_a_number')\nexcept ValueError as e:\n    print(e)\n```\n\n  `name` `None`, `age`       ,    .\n\n##   \n\nPydantic       .         .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Pydantic\n    ->>:    \n    ->>Pydantic:    \n    Pydantic-->>: Pydantic   \n```\n\n       ,  Pydantic   Pydantic      .\n\n## \n\n   Python   Pydantic         .      Pydantic      .   [  (Internal Utils)](05____internal_utils_.md)   .  !\n---\n# Chapter 5:   (Internal Utils)\n\n[ :    (Dataclass Creator)](04_____dataclass_creator_.md)  Python   Pydantic         .   '  (Internal Utils)'  Pydantic         .\n\n##  \n\n           . Pydantic          .                .\n\n##  \n\n### 1.   \n\n       .  ,       .     .\n\n```python\nfrom pydantic.utils import is_integer\n\nprint(is_integer(123))  # True\nprint(is_integer('123'))  # False\n```\n\n  `is_integer`     .  `123` ,  `'123'`  .\n\n### 2.   \n\n          .   Pydantic        .\n\n##  \n\n       . Pydantic           .\n\n###  \n\n       .\n\n```python\nfrom pydantic.utils import lenient_issubclass\n\nclass Base:\n    pass\n\nclass Sub(Base):\n    pass\n\nprint(lenient_issubclass(Sub, Base))  # True\nprint(lenient_issubclass(Base, Sub))  # False\n```\n\n  `lenient_issubclass`         .\n\n###  \n\n        .           .\n\n##   \n\n   ,         .         .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    ->>:    \n    -->>:   \n```\n\n             .\n\n###  \n\n    .\n\n```python\n# pseudo-module.py\ndef is_string(value):\n    return isinstance(value, str)\n\n#  :\nprint(is_string(\"Hello\"))  # True\n```\n\n      `is_string`  ,       .\n\n## \n\n          . Pydantic           .   [   (Dynamic Import Functionality)](06_____dynamic_import_functionality_.md)  .  !\n\nRelevant Code Snippets (Code itself remains unchanged):\nNo specific code snippets provided for this abstraction.\n\nInstructions for the chapter (Generate content in Korean unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 6:    (Dynamic Import Functionality)`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).\n\n- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).\n\n- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).\n\n- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).\n\n- Heavily use analogies and examples throughout (in Korean) to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 6:    (Dynamic Import Functionality)\n\n[ :   (Internal Utils)](05____internal_utils_.md) Pydantic           .   Pydantic  \"   (Dynamic Import Functionality)\"  .        Pydantic       .\n\n##  \n\n              .               ,      .\n\n ,           .               .\n\n##  \n\n           .\n\n### 1. `import_module` \n\n`import_module`  `importlib`   ,       .      .\n\n```python\nimport importlib\n\n#  \"os\"  \nos_module = importlib.import_module('os')\nprint(os_module.getcwd())  #    \n```\n\n  `os`       .        .\n\n### 2.    \n\n     ,          .\n\n```python\ndef get_current_directory():\n    import importlib  #    import\n    os_module = importlib.import_module('os')\n    return os_module.getcwd()\n\nprint(get_current_directory())  #    os  .\n```\n\n  `get_current_directory`     `os`  .\n\n##   \n\n      .    `import_module`      .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant importlib\n    participant \n    ->>importlib: import_module \n    importlib->>:    \n    -->>importlib:   \n    importlib-->>:   \n```\n\n###   \n\n `import_module`    . `importlib`        .\n\n```python\n# importlib   ( )\n\ndef import_module(name):\n    #      .\n    module = sys.modules.get(name)\n    if module is None:\n        #    ,  .\n        __import__(name)\n        module = sys.modules[name]\n    return module\n```\n\n  `importlib` `import_module`    .        .\n\n## \n\n  Pydantic              .         .    [  (Warning System)](07____warning_system_.md)  .  !",
    "\nIMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.\n\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `pydantic` about the concept: \"  (Warning System)\". This is Chapter 7.\n\nConcept Details (Note: Provided in Korean):\n- Name:   (Warning System)\n- Description:\nPydantic   deprecated           .\n\nComplete Tutorial Structure (Note: Chapter names might be in Korean):\n1. [  (Config Wrapper)](01____config_wrapper_.md)\n2. [  (Core Metadata)](02____core_metadata_.md)\n3. [  (Schema Generator)](03____schema_generator_.md)\n4. [   (Dataclass Creator)](04_____dataclass_creator_.md)\n5. [  (Internal Utils)](05____internal_utils_.md)\n6. [   (Dynamic Import Functionality)](06_____dynamic_import_functionality_.md)\n7. [  (Warning System)](07____warning_system_.md)\n8. [  (Decorator Info)](08____decorator_info_.md)\n\nContext from previous chapters (Note: This summary might be in Korean):\n# Chapter 1:   (Config Wrapper)\n\nPydantic           .   Pydantic \"  (Config Wrapper)\"  .   Pydantic          .     .\n\n##  \n\n  Pydantic        .        ,       .\n\n ,               .           .\n\n##    \n\n        .\n\n### 1. ConfigDict\n\n  ConfigDict (dictionary)    . ConfigDict    ,        .\n\n```python\nfrom pydantic import BaseModel\n\nclass MyModel(BaseModel):\n    class Config:\n        any_config_option = True  #    \n```\n\n  `Config`    `MyModel`  .\n\n### 2.  \n\n  ConfigDict    .        .\n\n### 3.   \n\n           .       .\n\n##    \n\n         .\n\n```python\nfrom pydantic import BaseModel\n\nclass UserModel(BaseModel):\n    name: str\n    age: int\n\n    class Config:\n        anystr_strip_whitespace = True  #    \n```\n\n  `UserModel`        .       .\n\n##   \n\n     . Pydantic     Config     .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    ->>:    \n    ->>:  \n```\n\n          ,     .\n\n## \n\n  Pydantic    .    Pydantic    ,     .   [  (Core Metadata)](02____core_metadata_.md)  Pydantic    . Pydantic    !\n---\n# Chapter 2:   (Core Metadata)\n\n[ :   (Config Wrapper)](01____config_wrapper_.md) Pydantic          .  [  (Core Metadata)]  .\n\n##  \n\n  Pydantic        .    ,        .             .\n\n##  \n\n        .\n\n### 1.   \n\n     (dictionary)  .   JSON       ,       .\n\n ,   JSON    ,            .\n\n```python\nfrom pydantic import BaseModel, Field\n\nclass Product(BaseModel):\n    name: str = Field(description='')\n    price: float = Field(ge=0, description='')\n\n# `Product`     .\nschema = Product.schema()\nprint(schema)\n```\n\n  `Product`    .   JSON,       .\n\n### 2.   \n\n   (Reference)     .  ,             .\n\n### 3.   \n\n           .         .\n\n##   \n\n        . Pydantic         .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant \n    ->>: JSON  \n    ->>:   \n    -->>:   \n    -->>: JSON  \n```\n\n    JSON  ,          .\n\n## \n\n  Pydantic       ,         .   [  (Schema Generator)](03____schema_generator_.md)        .  !\n---\n# Chapter 3:   (Schema Generator)\n\n[ :   (Core Metadata)](02____core_metadata_.md) Pydantic          .   '  (Schema Generator)' ,   JSON    .\n\n##  \n\n  Pydantic   JSON          .           .\n\n ,                   .      .\n\n##  \n\n### 1. JSON  \n\n      JSON   .     ,    .\n\n ,         .\n\n```python\nfrom pydantic import BaseModel\n\nclass Product(BaseModel):\n    name: str\n    price: float\n\n# JSON  \nschema = Product.schema_json(indent=2)\nprint(schema)\n```\n\n  `Product`  JSON   .    `name` `price`   .\n\n### 2.   \n\n            .       .\n\n```python\nfrom pydantic import Field\n\nclass DetailedProduct(Product):\n    name: str = Field(description='')\n    price: float = Field(ge=0, description=' (0 )')\n\n#   JSON  \ndetailed_schema = DetailedProduct.schema_json(indent=2)\nprint(detailed_schema)\n```\n\n `DetailedProduct`    `description`       .\n\n##   \n\n       .        .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant  \n    ->>:  \n    ->> :   \n     -->>: JSON  \n    -->>: JSON  \n```\n\n     ,         JSON  .\n\n## \n\n  Pydantic      JSON     .       ,      .   [   (Dataclass Creator)](04_____dataclass_creator_.md)  .  !\n---\n# Chapter 4:    (Dataclass Creator)\n\n[ :   (Schema Generator)](03____schema_generator_.md)   JSON    .   '   (Dataclass Creator)'   Python   Pydantic     .\n\n##  \n\n               Pydantic       .          .\n\n ,     ,             .\n\n##  \n\n          .\n\n### 1.  Python  \n\n  Python    .   `@dataclass`    ,        .\n\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n```\n\n   Python   .         .\n\n### 2. Pydantic  \n\nPydantic         .         .\n\n```python\nfrom pydantic.dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n```\n\n    Pydantic    .     .\n\n##  \n\n       Pydantic     .\n\n###  \n\n   ,       .\n\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\nfrom pydantic import dataclasses\n\nUser = dataclasses.dataclass(User)\n```\n\n     `User`   `pydantic.dataclasses.dataclass`    .\n\n  `User`   Pydantic      .\n\n###  \n\n Pydantic          .\n\n```python\ntry:\n    user = User(name=None, age='not_a_number')\nexcept ValueError as e:\n    print(e)\n```\n\n  `name` `None`, `age`       ,    .\n\n##   \n\nPydantic       .         .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Pydantic\n    ->>:    \n    ->>Pydantic:    \n    Pydantic-->>: Pydantic   \n```\n\n       ,  Pydantic   Pydantic      .\n\n## \n\n   Python   Pydantic         .      Pydantic      .   [  (Internal Utils)](05____internal_utils_.md)   .  !\n---\n# Chapter 5:   (Internal Utils)\n\n[ :    (Dataclass Creator)](04_____dataclass_creator_.md)  Python   Pydantic         .   '  (Internal Utils)'  Pydantic         .\n\n##  \n\n           . Pydantic          .                .\n\n##  \n\n### 1.   \n\n       .  ,       .     .\n\n```python\nfrom pydantic.utils import is_integer\n\nprint(is_integer(123))  # True\nprint(is_integer('123'))  # False\n```\n\n  `is_integer`     .  `123` ,  `'123'`  .\n\n### 2.   \n\n          .   Pydantic        .\n\n##  \n\n       . Pydantic           .\n\n###  \n\n       .\n\n```python\nfrom pydantic.utils import lenient_issubclass\n\nclass Base:\n    pass\n\nclass Sub(Base):\n    pass\n\nprint(lenient_issubclass(Sub, Base))  # True\nprint(lenient_issubclass(Base, Sub))  # False\n```\n\n  `lenient_issubclass`         .\n\n###  \n\n        .           .\n\n##   \n\n   ,         .         .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    ->>:    \n    -->>:   \n```\n\n             .\n\n###  \n\n    .\n\n```python\n# pseudo-module.py\ndef is_string(value):\n    return isinstance(value, str)\n\n#  :\nprint(is_string(\"Hello\"))  # True\n```\n\n      `is_string`  ,       .\n\n## \n\n          . Pydantic           .   [   (Dynamic Import Functionality)](06_____dynamic_import_functionality_.md)  .  !\n---\n# Chapter 6:    (Dynamic Import Functionality)\n\n[ :   (Internal Utils)](05____internal_utils_.md) Pydantic           .   Pydantic  \"   (Dynamic Import Functionality)\"  .        Pydantic       .\n\n##  \n\n              .               ,      .\n\n ,           .               .\n\n##  \n\n           .\n\n### 1. `import_module` \n\n`import_module`  `importlib`   ,       .      .\n\n```python\nimport importlib\n\n#  \"os\"  \nos_module = importlib.import_module('os')\nprint(os_module.getcwd())  #    \n```\n\n  `os`       .        .\n\n### 2.    \n\n     ,          .\n\n```python\ndef get_current_directory():\n    import importlib  #    import\n    os_module = importlib.import_module('os')\n    return os_module.getcwd()\n\nprint(get_current_directory())  #    os  .\n```\n\n  `get_current_directory`     `os`  .\n\n##   \n\n      .    `import_module`      .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant importlib\n    participant \n    ->>importlib: import_module \n    importlib->>:    \n    -->>importlib:   \n    importlib-->>:   \n```\n\n###   \n\n `import_module`    . `importlib`        .\n\n```python\n# importlib   ( )\n\ndef import_module(name):\n    #      .\n    module = sys.modules.get(name)\n    if module is None:\n        #    ,  .\n        __import__(name)\n        module = sys.modules[name]\n    return module\n```\n\n  `importlib` `import_module`    .        .\n\n## \n\n  Pydantic              .         .    [  (Warning System)](07____warning_system_.md)  .  !\n\nRelevant Code Snippets (Code itself remains unchanged):\nNo specific code snippets provided for this abstraction.\n\nInstructions for the chapter (Generate content in Korean unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 7:   (Warning System)`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).\n\n- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).\n\n- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).\n\n- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).\n\n- Heavily use analogies and examples throughout (in Korean) to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 7:   (Warning System)\n\n[ :    (Dynamic Import Functionality)](06_____dynamic_import_functionality_.md)         .   Pydantic \"  (Warning System)\" .   deprecated            .\n\n##  \n\n        .    ,            .      ,        .\n\n ,  `field_renamed`     Pydantic              .\n\n##  \n\n### 1.   \n\n             .   deprecated     .\n\n```python\nimport warnings\n\ndef old_function():\n    warnings.warn(\"  deprecated .\", DeprecationWarning)\n\nold_function()\n```\n\n  `old_function`   `DeprecationWarning`         .\n\n### 2.  \n\n           .         .\n\n##  \n\n         .\n\n###  \n\n```python\nimport warnings\n\ndef calculate_area(radius):\n    warnings.warn(\n        \"    .   .\", \n        DeprecationWarning\n    )\n    return 3.14 * radius * radius\n\n#     .\ncalculate_area(5)\n```\n\n  `calculate_area`  deprecated     .      .\n\n###  \n\n    `calculate_area`           .\n\n##   \n\n        .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    ->>:  \n    ->>:   \n    -->>:   \n```\n\n     ,         .\n\n###   \n\nPython `warnings`         .\n\n```python\n# pseudo_module.py\nimport warnings\n\ndef deprecated_feature():\n    warnings.warn(\"     .\", FutureWarning)\n```\n\n  `warnings.warn`           .\n\n## \n\n  Pydantic    deprecated            .        .    [  (Decorator Info)](08____decorator_info_.md)  .  !",
    "\nIMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.\n\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `pydantic` about the concept: \"  (Decorator Info)\". This is Chapter 8.\n\nConcept Details (Note: Provided in Korean):\n- Name:   (Decorator Info)\n- Description:\n              ,     .\n\nComplete Tutorial Structure (Note: Chapter names might be in Korean):\n1. [  (Config Wrapper)](01____config_wrapper_.md)\n2. [  (Core Metadata)](02____core_metadata_.md)\n3. [  (Schema Generator)](03____schema_generator_.md)\n4. [   (Dataclass Creator)](04_____dataclass_creator_.md)\n5. [  (Internal Utils)](05____internal_utils_.md)\n6. [   (Dynamic Import Functionality)](06_____dynamic_import_functionality_.md)\n7. [  (Warning System)](07____warning_system_.md)\n8. [  (Decorator Info)](08____decorator_info_.md)\n\nContext from previous chapters (Note: This summary might be in Korean):\n# Chapter 1:   (Config Wrapper)\n\nPydantic           .   Pydantic \"  (Config Wrapper)\"  .   Pydantic          .     .\n\n##  \n\n  Pydantic        .        ,       .\n\n ,               .           .\n\n##    \n\n        .\n\n### 1. ConfigDict\n\n  ConfigDict (dictionary)    . ConfigDict    ,        .\n\n```python\nfrom pydantic import BaseModel\n\nclass MyModel(BaseModel):\n    class Config:\n        any_config_option = True  #    \n```\n\n  `Config`    `MyModel`  .\n\n### 2.  \n\n  ConfigDict    .        .\n\n### 3.   \n\n           .       .\n\n##    \n\n         .\n\n```python\nfrom pydantic import BaseModel\n\nclass UserModel(BaseModel):\n    name: str\n    age: int\n\n    class Config:\n        anystr_strip_whitespace = True  #    \n```\n\n  `UserModel`        .       .\n\n##   \n\n     . Pydantic     Config     .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    ->>:    \n    ->>:  \n```\n\n          ,     .\n\n## \n\n  Pydantic    .    Pydantic    ,     .   [  (Core Metadata)](02____core_metadata_.md)  Pydantic    . Pydantic    !\n---\n# Chapter 2:   (Core Metadata)\n\n[ :   (Config Wrapper)](01____config_wrapper_.md) Pydantic          .  [  (Core Metadata)]  .\n\n##  \n\n  Pydantic        .    ,        .             .\n\n##  \n\n        .\n\n### 1.   \n\n     (dictionary)  .   JSON       ,       .\n\n ,   JSON    ,            .\n\n```python\nfrom pydantic import BaseModel, Field\n\nclass Product(BaseModel):\n    name: str = Field(description='')\n    price: float = Field(ge=0, description='')\n\n# `Product`     .\nschema = Product.schema()\nprint(schema)\n```\n\n  `Product`    .   JSON,       .\n\n### 2.   \n\n   (Reference)     .  ,             .\n\n### 3.   \n\n           .         .\n\n##   \n\n        . Pydantic         .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant \n    ->>: JSON  \n    ->>:   \n    -->>:   \n    -->>: JSON  \n```\n\n    JSON  ,          .\n\n## \n\n  Pydantic       ,         .   [  (Schema Generator)](03____schema_generator_.md)        .  !\n---\n# Chapter 3:   (Schema Generator)\n\n[ :   (Core Metadata)](02____core_metadata_.md) Pydantic          .   '  (Schema Generator)' ,   JSON    .\n\n##  \n\n  Pydantic   JSON          .           .\n\n ,                   .      .\n\n##  \n\n### 1. JSON  \n\n      JSON   .     ,    .\n\n ,         .\n\n```python\nfrom pydantic import BaseModel\n\nclass Product(BaseModel):\n    name: str\n    price: float\n\n# JSON  \nschema = Product.schema_json(indent=2)\nprint(schema)\n```\n\n  `Product`  JSON   .    `name` `price`   .\n\n### 2.   \n\n            .       .\n\n```python\nfrom pydantic import Field\n\nclass DetailedProduct(Product):\n    name: str = Field(description='')\n    price: float = Field(ge=0, description=' (0 )')\n\n#   JSON  \ndetailed_schema = DetailedProduct.schema_json(indent=2)\nprint(detailed_schema)\n```\n\n `DetailedProduct`    `description`       .\n\n##   \n\n       .        .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant  \n    ->>:  \n    ->> :   \n     -->>: JSON  \n    -->>: JSON  \n```\n\n     ,         JSON  .\n\n## \n\n  Pydantic      JSON     .       ,      .   [   (Dataclass Creator)](04_____dataclass_creator_.md)  .  !\n---\n# Chapter 4:    (Dataclass Creator)\n\n[ :   (Schema Generator)](03____schema_generator_.md)   JSON    .   '   (Dataclass Creator)'   Python   Pydantic     .\n\n##  \n\n               Pydantic       .          .\n\n ,     ,             .\n\n##  \n\n          .\n\n### 1.  Python  \n\n  Python    .   `@dataclass`    ,        .\n\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n```\n\n   Python   .         .\n\n### 2. Pydantic  \n\nPydantic         .         .\n\n```python\nfrom pydantic.dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n```\n\n    Pydantic    .     .\n\n##  \n\n       Pydantic     .\n\n###  \n\n   ,       .\n\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\nfrom pydantic import dataclasses\n\nUser = dataclasses.dataclass(User)\n```\n\n     `User`   `pydantic.dataclasses.dataclass`    .\n\n  `User`   Pydantic      .\n\n###  \n\n Pydantic          .\n\n```python\ntry:\n    user = User(name=None, age='not_a_number')\nexcept ValueError as e:\n    print(e)\n```\n\n  `name` `None`, `age`       ,    .\n\n##   \n\nPydantic       .         .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Pydantic\n    ->>:    \n    ->>Pydantic:    \n    Pydantic-->>: Pydantic   \n```\n\n       ,  Pydantic   Pydantic      .\n\n## \n\n   Python   Pydantic         .      Pydantic      .   [  (Internal Utils)](05____internal_utils_.md)   .  !\n---\n# Chapter 5:   (Internal Utils)\n\n[ :    (Dataclass Creator)](04_____dataclass_creator_.md)  Python   Pydantic         .   '  (Internal Utils)'  Pydantic         .\n\n##  \n\n           . Pydantic          .                .\n\n##  \n\n### 1.   \n\n       .  ,       .     .\n\n```python\nfrom pydantic.utils import is_integer\n\nprint(is_integer(123))  # True\nprint(is_integer('123'))  # False\n```\n\n  `is_integer`     .  `123` ,  `'123'`  .\n\n### 2.   \n\n          .   Pydantic        .\n\n##  \n\n       . Pydantic           .\n\n###  \n\n       .\n\n```python\nfrom pydantic.utils import lenient_issubclass\n\nclass Base:\n    pass\n\nclass Sub(Base):\n    pass\n\nprint(lenient_issubclass(Sub, Base))  # True\nprint(lenient_issubclass(Base, Sub))  # False\n```\n\n  `lenient_issubclass`         .\n\n###  \n\n        .           .\n\n##   \n\n   ,         .         .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    ->>:    \n    -->>:   \n```\n\n             .\n\n###  \n\n    .\n\n```python\n# pseudo-module.py\ndef is_string(value):\n    return isinstance(value, str)\n\n#  :\nprint(is_string(\"Hello\"))  # True\n```\n\n      `is_string`  ,       .\n\n## \n\n          . Pydantic           .   [   (Dynamic Import Functionality)](06_____dynamic_import_functionality_.md)  .  !\n---\n# Chapter 6:    (Dynamic Import Functionality)\n\n[ :   (Internal Utils)](05____internal_utils_.md) Pydantic           .   Pydantic  \"   (Dynamic Import Functionality)\"  .        Pydantic       .\n\n##  \n\n              .               ,      .\n\n ,           .               .\n\n##  \n\n           .\n\n### 1. `import_module` \n\n`import_module`  `importlib`   ,       .      .\n\n```python\nimport importlib\n\n#  \"os\"  \nos_module = importlib.import_module('os')\nprint(os_module.getcwd())  #    \n```\n\n  `os`       .        .\n\n### 2.    \n\n     ,          .\n\n```python\ndef get_current_directory():\n    import importlib  #    import\n    os_module = importlib.import_module('os')\n    return os_module.getcwd()\n\nprint(get_current_directory())  #    os  .\n```\n\n  `get_current_directory`     `os`  .\n\n##   \n\n      .    `import_module`      .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant importlib\n    participant \n    ->>importlib: import_module \n    importlib->>:    \n    -->>importlib:   \n    importlib-->>:   \n```\n\n###   \n\n `import_module`    . `importlib`        .\n\n```python\n# importlib   ( )\n\ndef import_module(name):\n    #      .\n    module = sys.modules.get(name)\n    if module is None:\n        #    ,  .\n        __import__(name)\n        module = sys.modules[name]\n    return module\n```\n\n  `importlib` `import_module`    .        .\n\n## \n\n  Pydantic              .         .    [  (Warning System)](07____warning_system_.md)  .  !\n---\n# Chapter 7:   (Warning System)\n\n[ :    (Dynamic Import Functionality)](06_____dynamic_import_functionality_.md)         .   Pydantic \"  (Warning System)\" .   deprecated            .\n\n##  \n\n        .    ,            .      ,        .\n\n ,  `field_renamed`     Pydantic              .\n\n##  \n\n### 1.   \n\n             .   deprecated     .\n\n```python\nimport warnings\n\ndef old_function():\n    warnings.warn(\"  deprecated .\", DeprecationWarning)\n\nold_function()\n```\n\n  `old_function`   `DeprecationWarning`         .\n\n### 2.  \n\n           .         .\n\n##  \n\n         .\n\n###  \n\n```python\nimport warnings\n\ndef calculate_area(radius):\n    warnings.warn(\n        \"    .   .\", \n        DeprecationWarning\n    )\n    return 3.14 * radius * radius\n\n#     .\ncalculate_area(5)\n```\n\n  `calculate_area`  deprecated     .      .\n\n###  \n\n    `calculate_area`           .\n\n##   \n\n        .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    ->>:  \n    ->>:   \n    -->>:   \n```\n\n     ,         .\n\n###   \n\nPython `warnings`         .\n\n```python\n# pseudo_module.py\nimport warnings\n\ndef deprecated_feature():\n    warnings.warn(\"     .\", FutureWarning)\n```\n\n  `warnings.warn`           .\n\n## \n\n  Pydantic    deprecated            .        .    [  (Decorator Info)](08____decorator_info_.md)  .  !\n\nRelevant Code Snippets (Code itself remains unchanged):\nNo specific code snippets provided for this abstraction.\n\nInstructions for the chapter (Generate content in Korean unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 8:   (Decorator Info)`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).\n\n- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).\n\n- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).\n\n- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).\n\n- Heavily use analogies and examples throughout (in Korean) to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 8:   (Decorator Info)\n\n[ :   (Warning System)](07____warning_system_.md) Pydantic     deprecated       .   \"  (Decorator Info)\"  .            .\n\n##  \n\n Python        . Pydantic            .  ,         .\n\n###   \n    ,           .         .\n\n##  \n\n### 1.   \n\n          . \n\n```python\nfrom pydantic import BaseModel, validator\n\nclass User(BaseModel):\n    email: str\n\n    @validator('email')\n    def validate_email(cls, v):\n        if '@' not in v:\n            raise ValueError('   .')\n        return v\n```\n\n  `email`   '@'    .\n\n### 2.   \n\n       .       .\n\n```python\nfrom pydantic import BaseModel, root_validator\n\nclass User(BaseModel):\n    email: str\n    age: int\n\n    @root_validator\n    def check_age(cls, values):\n        if values.get('age') < 18:\n            raise ValueError(' 18  .')\n        return values\n```\n\n   18     .\n\n##  \n\n        .\n\n###  \n\n```python\nfrom pydantic import BaseModel, validator\n\nclass Product(BaseModel):\n    name: str\n    price: float\n\n    @validator('price')\n    def check_price(cls, v):\n        if v <= 0:\n            raise ValueError(' 0  .')\n        return v\n```\n\n- `Product`   0  ,      .\n\n###  \n  ,          .\n\n##   \n\n      .       .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant \n    ->>:  \n    ->>:  \n    -->>:   \n    -->>:   /  \n```\n\n              .\n\n###  \n\n      .\n\n```python\n# pseudo_decorator_module.py\ndef validator(field_name):\n    def decorator(func):\n        func._field_name = field_name\n        return func\n    return decorator\n\n#   :\n@validator('price')\ndef check_price(cls, v):\n    #   \n```\n\n  `validator`        .\n\n## \n\n  Pydantic           .           .    [  (Testing and Deployment)](09____testing_and_deployment.md)  .  !",
    "\nAnalyze the following codebase for the project 'develop'.\n\nAvailable files (total 18):\n- 0 # README.md\n- 1 # csvtodb.py\n- 2 # django_project/django_project/__init__.py\n- 3 # django_project/django_project/asgi.py\n- 4 # django_project/django_project/settings.py\n- 5 # django_project/django_project/urls.py\n- 6 # django_project/django_project/wsgi.py\n- 7 # django_project/manage.py\n- 8 # django_project//__init__.py\n- 9 # django_project//admin.py\n- 10 # django_project//apps.py\n- 11 # django_project//migrations/__init__.py\n- 12 # django_project//models.py\n- 13 # django_project//tripadvisor_3_reviews.py\n- 14 # django_project//urls.py\n- 15 # django_project//views.py\n- 16 # inspect_chromadb.py\n- 17 # preprocess.py\n\nFull context of all files:\n--- File Index 0: README.md ---\n---\nmarp: true\ntheme: default\npaginate: true\ntitle: SKN10-4rd-4Team \n---\n\n# SKN10-4rd-4Team\n\n## LLM Document Q&A System\n\n---\n\n## 1.  \n\n   LLM  RAG(Retrieval-Augmented Generation)  ,  \n** HTML     ,    +  TripAdvisor      **.\n\n<img src=\"chatbot_ui.png\" alt=\"  \" width=\"750\" style=\"display:block; margin:0 auto;\" />\n\n---\n\n## 2.  \n\n- **:** 4 (SKN10-4rd-4Team)\n\n|  |  |  |  |  |\n|:------:|:------:|:------:|:--------:|:------:|\n| ![](image/.png) | ![](image/.png) | ![](image/.png) | ![](image/.png) | ![](image/.png) |\n\n---\n<img src=\"image/4.drawio.png\" alt=\"4\" width=\"750\" style=\"display:block; margin:0 auto;\" />\n\n## 3.     \n\n### 3.1  \n\n-   :     ,   27000 \n\n-   : TripAdvisor API      \n\n### 3.2   \n\n- .xlsx          (,  )\n\n-         (,  )\n\n-  +        SentenceTransformer \n\n- ChromaDB    , ,   \n\n<img src=\"image/5.png\" alt=\"  5\" width=\"750\" style=\"display:block; margin:0 auto;\" />\n<img src=\"image/6.png\" alt=\"  6\" width=\"750\" style=\"display:block; margin:0 auto;\" />\n\n---\n\n\n\n## 4.  \n\n**  (CSV )**\n\n- : index.html - , ,    UI\n\n- DB: ChromaDB (    )\n\n-  : intfloat/e5-large-v2   \n\n- : Django  views.py\n\n  -   (+)   \n\n  - TripAdvisor API    \n\n  -  +     GPT-3.5-Turbo   \n\n---\n\n## 5.  \n\n- **Django + OpenAI API + TripAdvisor API + ChromaDB**\n- CSV    embedding \n\n- ChromaDB  DB     \n\n- HTML  UI / \n\n- TripAdvisor     +   \n\n\n---\n\n## 6.  \n\n1. **  (HTML)** :  &  &  \n\n2.        \n\n3.   + TripAdvisor   GPT \n\n4.   HTML \n\n---\n\n## 7. \n\n- ****: `index.html`  /  +   UI\n- ****: `views.py`  Django  GPT   \n- ** **: ChromaDB (  )\n- ** **: `xlsx`    CSV     ChromaDB \n\n---\n\n## 8.  \n\n- **  **:        \n- ** UI**:     \n- **LLM  **:       \n- **  **:           \n- **  **:  vectorDB    API   \n\n---\n\n## 8.1 \n<img src=\"image/1.png\" alt=\"  1\" width=\"750\" style=\"display:block; margin:0 auto;\" />\n<img src=\"image/2.png\" alt=\"  2\" width=\"750\" style=\"display:block; margin:0 auto;\" />\n<img src=\"image/3.png\" alt=\"  3\" width=\"750\" style=\"display:block; margin:0 auto;\" />\n<img src=\"image/4.png\" alt=\"  4\" width=\"750\" style=\"display:block; margin:0 auto;\" />\n\n---\n\n## 9.    & \n\n- **** :     ,      ,            .       ,              .\n- **** :  api  dataset  ,\ntourapi   21 api         .\n   .\n,            ,   batch_size     .\n---\n- **** : \n  -    :  Tavily     ,    TripAdvisor   API    3 ,  RAG      .\n  - UI :   ,   ,       .\n  - Git  :            ,   .      .\n- **** :            \n           \n\n\n---\n\n## 10.  \n\n- **** :       ,              .    ,                 .     !\n- **** :   ,        .\n       .\n- **** :   ChatGPT     ,\n        .\n     ,      .\n- **** :                     \n- **** :      .            .          .\n\n--- File Index 1: csvtodb.py ---\nimport pandas as pd\nimport re\nfrom sentence_transformers import SentenceTransformer\nimport chromadb\n\n###    CSV  &    !!\ncsv_file = \"data/.csv\"\n\n\n###   \ndf = pd.read_csv(csv_file)\n\ndf[''] = df[''].fillna('') + \" \" + df[''].fillna('')\n\ndef clean_text(text):\n    if pd.isna(text):\n        return \"\"\n    text = re.sub(r'<.*?>', ' ', text)\n    text = re.sub(r'[*\\-\\n\\t\\r]+', ' ', text)\n    text = re.sub(r'\\s+', ' ', text).strip()\n    return text\n\ndf[''] = df[''].apply(clean_text)\n\n###  e5-large-v2  \nmodel = SentenceTransformer(\"intfloat/e5-large-v2\")\n\ntexts = df[''].tolist()\nembeddings = model.encode(\n    [\"passage: \" + text for text in texts],\n    show_progress_bar=True\n)\n\n###  ChromaDB \nchroma_client = chromadb.PersistentClient(path=\"./chroma_db\")\ncollection = chroma_client.get_or_create_collection(name=\"places\")\n\n###    (  !!)\nfor idx, row in df.iterrows():\n    collection.add(\n        embeddings=[embeddings[idx]],\n        documents=[row['']],\n        metadatas=[{\n            \"name\": row[''],\n            \"region\": row[''],\n            \"description\": row[''],\n            \"category\": row[''],\n            \"open_time\": row[''],\n            \"closed_day\": row[''],\n            \"detail\": row[''],\n            \"location\": row[''],\n        }]\n    )\n\nprint(f\" {csv_file}   & ChromaDB  !\")\nprint(\"  :\", collection.count())\n\n\n--- File Index 2: django_project/django_project/__init__.py ---\n\n\n--- File Index 3: django_project/django_project/asgi.py ---\n\"\"\"\nASGI config for django_project project.\n\nIt exposes the ASGI callable as a module-level variable named ``application``.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/5.2/howto/deployment/asgi/\n\"\"\"\n\nimport os\n\nfrom django.core.asgi import get_asgi_application\n\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django_project.settings')\n\napplication = get_asgi_application()\n\n\n--- File Index 4: django_project/django_project/settings.py ---\n\"\"\"\nDjango settings for django_project project.\n\nGenerated by 'django-admin startproject' using Django 5.2.1.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/5.2/topics/settings/\n\nFor the full list of settings and their values, see\nhttps://docs.djangoproject.com/en/5.2/ref/settings/\n\"\"\"\n\nfrom pathlib import Path\n\n# Build paths inside the project like this: BASE_DIR / 'subdir'.\nBASE_DIR = Path(__file__).resolve().parent.parent\n\n\n# Quick-start development settings - unsuitable for production\n# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/\n\n# SECURITY WARNING: keep the secret key used in production secret!\nSECRET_KEY = 'django-insecure-c=m)*fg4h!e2hr@s-t6lxz5phdxn*meo6o=a&xg5xm)r#bi!0m'\n\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = True\n\nALLOWED_HOSTS = []\n\n\n# Application definition\n\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    '',\n]\n\nMIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n]\n\nROOT_URLCONF = 'django_project.urls'\n\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [],\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                'django.template.context_processors.request',\n                'django.contrib.auth.context_processors.auth',\n                'django.contrib.messages.context_processors.messages',\n            ],\n        },\n    },\n]\n\nWSGI_APPLICATION = 'django_project.wsgi.application'\n\n\n# Database\n# https://docs.djangoproject.com/en/5.2/ref/settings/#databases\n\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.sqlite3',\n        'NAME': BASE_DIR / 'db.sqlite3',\n    }\n}\n\n\n# Password validation\n# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators\n\nAUTH_PASSWORD_VALIDATORS = [\n    {\n        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',\n    },\n]\n\n\n# Internationalization\n# https://docs.djangoproject.com/en/5.2/topics/i18n/\n\nLANGUAGE_CODE = 'en-us'\n\nTIME_ZONE = 'UTC'\n\nUSE_I18N = True\n\nUSE_TZ = True\n\n\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/5.2/howto/static-files/\n\nSTATIC_URL = 'static/'\n\n# Default primary key field type\n# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field\n\nDEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'\n\n\n--- File Index 5: django_project/django_project/urls.py ---\n\"\"\"\nURL configuration for django_project project.\n\nThe `urlpatterns` list routes URLs to views. For more information please see:\n    https://docs.djangoproject.com/en/5.2/topics/http/urls/\nExamples:\nFunction views\n    1. Add an import:  from my_app import views\n    2. Add a URL to urlpatterns:  path('', views.home, name='home')\nClass-based views\n    1. Add an import:  from other_app.views import Home\n    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')\nIncluding another URLconf\n    1. Import the include() function: from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n\"\"\"\nfrom django.contrib import admin\nfrom django.urls import path, include\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('', include('.urls')),  #  urls \n]\n\n\n\n--- File Index 6: django_project/django_project/wsgi.py ---\n\"\"\"\nWSGI config for django_project project.\n\nIt exposes the WSGI callable as a module-level variable named ``application``.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/\n\"\"\"\n\nimport os\n\nfrom django.core.wsgi import get_wsgi_application\n\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django_project.settings')\n\napplication = get_wsgi_application()\n\n\n--- File Index 7: django_project/manage.py ---\n#!/usr/bin/env python\n\"\"\"Django's command-line utility for administrative tasks.\"\"\"\nimport os\nimport sys\n\n\ndef main():\n    \"\"\"Run administrative tasks.\"\"\"\n    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django_project.settings')\n    try:\n        from django.core.management import execute_from_command_line\n    except ImportError as exc:\n        raise ImportError(\n            \"Couldn't import Django. Are you sure it's installed and \"\n            \"available on your PYTHONPATH environment variable? Did you \"\n            \"forget to activate a virtual environment?\"\n        ) from exc\n    execute_from_command_line(sys.argv)\n\n\nif __name__ == '__main__':\n    main()\n\n\n--- File Index 8: django_project//__init__.py ---\n\n\n--- File Index 9: django_project//admin.py ---\nfrom django.contrib import admin\n\n# Register your models here.\n\n\n--- File Index 10: django_project//apps.py ---\nfrom django.apps import AppConfig\n\n\nclass Config(AppConfig):\n    default_auto_field = 'django.db.models.BigAutoField'\n    name = ''\n\n\n--- File Index 11: django_project//migrations/__init__.py ---\n\n\n--- File Index 12: django_project//models.py ---\nfrom django.db import models\n\n# Create your models here.\n\n\n--- File Index 13: django_project//tripadvisor_3_reviews.py ---\nimport requests\nimport openai\nimport os\nfrom typing import List, Optional\nfrom dotenv import load_dotenv\n\n# ======   ======\n#     .env  \nBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nenv_path = os.path.join(BASE_DIR, '..', '.env')\nload_dotenv(dotenv_path=os.path.abspath(env_path))\n\n# ====== 1.   3  ======\ndef fetch_top3_reviews(place_name: str, api_key: str) -> List[str]:\n    BASE_URL = 'https://api.content.tripadvisor.com/api/v1'\n    # 1)  \n    search_url = f\"{BASE_URL}/location/search\"\n    search_params = {'searchQuery': place_name, 'key': api_key, 'language': 'ko', 'category': 'attractions'}\n    search_resp = requests.get(search_url, params=search_params)\n    search_resp.raise_for_status()\n    search_data = search_resp.json()\n    if not search_data.get('data'):\n        raise ValueError(\"No location found for the given place name.\")\n    location_id = search_data['data'][0]['location_id']\n    # 2)  3 \n    review_url = f\"{BASE_URL}/location/{location_id}/reviews\"\n    review_params = {'limit': 3, 'key': api_key}\n    review_resp = requests.get(review_url, params=review_params)\n    review_resp.raise_for_status()\n    review_data = review_resp.json()\n    reviews = [r['text'] for r in review_data.get('data', [])[:3]]\n    if not reviews:\n        raise ValueError(\"No reviews found for the given location.\")\n    return reviews\n\n# ====== 2. OpenAI API  (openai>=1.0.0) ======\ndef summarize_reviews_openai(reviews: List[str], openai_api_key: str, language: str = \"ko\") -> str:\n    client = openai.OpenAI(api_key=openai_api_key)\n    joined = \"\\n\".join(reviews)\n    prompt = (\n        f\"     3.     .\\n\\n\"\n        f\"{joined}\\n\\n\"\n        f\":\"\n    )\n    response = client.chat.completions.create(\n        model=\"gpt-3.5-turbo\",  #  \"gpt-4\"\n        messages=[\n            {\"role\": \"system\", \"content\": \"    .\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ],\n        max_tokens=200,\n        temperature=0.5,\n    )\n    return response.choices[0].message.content.strip()\n\n# ====== 3.   ======\nif __name__ == \"__main__\":\n    # .env API  \n    API_KEY = os.getenv(\"TRIPADVISOR_API_KEY\")\n    print(\"TripAdvisor :\", os.getenv(\"TRIPADVISOR_API_KEY\"))\n    place = \"\"\n\n    if API_KEY and place:\n        try:\n            reviews = fetch_top3_reviews(place, API_KEY)\n        except Exception as e:\n            print(f\"  : {e}\")\n            exit(1)\n\n    print(\"===   3 ===\")\n    for i, r in enumerate(reviews, 1):\n        print(f\"[{i}] {r}\")\n\n    print(\"\\n===    ( ) ===\")\n    joined_reviews = \" \".join(reviews)\n    print(joined_reviews)\n\n--- File Index 14: django_project//urls.py ---\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('', views.chatbot_view, name='chatbot'),\n]\n\n\n--- File Index 15: django_project//views.py ---\nfrom django.shortcuts import render\nfrom sentence_transformers import SentenceTransformer\nimport chromadb\nfrom openai import OpenAI\nimport os\nfrom dotenv import load_dotenv\nfrom django.conf import settings\nfrom .tripadvisor_3_reviews import fetch_top3_reviews, summarize_reviews_openai\n\n#  chroma_db     \nchroma_db_path = os.path.join(settings.BASE_DIR.parent, \"chroma_db2\")\n\nprint(\"   ChromaDB :\", chroma_db_path)\n\n# .env  \nload_dotenv(dotenv_path=os.path.join(settings.BASE_DIR.parent, \".env\"))\n\nclient = OpenAI(\n    api_key=os.getenv(\"OPENAI_API_KEY\")\n)\n\nchroma_client = chromadb.PersistentClient(path=chroma_db_path)\ncollection = chroma_client.get_or_create_collection(name=\"places\")\n\nmodel = SentenceTransformer(\"intfloat/e5-large-v2\")\n\ndef summarize_place_and_reviews(place_name, place_desc, reviews, openai_client):\n    joined_reviews = \"\\n\".join(reviews)\n    prompt = (\n        f\"  '{place_name}'     .\\n\\n\"\n        f\"[ ]\\n{place_desc}\\n\\n\"\n        f\"[]\\n{joined_reviews}\\n\\n\"\n        f\"       .\"\n    )\n    response = openai_client.chat.completions.create(\n        model=\"gpt-3.5-turbo\",\n        messages=[\n            {\"role\": \"system\", \"content\": \"    .\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ],\n        max_tokens=300,\n        temperature=0.5,\n    )\n    return response.choices[0].message.content.strip()\n\ndef is_recommendation_request(question):\n    check_prompt = f\"\"\"\n       '  ' .\n    -  \"true\",  \"false\" .\n    \n     :\n    \"{question}\"\n    \"\"\"\n\n    response = client.chat.completions.create(\n        model=\"gpt-4o\",\n        messages=[{\"role\": \"user\", \"content\": check_prompt}]\n    )\n\n    return \"true\" in response.choices[0].message.content.lower()\n\ndef is_follow_up_question(question, chat_history):\n    history = \"\"\n    for q, a in chat_history[-3:]:  #  3 \n        history += f\": {q}\\n: {a}\\n\"\n\n    check_prompt = f\"\"\"\n         (   )     .\n    - : \"  \", \" ?\", \" ?\"    .\n    -     \"false\",   \"true\" .\n\n     :\n    {history}\n\n     :\n    \"{question}\"\n    \"\"\"\n\n    response = client.chat.completions.create(\n        model=\"gpt-4o\",\n        messages=[{\"role\": \"user\", \"content\": check_prompt}]\n    )\n\n    return \"true\" in response.choices[0].message.content.lower()\n\n\ndef chatbot_view(request):\n    # ChromaDB    \n    all_places = collection.get(include=[\"metadatas\"])\n    all_locations = sorted(set(meta[\"location\"] for meta in all_places[\"metadatas\"] if \"location\" in meta))\n    all_categories = sorted(set(meta[\"category\"] for meta in all_places[\"metadatas\"] if \"category\" in meta))\n\n    answer = \"\"\n    user_question = \"\"\n    location = \"\"\n    category = \"\"\n\n    #       !\n    if not hasattr(request, '_session_initialized'):\n        request.session['chat_history'] = []\n        request._session_initialized = True\n\n    chat_history = request.session.get('chat_history', [])\n\n    typing = False\n\n    if request.method == \"POST\":\n        user_question = request.POST.get(\"question\")\n        location = request.POST.get(\"location\")\n        category = request.POST.get(\"category\")\n\n        print(\" :\", user_question)\n        print(\" :\", location)\n        print(\" :\", category)\n\n        typing = True\n\n        is_recommend = is_recommendation_request(user_question)\n        is_follow_up = is_follow_up_question(user_question, chat_history)\n\n        #     \n        use_last_places = False\n        places_info = \"\"\n        last_info = request.session.get(\"last_places_info\")\n\n        if not is_recommend and is_follow_up and last_info:\n                places_info = last_info\n                use_last_places = True\n                print(\"     !\")\n        else:\n            print(\"    !\")\n            use_last_places = False\n\n        if not use_last_places:\n            print(\"    !\")\n            query_embedding = model.encode([\"query: \" + user_question])\n            filters = {}\n            if category:\n                filters[\"category\"] = category  #     \n\n            results = collection.query(\n                query_embeddings=query_embedding,\n                n_results=20,\n                where=filters\n            )\n\n            documents = results['documents'][0] if results['documents'][0] else []\n            metadatas = results['metadatas'][0] if results['metadatas'][0] else []\n\n            print(\"  :\", len(documents))\n\n            \n            if documents:\n                unique_places = {}\n                for doc, meta in zip(documents, metadatas):\n                    place_name = meta['name']\n                    if place_name not in unique_places:\n                        unique_places[place_name] = (doc, meta)\n\n                selected_places = list(unique_places.items())[:5]\n\n                if len(selected_places) < 3:\n                    answer = \"     .     !\"\n                    chat_history.append((user_question, answer))\n                    request.session['chat_history'] = chat_history\n                    typing = False\n                    return render(request, \"index.html\", {\n                        \"answer\": answer,\n                        \"user_question\": user_question,\n                        \"location\": location,\n                        \"category\": category,\n                        \"chat_history\": chat_history,\n                        \"typing\": typing,\n                        \"location_list\": all_locations,\n                        \"category_list\": all_categories,\n                    })\n\n                for place_name, (doc, meta) in list(unique_places.items())[:5]:\n                    review_text = \"\"\n                    try:\n                        trip_reviews = fetch_top3_reviews(place_name, os.getenv(\"TRIPADVISOR_API_KEY\"))\n                        review_summary = summarize_place_and_reviews(place_name, doc, trip_reviews, client)\n                        review_text = f\" : {review_summary}\"\n                    except Exception as e:\n                        print(f\"   - {place_name}: {e}\")\n                        review_text = f\": {doc}<br>  : (  )\"  #     !\n\n                    places_info += (\n                        f\": {place_name}<br>\"\n                        f\": {meta['category']}<br>\"\n                        f\": {meta['location']}<br>\"\n                        f\"{review_text}<br><br>\"\n                    )\n\n                if is_recommend:\n                    request.session[\"last_places_info\"] = places_info\n                    print(\"         !\")\n            else:\n                answer = \"     .\"\n                chat_history.append((user_question, answer))\n                request.session['chat_history'] = chat_history\n                typing = False\n                return render(request, \"index.html\", {\n                    \"answer\": answer,\n                    \"user_question\": user_question,\n                    \"location\": location,\n                    \"category\": category,\n                    \"chat_history\": chat_history,\n                    \"typing\": typing\n                })\n        else:\n            print(\"     !\")\n            places_info = last_info\n\n        #  GPT  \n        recent_history = chat_history[-5:]\n\n        chat_context = \"\"\n        for past_q, past_a in recent_history:\n            chat_context += f\": {past_q}\\n: {past_a}\\n\"\n\n        prompt_intro = \"\"\n        if use_last_places:\n            prompt_intro = \"\"\"\n                   .\n                 ,\n              **   **  .\n                !\n            \"\"\"\n\n        prompt = f\"\"\"\n              .\n\n             :\n        {chat_context}\n\n           :\n        \"{user_question}\"\n\n        {prompt_intro}\n\n                 .\n               !\n\n          :\n        - : {location}\n        - : {category}\n\n              :\n\n        {places_info}\n\n        ** **:\n        -     !\n        -    3~5!\n        -    !\n        - :  \n        - : \n        - : ,   !\n        -  <br> !\n        -   ,  !\n\n        ** **:\n        -        .\n        -        .\n        -     ,      !\n        \"\"\"\n\n        response = client.chat.completions.create(\n            model=\"gpt-4o\",\n            messages=[{\"role\": \"user\", \"content\": prompt}]\n        )\n\n        print(\"GPT :\", response)\n\n        answer = response.choices[0].message.content\n        answer = answer.replace(\"1.\", \"<br><br> 1.\").replace(\"2.\", \"<br><br> 2.\")\n        answer = answer.replace(\"3.\", \"<br><br> 3.\").replace(\"4.\", \"<br><br> 4.\")\n        answer = answer.replace(\"\\n\\n\", \"<br><br>\").replace(\"\\n\", \"<br>\")\n\n        chat_history.append((user_question, answer))\n        request.session['chat_history'] = chat_history\n\n        typing = False\n\n    return render(request, \"index.html\", {\n        \"answer\": answer,\n        \"user_question\": user_question,\n        \"location\": location,\n        \"category\": category,\n        \"chat_history\": chat_history,\n        \"typing\": typing,\n        \"location_list\": all_locations,\n        \"category_list\": all_categories,\n    })\n\n\n--- File Index 16: inspect_chromadb.py ---\nimport chromadb\n\n###  ChromaDB \nchroma_client = chromadb.PersistentClient(path=\"./chroma_db\")\ncollection = chroma_client.get_or_create_collection(name=\"places\")\n\n###        \nprint(\"  :\", collection.count())\n\n###  ID   ( 1000 )\nresults = collection.get(include=[\"ids\", \"metadatas\"], limit=1000)\n\nids = results[\"ids\"]\nmetadatas = results[\"metadatas\"]\n\nprint(\"\\n===  ID  ===\")\nfor i, id in enumerate(ids):\n    print(f\"{i+1}: {id}\")\n\nprint(\"\\n===   ===\")\nfor i, meta in enumerate(metadatas[:5]):  #  5  \n    print(f\"ID: {ids[i]}\")\n    print(meta)\n    print(\"------\")\n\n\n--- File Index 17: preprocess.py ---\nimport pandas as pd\nimport re\n\n#  XLSX  \nxlsx_file = \"data/dataset.xlsx\"\ndf = pd.read_excel(xlsx_file, sheet_name=0)  #    \n\n#   \nuse_cols = [\"\",\"\",\"\",\"\",\"\",\"\",\"\"]\ndf_clean = df[use_cols].copy()\ndf_clean.rename(columns={\"\": \"\"}, inplace=True)\n#  /   \ndef extract_region(address):\n    if pd.isna(address):\n        return \"\"\n    tokens = str(address).split()\n    for token in tokens:\n        if any(x in token for x in [\"\", \"\", \"\"]):\n            return token\n    return tokens[0] if tokens else \"\"\n\ndf_clean[\"\"] = df_clean[\"\"].apply(extract_region)\n\n#   \ndef clean_text(text):\n    if pd.isna(text):\n        return \"\"\n    # HTML  \n    text = re.sub(r'<.*?>', ' ', text)\n    #  \n    text = re.sub(r'[*\\-\\n\\t\\r]+', ' ', text)\n    #   \n    text = re.sub(r'\\s+', ' ', text).strip()\n    return text\n\n#   \ntext_cols = [\"\",\"\",\"\",\"\",\"\",\"\",\"\"]\nfor col in text_cols:\n    df_clean[col] = df_clean[col].apply(clean_text)\n\n\n#  \nprint(df_clean.head())\n\n#  CSV  ()\ndf_clean.to_csv(\"1.csv\", index=False)\n\n\n\n\nBased on the provided codebase, identify the key abstractions that are central to understanding this project. \nThese abstractions should represent the core components, modules, or concepts.\n\nDesired output format is a YAML list of objects, where each object has:\n- 'name': A concise name for the abstraction (in korean).\n- 'description': A brief explanation of what this abstraction represents and its role (in korean).\n- 'file_indices': A list of integer file indices that are most relevant to this abstraction. Choose from the file list above.\n\nReturn at most 10 key abstractions.\n\nExample for a different project (simple web server):\n```yaml\n- name: \"HTTP   (HTTP Request Handler)\"\n  description: \" HTTP       . (Component that processes incoming HTTP requests and generates appropriate responses.)\"\n  file_indices: [0, 2]\n- name: \"  (Routing Configuration)\"\n  description: \"URL        . (Defines rules for mapping URL paths to specific request handler functions.)\"\n  file_indices: [1]\n```\n\nYour response should be only the YAML list, enclosed in triple backticks (```yaml ... ```).\nEnsure the output is valid YAML.\n": "```yaml\n- name: \"  (Chatbot System)\"\n  description: \"  ,          .\"\n  file_indices: [0, 14, 15]\n\n- name: \"  (Data Preprocessing)\"\n  description: \"           .\"\n  file_indices: [1, 17]\n\n- name: \"Django  (Django Framework)\"\n  description: \"     ,    Django  .\"\n  file_indices: [2, 4, 5, 7]\n\n- name: \"   (Similarity-based Retrieval)\"\n  description: \"      ChromaDB     .\"\n  file_indices: [15]\n\n- name: \"   (Travel Review Processing)\"\n  description: \"TripAdvisor API     OpenAI     .\"\n  file_indices: [13, 15]\n\n- name: \"ChromaDB     (ChromaDB Connection and Data Storage)\"\n  description: \"ChromaDB          .\"\n  file_indices: [1, 16]\n\n- name: \"OpenAI  (OpenAI Integration)\"\n  description: \"OpenAI API  GPT-3.5-Turbo       .\"\n  file_indices: [13, 15]\n\n- name: \"     (Data Embedding and Model Preparation)\"\n  description: \"SentenceTransformer        .\"\n  file_indices: [1, 15]\n\n- name: \"   HTML  (User Interface and HTML Rendering)\"\n  description: \"     HTML    .\"\n  file_indices: [14, 15]\n\n- name: \"    (Environment Configuration and Secret Key Management)\"\n  description: \"   API ,       .\"\n  file_indices: [4, 13, 15]\n```",
    "\nBased on the following abstractions and relevant code snippets from the project `develop`:\n\nList of Abstraction Indices and Names (Names might be in Korean):\n0 #   (Chatbot System)\n1 #   (Data Preprocessing)\n2 # Django  (Django Framework)\n3 #    (Similarity-based Retrieval)\n4 #    (Travel Review Processing)\n5 # ChromaDB     (ChromaDB Connection and Data Storage)\n6 # OpenAI  (OpenAI Integration)\n7 #      (Data Embedding and Model Preparation)\n8 #    HTML  (User Interface and HTML Rendering)\n9 #     (Environment Configuration and Secret Key Management)\n\nContext (Abstractions, Descriptions, Code):\nIdentified Abstractions:\n- Index 0:   (Chatbot System) (Relevant file indices: [0, 14, 15])\n  Description:   ,          .\n- Index 1:   (Data Preprocessing) (Relevant file indices: [1, 17])\n  Description:            .\n- Index 2: Django  (Django Framework) (Relevant file indices: [2, 4, 5, 7])\n  Description:      ,    Django  .\n- Index 3:    (Similarity-based Retrieval) (Relevant file indices: [15])\n  Description:       ChromaDB     .\n- Index 4:    (Travel Review Processing) (Relevant file indices: [13, 15])\n  Description: TripAdvisor API     OpenAI     .\n- Index 5: ChromaDB     (ChromaDB Connection and Data Storage) (Relevant file indices: [1, 16])\n  Description: ChromaDB          .\n- Index 6: OpenAI  (OpenAI Integration) (Relevant file indices: [13, 15])\n  Description: OpenAI API  GPT-3.5-Turbo       .\n- Index 7:      (Data Embedding and Model Preparation) (Relevant file indices: [1, 15])\n  Description: SentenceTransformer        .\n- Index 8:    HTML  (User Interface and HTML Rendering) (Relevant file indices: [14, 15])\n  Description:      HTML    .\n- Index 9:     (Environment Configuration and Secret Key Management) (Relevant file indices: [4, 13, 15])\n  Description:    API ,       .\n\nRelevant File Snippets (Referenced by Index and Path):\n--- File: 0 # README.md ---\n---\nmarp: true\ntheme: default\npaginate: true\ntitle: SKN10-4rd-4Team \n---\n\n# SKN10-4rd-4Team\n\n## LLM Document Q&A System\n\n---\n\n## 1.  \n\n   LLM  RAG(Retrieval-Augmented Generation)  ,  \n** HTML     ,    +  TripAdvisor      **.\n\n<img src=\"chatbot_ui.png\" alt=\"  \" width=\"750\" style=\"display:block; margin:0 auto;\" />\n\n---\n\n## 2.  \n\n- **:** 4 (SKN10-4rd-4Team)\n\n|  |  |  |  |  |\n|:------:|:------:|:------:|:--------:|:------:|\n| ![](image/.png) | ![](image/.png) | ![](image/.png) | ![](image/.png) | ![](image/.png) |\n\n---\n<img src=\"image/4.drawio.png\" alt=\"4\" width=\"750\" style=\"display:block; margin:0 auto;\" />\n\n## 3.     \n\n### 3.1  \n\n-   :     ,   27000 \n\n-   : TripAdvisor API      \n\n### 3.2   \n\n- .xlsx          (,  )\n\n-         (,  )\n\n-  +        SentenceTransformer \n\n- ChromaDB    , ,   \n\n<img src=\"image/5.png\" alt=\"  5\" width=\"750\" style=\"display:block; margin:0 auto;\" />\n<img src=\"image/6.png\" alt=\"  6\" width=\"750\" style=\"display:block; margin:0 auto;\" />\n\n---\n\n\n\n## 4.  \n\n**  (CSV )**\n\n- : index.html - , ,    UI\n\n- DB: ChromaDB (    )\n\n-  : intfloat/e5-large-v2   \n\n- : Django  views.py\n\n  -   (+)   \n\n  - TripAdvisor API    \n\n  -  +     GPT-3.5-Turbo   \n\n---\n\n## 5.  \n\n- **Django + OpenAI API + TripAdvisor API + ChromaDB**\n- CSV    embedding \n\n- ChromaDB  DB     \n\n- HTML  UI / \n\n- TripAdvisor     +   \n\n\n---\n\n## 6.  \n\n1. **  (HTML)** :  &  &  \n\n2.        \n\n3.   + TripAdvisor   GPT \n\n4.   HTML \n\n---\n\n## 7. \n\n- ****: `index.html`  /  +   UI\n- ****: `views.py`  Django  GPT   \n- ** **: ChromaDB (  )\n- ** **: `xlsx`    CSV     ChromaDB \n\n---\n\n## 8.  \n\n- **  **:        \n- ** UI**:     \n- **LLM  **:       \n- **  **:           \n- **  **:  vectorDB    API   \n\n---\n\n## 8.1 \n<img src=\"image/1.png\" alt=\"  1\" width=\"750\" style=\"display:block; margin:0 auto;\" />\n<img src=\"image/2.png\" alt=\"  2\" width=\"750\" style=\"display:block; margin:0 auto;\" />\n<img src=\"image/3.png\" alt=\"  3\" width=\"750\" style=\"display:block; margin:0 auto;\" />\n<img src=\"image/4.png\" alt=\"  4\" width=\"750\" style=\"display:block; margin:0 auto;\" />\n\n---\n\n## 9.    & \n\n- **** :     ,      ,            .       ,              .\n- **** :  api  dataset  ,\ntourapi   21 api         .\n   .\n,            ,   batch_size     .\n---\n- **** : \n  -    :  Tavily     ,    TripAdvisor   API    3 ,  RAG      .\n  - UI :   ,   ,       .\n  - Git  :            ,   .      .\n- **** :            \n           \n\n\n---\n\n## 10.  \n\n- **** :       ,              .    ,                 .     !\n- **** :   ,        .\n       .\n- **** :   ChatGPT     ,\n        .\n     ,      .\n- **** :                     \n- **** :      .            .          .\n\n--- File: 1 # csvtodb.py ---\nimport pandas as pd\nimport re\nfrom sentence_transformers import SentenceTransformer\nimport chromadb\n\n###    CSV  &    !!\ncsv_file = \"data/.csv\"\n\n\n###   \ndf = pd.read_csv(csv_file)\n\ndf[''] = df[''].fillna('') + \" \" + df[''].fillna('')\n\ndef clean_text(text):\n    if pd.isna(text):\n        return \"\"\n    text = re.sub(r'<.*?>', ' ', text)\n    text = re.sub(r'[*\\-\\n\\t\\r]+', ' ', text)\n    text = re.sub(r'\\s+', ' ', text).strip()\n    return text\n\ndf[''] = df[''].apply(clean_text)\n\n###  e5-large-v2  \nmodel = SentenceTransformer(\"intfloat/e5-large-v2\")\n\ntexts = df[''].tolist()\nembeddings = model.encode(\n    [\"passage: \" + text for text in texts],\n    show_progress_bar=True\n)\n\n###  ChromaDB \nchroma_client = chromadb.PersistentClient(path=\"./chroma_db\")\ncollection = chroma_client.get_or_create_collection(name=\"places\")\n\n###    (  !!)\nfor idx, row in df.iterrows():\n    collection.add(\n        embeddings=[embeddings[idx]],\n        documents=[row['']],\n        metadatas=[{\n            \"name\": row[''],\n            \"region\": row[''],\n            \"description\": row[''],\n            \"category\": row[''],\n            \"open_time\": row[''],\n            \"closed_day\": row[''],\n            \"detail\": row[''],\n            \"location\": row[''],\n        }]\n    )\n\nprint(f\" {csv_file}   & ChromaDB  !\")\nprint(\"  :\", collection.count())\n\n\n--- File: 2 # django_project/django_project/__init__.py ---\n\n\n--- File: 4 # django_project/django_project/settings.py ---\n\"\"\"\nDjango settings for django_project project.\n\nGenerated by 'django-admin startproject' using Django 5.2.1.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/5.2/topics/settings/\n\nFor the full list of settings and their values, see\nhttps://docs.djangoproject.com/en/5.2/ref/settings/\n\"\"\"\n\nfrom pathlib import Path\n\n# Build paths inside the project like this: BASE_DIR / 'subdir'.\nBASE_DIR = Path(__file__).resolve().parent.parent\n\n\n# Quick-start development settings - unsuitable for production\n# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/\n\n# SECURITY WARNING: keep the secret key used in production secret!\nSECRET_KEY = 'django-insecure-c=m)*fg4h!e2hr@s-t6lxz5phdxn*meo6o=a&xg5xm)r#bi!0m'\n\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = True\n\nALLOWED_HOSTS = []\n\n\n# Application definition\n\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    '',\n]\n\nMIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n]\n\nROOT_URLCONF = 'django_project.urls'\n\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [],\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                'django.template.context_processors.request',\n                'django.contrib.auth.context_processors.auth',\n                'django.contrib.messages.context_processors.messages',\n            ],\n        },\n    },\n]\n\nWSGI_APPLICATION = 'django_project.wsgi.application'\n\n\n# Database\n# https://docs.djangoproject.com/en/5.2/ref/settings/#databases\n\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.sqlite3',\n        'NAME': BASE_DIR / 'db.sqlite3',\n    }\n}\n\n\n# Password validation\n# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators\n\nAUTH_PASSWORD_VALIDATORS = [\n    {\n        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',\n    },\n]\n\n\n# Internationalization\n# https://docs.djangoproject.com/en/5.2/topics/i18n/\n\nLANGUAGE_CODE = 'en-us'\n\nTIME_ZONE = 'UTC'\n\nUSE_I18N = True\n\nUSE_TZ = True\n\n\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/5.2/howto/static-files/\n\nSTATIC_URL = 'static/'\n\n# Default primary key field type\n# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field\n\nDEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'\n\n\n--- File: 5 # django_project/django_project/urls.py ---\n\"\"\"\nURL configuration for django_project project.\n\nThe `urlpatterns` list routes URLs to views. For more information please see:\n    https://docs.djangoproject.com/en/5.2/topics/http/urls/\nExamples:\nFunction views\n    1. Add an import:  from my_app import views\n    2. Add a URL to urlpatterns:  path('', views.home, name='home')\nClass-based views\n    1. Add an import:  from other_app.views import Home\n    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')\nIncluding another URLconf\n    1. Import the include() function: from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n\"\"\"\nfrom django.contrib import admin\nfrom django.urls import path, include\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('', include('.urls')),  #  urls \n]\n\n\n\n--- File: 7 # django_project/manage.py ---\n#!/usr/bin/env python\n\"\"\"Django's command-line utility for administrative tasks.\"\"\"\nimport os\nimport sys\n\n\ndef main():\n    \"\"\"Run administrative tasks.\"\"\"\n    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django_project.settings')\n    try:\n        from django.core.management import execute_from_command_line\n    except ImportError as exc:\n        raise ImportError(\n            \"Couldn't import Django. Are you sure it's installed and \"\n            \"available on your PYTHONPATH environment variable? Did you \"\n            \"forget to activate a virtual environment?\"\n        ) from exc\n    execute_from_command_line(sys.argv)\n\n\nif __name__ == '__main__':\n    main()\n\n\n--- File: 13 # django_project//tripadvisor_3_reviews.py ---\nimport requests\nimport openai\nimport os\nfrom typing import List, Optional\nfrom dotenv import load_dotenv\n\n# ======   ======\n#     .env  \nBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nenv_path = os.path.join(BASE_DIR, '..', '.env')\nload_dotenv(dotenv_path=os.path.abspath(env_path))\n\n# ====== 1.   3  ======\ndef fetch_top3_reviews(place_name: str, api_key: str) -> List[str]:\n    BASE_URL = 'https://api.content.tripadvisor.com/api/v1'\n    # 1)  \n    search_url = f\"{BASE_URL}/location/search\"\n    search_params = {'searchQuery': place_name, 'key': api_key, 'language': 'ko', 'category': 'attractions'}\n    search_resp = requests.get(search_url, params=search_params)\n    search_resp.raise_for_status()\n    search_data = search_resp.json()\n    if not search_data.get('data'):\n        raise ValueError(\"No location found for the given place name.\")\n    location_id = search_data['data'][0]['location_id']\n    # 2)  3 \n    review_url = f\"{BASE_URL}/location/{location_id}/reviews\"\n    review_params = {'limit': 3, 'key': api_key}\n    review_resp = requests.get(review_url, params=review_params)\n    review_resp.raise_for_status()\n    review_data = review_resp.json()\n    reviews = [r['text'] for r in review_data.get('data', [])[:3]]\n    if not reviews:\n        raise ValueError(\"No reviews found for the given location.\")\n    return reviews\n\n# ====== 2. OpenAI API  (openai>=1.0.0) ======\ndef summarize_reviews_openai(reviews: List[str], openai_api_key: str, language: str = \"ko\") -> str:\n    client = openai.OpenAI(api_key=openai_api_key)\n    joined = \"\\n\".join(reviews)\n    prompt = (\n        f\"     3.     .\\n\\n\"\n        f\"{joined}\\n\\n\"\n        f\":\"\n    )\n    response = client.chat.completions.create(\n        model=\"gpt-3.5-turbo\",  #  \"gpt-4\"\n        messages=[\n            {\"role\": \"system\", \"content\": \"    .\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ],\n        max_tokens=200,\n        temperature=0.5,\n    )\n    return response.choices[0].message.content.strip()\n\n# ====== 3.   ======\nif __name__ == \"__main__\":\n    # .env API  \n    API_KEY = os.getenv(\"TRIPADVISOR_API_KEY\")\n    print(\"TripAdvisor :\", os.getenv(\"TRIPADVISOR_API_KEY\"))\n    place = \"\"\n\n    if API_KEY and place:\n        try:\n            reviews = fetch_top3_reviews(place, API_KEY)\n        except Exception as e:\n            print(f\"  : {e}\")\n            exit(1)\n\n    print(\"===   3 ===\")\n    for i, r in enumerate(reviews, 1):\n        print(f\"[{i}] {r}\")\n\n    print(\"\\n===    ( ) ===\")\n    joined_reviews = \" \".join(reviews)\n    print(joined_reviews)\n\n--- File: 14 # django_project//urls.py ---\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('', views.chatbot_view, name='chatbot'),\n]\n\n\n--- File: 15 # django_project//views.py ---\nfrom django.shortcuts import render\nfrom sentence_transformers import SentenceTransformer\nimport chromadb\nfrom openai import OpenAI\nimport os\nfrom dotenv import load_dotenv\nfrom django.conf import settings\nfrom .tripadvisor_3_reviews import fetch_top3_reviews, summarize_reviews_openai\n\n#  chroma_db     \nchroma_db_path = os.path.join(settings.BASE_DIR.parent, \"chroma_db2\")\n\nprint(\"   ChromaDB :\", chroma_db_path)\n\n# .env  \nload_dotenv(dotenv_path=os.path.join(settings.BASE_DIR.parent, \".env\"))\n\nclient = OpenAI(\n    api_key=os.getenv(\"OPENAI_API_KEY\")\n)\n\nchroma_client = chromadb.PersistentClient(path=chroma_db_path)\ncollection = chroma_client.get_or_create_collection(name=\"places\")\n\nmodel = SentenceTransformer(\"intfloat/e5-large-v2\")\n\ndef summarize_place_and_reviews(place_name, place_desc, reviews, openai_client):\n    joined_reviews = \"\\n\".join(reviews)\n    prompt = (\n        f\"  '{place_name}'     .\\n\\n\"\n        f\"[ ]\\n{place_desc}\\n\\n\"\n        f\"[]\\n{joined_reviews}\\n\\n\"\n        f\"       .\"\n    )\n    response = openai_client.chat.completions.create(\n        model=\"gpt-3.5-turbo\",\n        messages=[\n            {\"role\": \"system\", \"content\": \"    .\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ],\n        max_tokens=300,\n        temperature=0.5,\n    )\n    return response.choices[0].message.content.strip()\n\ndef is_recommendation_request(question):\n    check_prompt = f\"\"\"\n       '  ' .\n    -  \"true\",  \"false\" .\n    \n     :\n    \"{question}\"\n    \"\"\"\n\n    response = client.chat.completions.create(\n        model=\"gpt-4o\",\n        messages=[{\"role\": \"user\", \"content\": check_prompt}]\n    )\n\n    return \"true\" in response.choices[0].message.content.lower()\n\ndef is_follow_up_question(question, chat_history):\n    history = \"\"\n    for q, a in chat_history[-3:]:  #  3 \n        history += f\": {q}\\n: {a}\\n\"\n\n    check_prompt = f\"\"\"\n         (   )     .\n    - : \"  \", \" ?\", \" ?\"    .\n    -     \"false\",   \"true\" .\n\n     :\n    {history}\n\n     :\n    \"{question}\"\n    \"\"\"\n\n    response = client.chat.completions.create(\n        model=\"gpt-4o\",\n        messages=[{\"role\": \"user\", \"content\": check_prompt}]\n    )\n\n    return \"true\" in response.choices[0].message.content.lower()\n\n\ndef chatbot_view(request):\n    # ChromaDB    \n    all_places = collection.get(include=[\"metadatas\"])\n    all_locations = sorted(set(meta[\"location\"] for meta in all_places[\"metadatas\"] if \"location\" in meta))\n    all_categories = sorted(set(meta[\"category\"] for meta in all_places[\"metadatas\"] if \"category\" in meta))\n\n    answer = \"\"\n    user_question = \"\"\n    location = \"\"\n    category = \"\"\n\n    #       !\n    if not hasattr(request, '_session_initialized'):\n        request.session['chat_history'] = []\n        request._session_initialized = True\n\n    chat_history = request.session.get('chat_history', [])\n\n    typing = False\n\n    if request.method == \"POST\":\n        user_question = request.POST.get(\"question\")\n        location = request.POST.get(\"location\")\n        category = request.POST.get(\"category\")\n\n        print(\" :\", user_question)\n        print(\" :\", location)\n        print(\" :\", category)\n\n        typing = True\n\n        is_recommend = is_recommendation_request(user_question)\n        is_follow_up = is_follow_up_question(user_question, chat_history)\n\n        #     \n        use_last_places = False\n        places_info = \"\"\n        last_info = request.session.get(\"last_places_info\")\n\n        if not is_recommend and is_follow_up and last_info:\n                places_info = last_info\n                use_last_places = True\n                print(\"     !\")\n        else:\n            print(\"    !\")\n            use_last_places = False\n\n        if not use_last_places:\n            print(\"    !\")\n            query_embedding = model.encode([\"query: \" + user_question])\n            filters = {}\n            if category:\n                filters[\"category\"] = category  #     \n\n            results = collection.query(\n                query_embeddings=query_embedding,\n                n_results=20,\n                where=filters\n            )\n\n            documents = results['documents'][0] if results['documents'][0] else []\n            metadatas = results['metadatas'][0] if results['metadatas'][0] else []\n\n            print(\"  :\", len(documents))\n\n            \n            if documents:\n                unique_places = {}\n                for doc, meta in zip(documents, metadatas):\n                    place_name = meta['name']\n                    if place_name not in unique_places:\n                        unique_places[place_name] = (doc, meta)\n\n                selected_places = list(unique_places.items())[:5]\n\n                if len(selected_places) < 3:\n                    answer = \"     .     !\"\n                    chat_history.append((user_question, answer))\n                    request.session['chat_history'] = chat_history\n                    typing = False\n                    return render(request, \"index.html\", {\n                        \"answer\": answer,\n                        \"user_question\": user_question,\n                        \"location\": location,\n                        \"category\": category,\n                        \"chat_history\": chat_history,\n                        \"typing\": typing,\n                        \"location_list\": all_locations,\n                        \"category_list\": all_categories,\n                    })\n\n                for place_name, (doc, meta) in list(unique_places.items())[:5]:\n                    review_text = \"\"\n                    try:\n                        trip_reviews = fetch_top3_reviews(place_name, os.getenv(\"TRIPADVISOR_API_KEY\"))\n                        review_summary = summarize_place_and_reviews(place_name, doc, trip_reviews, client)\n                        review_text = f\" : {review_summary}\"\n                    except Exception as e:\n                        print(f\"   - {place_name}: {e}\")\n                        review_text = f\": {doc}<br>  : (  )\"  #     !\n\n                    places_info += (\n                        f\": {place_name}<br>\"\n                        f\": {meta['category']}<br>\"\n                        f\": {meta['location']}<br>\"\n                        f\"{review_text}<br><br>\"\n                    )\n\n                if is_recommend:\n                    request.session[\"last_places_info\"] = places_info\n                    print(\"         !\")\n            else:\n                answer = \"     .\"\n                chat_history.append((user_question, answer))\n                request.session['chat_history'] = chat_history\n                typing = False\n                return render(request, \"index.html\", {\n                    \"answer\": answer,\n                    \"user_question\": user_question,\n                    \"location\": location,\n                    \"category\": category,\n                    \"chat_history\": chat_history,\n                    \"typing\": typing\n                })\n        else:\n            print(\"     !\")\n            places_info = last_info\n\n        #  GPT  \n        recent_history = chat_history[-5:]\n\n        chat_context = \"\"\n        for past_q, past_a in recent_history:\n            chat_context += f\": {past_q}\\n: {past_a}\\n\"\n\n        prompt_intro = \"\"\n        if use_last_places:\n            prompt_intro = \"\"\"\n                   .\n                 ,\n              **   **  .\n                !\n            \"\"\"\n\n        prompt = f\"\"\"\n              .\n\n             :\n        {chat_context}\n\n           :\n        \"{user_question}\"\n\n        {prompt_intro}\n\n                 .\n               !\n\n          :\n        - : {location}\n        - : {category}\n\n              :\n\n        {places_info}\n\n        ** **:\n        -     !\n        -    3~5!\n        -    !\n        - :  \n        - : \n        - : ,   !\n        -  <br> !\n        -   ,  !\n\n        ** **:\n        -        .\n        -        .\n        -     ,      !\n        \"\"\"\n\n        response = client.chat.completions.create(\n            model=\"gpt-4o\",\n            messages=[{\"role\": \"user\", \"content\": prompt}]\n        )\n\n        print(\"GPT :\", response)\n\n        answer = response.choices[0].message.content\n        answer = answer.replace(\"1.\", \"<br><br> 1.\").replace(\"2.\", \"<br><br> 2.\")\n        answer = answer.replace(\"3.\", \"<br><br> 3.\").replace(\"4.\", \"<br><br> 4.\")\n        answer = answer.replace(\"\\n\\n\", \"<br><br>\").replace(\"\\n\", \"<br>\")\n\n        chat_history.append((user_question, answer))\n        request.session['chat_history'] = chat_history\n\n        typing = False\n\n    return render(request, \"index.html\", {\n        \"answer\": answer,\n        \"user_question\": user_question,\n        \"location\": location,\n        \"category\": category,\n        \"chat_history\": chat_history,\n        \"typing\": typing,\n        \"location_list\": all_locations,\n        \"category_list\": all_categories,\n    })\n\n\n--- File: 16 # inspect_chromadb.py ---\nimport chromadb\n\n###  ChromaDB \nchroma_client = chromadb.PersistentClient(path=\"./chroma_db\")\ncollection = chroma_client.get_or_create_collection(name=\"places\")\n\n###        \nprint(\"  :\", collection.count())\n\n###  ID   ( 1000 )\nresults = collection.get(include=[\"ids\", \"metadatas\"], limit=1000)\n\nids = results[\"ids\"]\nmetadatas = results[\"metadatas\"]\n\nprint(\"\\n===  ID  ===\")\nfor i, id in enumerate(ids):\n    print(f\"{i+1}: {id}\")\n\nprint(\"\\n===   ===\")\nfor i, meta in enumerate(metadatas[:5]):  #  5  \n    print(f\"ID: {ids[i]}\")\n    print(meta)\n    print(\"------\")\n\n\n--- File: 17 # preprocess.py ---\nimport pandas as pd\nimport re\n\n#  XLSX  \nxlsx_file = \"data/dataset.xlsx\"\ndf = pd.read_excel(xlsx_file, sheet_name=0)  #    \n\n#   \nuse_cols = [\"\",\"\",\"\",\"\",\"\",\"\",\"\"]\ndf_clean = df[use_cols].copy()\ndf_clean.rename(columns={\"\": \"\"}, inplace=True)\n#  /   \ndef extract_region(address):\n    if pd.isna(address):\n        return \"\"\n    tokens = str(address).split()\n    for token in tokens:\n        if any(x in token for x in [\"\", \"\", \"\"]):\n            return token\n    return tokens[0] if tokens else \"\"\n\ndf_clean[\"\"] = df_clean[\"\"].apply(extract_region)\n\n#   \ndef clean_text(text):\n    if pd.isna(text):\n        return \"\"\n    # HTML  \n    text = re.sub(r'<.*?>', ' ', text)\n    #  \n    text = re.sub(r'[*\\-\\n\\t\\r]+', ' ', text)\n    #   \n    text = re.sub(r'\\s+', ' ', text).strip()\n    return text\n\n#   \ntext_cols = [\"\",\"\",\"\",\"\",\"\",\"\",\"\"]\nfor col in text_cols:\n    df_clean[col] = df_clean[col].apply(clean_text)\n\n\n#  \nprint(df_clean.head())\n\n#  CSV  ()\ndf_clean.to_csv(\"1.csv\", index=False)\n\n\nIMPORTANT: Generate the `summary` and relationship `label` fields in **Korean** language. Do NOT use English for these fields.\n\nPlease provide:\n1. A high-level `summary` of the project's main purpose and functionality in a few beginner-friendly sentences (in Korean). Use markdown formatting with **bold** and *italic* text to highlight important concepts.\n2. A list (`relationships`) describing the key interactions between these abstractions. For each relationship, specify:\n    - `from_abstraction`: Index of the source abstraction (e.g., `0 # AbstractionName1`)\n    - `to_abstraction`: Index of the target abstraction (e.g., `1 # AbstractionName2`)\n    - `label`: A brief label for the interaction **in just a few words** (in Korean) (e.g., \"Manages\", \"Inherits\", \"Uses\").\n    Ideally the relationship should be backed by one abstraction calling or passing parameters to another.\n    Simplify the relationship and exclude those non-important ones.\n\nIMPORTANT: Make sure EVERY abstraction is involved in at least ONE relationship (either as source or target). Each abstraction index must appear at least once across all relationships.\n\nFormat the output as YAML:\n\n```yaml\nsummary: |\n  A brief, simple explanation of the project (in Korean).\n  Can span multiple lines with **bold** and *italic* for emphasis.\nrelationships:\n  - from_abstraction: 0 # AbstractionName1\n    to_abstraction: 1 # AbstractionName2\n    label: \"Manages\" (in Korean)\n  - from_abstraction: 2 # AbstractionName3\n    to_abstraction: 0 # AbstractionName1\n    label: \"Provides config\" (in Korean)\n  # ... other relationships\n```\n\nNow, provide the YAML output:\n": "```yaml\nsummary: |\n  ** **  LLM  RAG   * HTML       *, \n      TripAdvisor     ** **.   ,    \n         .\n\nrelationships:\n  - from_abstraction: 0 #  \n    to_abstraction: 4 #   \n    label: \"   \"\n  - from_abstraction: 1 #  \n    to_abstraction: 5 # ChromaDB    \n    label: \" \"\n  - from_abstraction: 2 # Django \n    to_abstraction: 0 #  \n    label: \"  \"\n  - from_abstraction: 3 #   \n    to_abstraction: 5 # ChromaDB    \n    label: \" \"\n  - from_abstraction: 6 # OpenAI \n    to_abstraction: 4 #   \n    label: \"  \"\n  - from_abstraction: 7 #     \n    to_abstraction: 5 # ChromaDB    \n    label: \" \"\n  - from_abstraction: 8 #    HTML \n    to_abstraction: 0 #  \n    label: \"  \"\n  - from_abstraction: 9 #    \n    to_abstraction: 2 # Django \n    label: \"  \"\n```",
    "\nGiven the following project abstractions and their relationships for the project ```` develop ````:\n\nAbstractions (Index # Name) (Names might be in Korean):\n- 0 #   (Chatbot System)\n- 1 #   (Data Preprocessing)\n- 2 # Django  (Django Framework)\n- 3 #    (Similarity-based Retrieval)\n- 4 #    (Travel Review Processing)\n- 5 # ChromaDB     (ChromaDB Connection and Data Storage)\n- 6 # OpenAI  (OpenAI Integration)\n- 7 #      (Data Embedding and Model Preparation)\n- 8 #    HTML  (User Interface and HTML Rendering)\n- 9 #     (Environment Configuration and Secret Key Management)\n\nContext about relationships and project summary:\nProject Summary (Note: Project Summary might be in Korean):\n** **  LLM  RAG   * HTML       *, \n    TripAdvisor     ** **.   ,    \n       .\n\n\nRelationships (Indices refer to abstractions above):\n- From 0 (  (Chatbot System)) to 4 (   (Travel Review Processing)):    \n- From 1 (  (Data Preprocessing)) to 5 (ChromaDB     (ChromaDB Connection and Data Storage)):  \n- From 2 (Django  (Django Framework)) to 0 (  (Chatbot System)):   \n- From 3 (   (Similarity-based Retrieval)) to 5 (ChromaDB     (ChromaDB Connection and Data Storage)):  \n- From 6 (OpenAI  (OpenAI Integration)) to 4 (   (Travel Review Processing)):   \n- From 7 (     (Data Embedding and Model Preparation)) to 5 (ChromaDB     (ChromaDB Connection and Data Storage)):  \n- From 8 (   HTML  (User Interface and HTML Rendering)) to 0 (  (Chatbot System)):   \n- From 9 (    (Environment Configuration and Secret Key Management)) to 2 (Django  (Django Framework)):   \n\n\nIf you are going to make a tutorial for ```` develop ````, what is the best order to explain these abstractions, from first to last?\nIdeally, first explain those that are the most important or foundational, perhaps user-facing concepts or entry points. Then move to more detailed, lower-level implementation details or supporting concepts.\n\nOutput the ordered list of abstraction indices, including the name in a comment for clarity. Use the format `idx # AbstractionName`.\n\n```yaml\n- 2 # FoundationalConcept\n- 0 # CoreClassA\n- 1 # CoreClassB (uses CoreClassA)\n- ...\n```\n\nNow, provide the YAML output:\n": "```yaml\n- 2 # Django  (Django Framework)\n- 8 #    HTML  (User Interface and HTML Rendering)\n- 0 #   (Chatbot System)\n- 9 #     (Environment Configuration and Secret Key Management)\n- 1 #   (Data Preprocessing)\n- 5 # ChromaDB     (ChromaDB Connection and Data Storage)\n- 7 #      (Data Embedding and Model Preparation)\n- 3 #    (Similarity-based Retrieval)\n- 4 #    (Travel Review Processing)\n- 6 # OpenAI  (OpenAI Integration)\n```",
    "\nIMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.\n\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `develop` about the concept: \"Django  (Django Framework)\". This is Chapter 1.\n\nConcept Details (Note: Provided in Korean):\n- Name: Django  (Django Framework)\n- Description:\n     ,    Django  .\n\nComplete Tutorial Structure (Note: Chapter names might be in Korean):\n1. [Django  (Django Framework)](01_django___django_framework_.md)\n2. [   HTML  (User Interface and HTML Rendering)](02____html___user_interface_and_html_rendering_.md)\n3. [  (Chatbot System)](03____chatbot_system_.md)\n4. [    (Environment Configuration and Secret Key Management)](04______environment_configuration_and_secret_key_management_.md)\n5. [  (Data Preprocessing)](05____data_preprocessing_.md)\n6. [ChromaDB     (ChromaDB Connection and Data Storage)](06_chromadb______chromadb_connection_and_data_storage_.md)\n7. [     (Data Embedding and Model Preparation)](07_______data_embedding_and_model_preparation_.md)\n8. [   (Similarity-based Retrieval)](08_____similarity_based_retrieval_.md)\n9. [   (Travel Review Processing)](09_____travel_review_processing_.md)\n10. [OpenAI  (OpenAI Integration)](10_openai___openai_integration_.md)\n\nContext from previous chapters (Note: This summary might be in Korean):\nThis is the first chapter.\n\nRelevant Code Snippets (Code itself remains unchanged):\nNo specific code snippets provided for this abstraction.\n\nInstructions for the chapter (Generate content in Korean unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 1: Django  (Django Framework)`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).\n\n- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).\n\n- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).\n\n- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).\n\n- Heavily use analogies and examples throughout (in Korean) to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 1: Django  (Django Framework)\n\n##   \n\n              .  ,         .  , ,          .           .\n\nDjango       .    ,  ,             .\n\n## Django  \n\n   Django     .  Django    :\n\n### 1. MTV \nDjango **MTV (Model, Template, View)**  .\n- **Model ()**:       .\n- **Template ()**:     .\n- **View ()**:        .\n\n### 2. URL \nDjango URL       .    URL   , Django     .\n\n### 3.  \nDjango ORM(Object-Relational Mapping)    .      .\n\n## Django   \n\nDjango    ,  \"Hello, World!\"   .\n\n###  \n\n, Django  ,  .\n\n```bash\ndjango-admin startproject myproject\ncd myproject\npython manage.py startapp myapp\n```\n\n, URL  .\n\n**urls.py**  :\n```python\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('', views.hello_world, name='hello_world'),\n]\n```\n\n**views.py**  :\n```python\nfrom django.http import HttpResponse\n\ndef hello_world(request):\n    return HttpResponse(\"Hello, World!\")\n```\n\n#### \n    Django   .   URL  ,  URL  **hello_world**   . , `hello_world()`   \"Hello, World!\"  .\n\n##   \n\nDjango         .  URL     :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    \n     ->> : HTTP  (URL)\n     ->> Django: URL    \n    Django ->> :   \n     ->> : HTTP  ( )\n```\n\n###    \n\nDjango  **settings.py**  , **urls.py**  . `manage.py`    ,   .\n\n**settings.py**     :\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    ...\n    'myapp',  #    \n]\n```\n\n  Django     .\n\n## \n\n  Django      . Django         .   [   HTML ](02____html___user_interface_and_html_rendering_.md)  .",
    "\nIMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.\n\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `develop` about the concept: \"   HTML  (User Interface and HTML Rendering)\". This is Chapter 2.\n\nConcept Details (Note: Provided in Korean):\n- Name:    HTML  (User Interface and HTML Rendering)\n- Description:\n     HTML    .\n\nComplete Tutorial Structure (Note: Chapter names might be in Korean):\n1. [Django  (Django Framework)](01_django___django_framework_.md)\n2. [   HTML  (User Interface and HTML Rendering)](02____html___user_interface_and_html_rendering_.md)\n3. [  (Chatbot System)](03____chatbot_system_.md)\n4. [    (Environment Configuration and Secret Key Management)](04______environment_configuration_and_secret_key_management_.md)\n5. [  (Data Preprocessing)](05____data_preprocessing_.md)\n6. [ChromaDB     (ChromaDB Connection and Data Storage)](06_chromadb______chromadb_connection_and_data_storage_.md)\n7. [     (Data Embedding and Model Preparation)](07_______data_embedding_and_model_preparation_.md)\n8. [   (Similarity-based Retrieval)](08_____similarity_based_retrieval_.md)\n9. [   (Travel Review Processing)](09_____travel_review_processing_.md)\n10. [OpenAI  (OpenAI Integration)](10_openai___openai_integration_.md)\n\nContext from previous chapters (Note: This summary might be in Korean):\n# Chapter 1: Django  (Django Framework)\n\n##   \n\n              .  ,         .  , ,          .           .\n\nDjango       .    ,  ,             .\n\n## Django  \n\n   Django     .  Django    :\n\n### 1. MTV \nDjango **MTV (Model, Template, View)**  .\n- **Model ()**:       .\n- **Template ()**:     .\n- **View ()**:        .\n\n### 2. URL \nDjango URL       .    URL   , Django     .\n\n### 3.  \nDjango ORM(Object-Relational Mapping)    .      .\n\n## Django   \n\nDjango    ,  \"Hello, World!\"   .\n\n###  \n\n, Django  ,  .\n\n```bash\ndjango-admin startproject myproject\ncd myproject\npython manage.py startapp myapp\n```\n\n, URL  .\n\n**urls.py**  :\n```python\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('', views.hello_world, name='hello_world'),\n]\n```\n\n**views.py**  :\n```python\nfrom django.http import HttpResponse\n\ndef hello_world(request):\n    return HttpResponse(\"Hello, World!\")\n```\n\n#### \n    Django   .   URL  ,  URL  **hello_world**   . , `hello_world()`   \"Hello, World!\"  .\n\n##   \n\nDjango         .  URL     :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    \n     ->> : HTTP  (URL)\n     ->> Django: URL    \n    Django ->> :   \n     ->> : HTTP  ( )\n```\n\n###    \n\nDjango  **settings.py**  , **urls.py**  . `manage.py`    ,   .\n\n**settings.py**     :\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    ...\n    'myapp',  #    \n]\n```\n\n  Django     .\n\n## \n\n  Django      . Django         .   [   HTML ](02____html___user_interface_and_html_rendering_.md)  .\n\nRelevant Code Snippets (Code itself remains unchanged):\nNo specific code snippets provided for this abstraction.\n\nInstructions for the chapter (Generate content in Korean unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 2:    HTML  (User Interface and HTML Rendering)`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).\n\n- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).\n\n- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).\n\n- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).\n\n- Heavily use analogies and examples throughout (in Korean) to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 2:    HTML  (User Interface and HTML Rendering)\n\n  [Django ](01_django___django_framework_.md)  .       \"   HTML \"  .\n\n##    \n\n        UI ( ).  ,    ,          UI      .    HTML  ,      . \n\nHTML           .         .\n\n##  \n\n### 1.  \n\nDjango HTML      .    ,         .\n\n```html\n<!-- : templates/hello.html -->\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n    <h1>, {{ username }}!</h1>\n</body>\n</html>\n```\n\n#### \n `{{ username }}`   `views.py`   `username`  . \n\n### 2.   \n\n           .\n\n```python\n# views.py\nfrom django.shortcuts import render\n\ndef greet_user(request):\n    user_name = \"\"  #   \n    return render(request, 'hello.html', {'username': user_name})\n```\n\n#### \n  `render()`   `hello.html`    .     `{{ username }}` \"\" .\n\n##   \n\n Django    .       :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    participant HTML\n\n     ->> : HTTP \n     ->> Django:  \n    Django ->> :    \n     ->> HTML: HTML   \n    HTML ->> : HTTP  ( )\n```\n\n###    \n\nDjango          HTML .\n\n**settings.py**   :\n```python\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [os.path.join(BASE_DIR, 'templates')],  #     \n        ...\n    },\n]\n```\n\n  Django      . `BASE_DIR`    .\n\n## \n\n  HTML      Django      HTML  .   [ ](03____chatbot_system_.md)        .",
    "\nIMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.\n\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `develop` about the concept: \"  (Chatbot System)\". This is Chapter 3.\n\nConcept Details (Note: Provided in Korean):\n- Name:   (Chatbot System)\n- Description:\n  ,          .\n\nComplete Tutorial Structure (Note: Chapter names might be in Korean):\n1. [Django  (Django Framework)](01_django___django_framework_.md)\n2. [   HTML  (User Interface and HTML Rendering)](02____html___user_interface_and_html_rendering_.md)\n3. [  (Chatbot System)](03____chatbot_system_.md)\n4. [    (Environment Configuration and Secret Key Management)](04______environment_configuration_and_secret_key_management_.md)\n5. [  (Data Preprocessing)](05____data_preprocessing_.md)\n6. [ChromaDB     (ChromaDB Connection and Data Storage)](06_chromadb______chromadb_connection_and_data_storage_.md)\n7. [     (Data Embedding and Model Preparation)](07_______data_embedding_and_model_preparation_.md)\n8. [   (Similarity-based Retrieval)](08_____similarity_based_retrieval_.md)\n9. [   (Travel Review Processing)](09_____travel_review_processing_.md)\n10. [OpenAI  (OpenAI Integration)](10_openai___openai_integration_.md)\n\nContext from previous chapters (Note: This summary might be in Korean):\n# Chapter 1: Django  (Django Framework)\n\n##   \n\n              .  ,         .  , ,          .           .\n\nDjango       .    ,  ,             .\n\n## Django  \n\n   Django     .  Django    :\n\n### 1. MTV \nDjango **MTV (Model, Template, View)**  .\n- **Model ()**:       .\n- **Template ()**:     .\n- **View ()**:        .\n\n### 2. URL \nDjango URL       .    URL   , Django     .\n\n### 3.  \nDjango ORM(Object-Relational Mapping)    .      .\n\n## Django   \n\nDjango    ,  \"Hello, World!\"   .\n\n###  \n\n, Django  ,  .\n\n```bash\ndjango-admin startproject myproject\ncd myproject\npython manage.py startapp myapp\n```\n\n, URL  .\n\n**urls.py**  :\n```python\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('', views.hello_world, name='hello_world'),\n]\n```\n\n**views.py**  :\n```python\nfrom django.http import HttpResponse\n\ndef hello_world(request):\n    return HttpResponse(\"Hello, World!\")\n```\n\n#### \n    Django   .   URL  ,  URL  **hello_world**   . , `hello_world()`   \"Hello, World!\"  .\n\n##   \n\nDjango         .  URL     :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    \n     ->> : HTTP  (URL)\n     ->> Django: URL    \n    Django ->> :   \n     ->> : HTTP  ( )\n```\n\n###    \n\nDjango  **settings.py**  , **urls.py**  . `manage.py`    ,   .\n\n**settings.py**     :\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    ...\n    'myapp',  #    \n]\n```\n\n  Django     .\n\n## \n\n  Django      . Django         .   [   HTML ](02____html___user_interface_and_html_rendering_.md)  .\n---\n# Chapter 2:    HTML  (User Interface and HTML Rendering)\n\n  [Django ](01_django___django_framework_.md)  .       \"   HTML \"  .\n\n##    \n\n        UI ( ).  ,    ,          UI      .    HTML  ,      . \n\nHTML           .         .\n\n##  \n\n### 1.  \n\nDjango HTML      .    ,         .\n\n```html\n<!-- : templates/hello.html -->\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n    <h1>, {{ username }}!</h1>\n</body>\n</html>\n```\n\n#### \n `{{ username }}`   `views.py`   `username`  . \n\n### 2.   \n\n           .\n\n```python\n# views.py\nfrom django.shortcuts import render\n\ndef greet_user(request):\n    user_name = \"\"  #   \n    return render(request, 'hello.html', {'username': user_name})\n```\n\n#### \n  `render()`   `hello.html`    .     `{{ username }}` \"\" .\n\n##   \n\n Django    .       :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    participant HTML\n\n     ->> : HTTP \n     ->> Django:  \n    Django ->> :    \n     ->> HTML: HTML   \n    HTML ->> : HTTP  ( )\n```\n\n###    \n\nDjango          HTML .\n\n**settings.py**   :\n```python\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [os.path.join(BASE_DIR, 'templates')],  #     \n        ...\n    },\n]\n```\n\n  Django      . `BASE_DIR`    .\n\n## \n\n  HTML      Django      HTML  .   [ ](03____chatbot_system_.md)        .\n\nRelevant Code Snippets (Code itself remains unchanged):\nNo specific code snippets provided for this abstraction.\n\nInstructions for the chapter (Generate content in Korean unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 3:   (Chatbot System)`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).\n\n- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).\n\n- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).\n\n- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).\n\n- Heavily use analogies and examples throughout (in Korean) to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 3:   (Chatbot System)\n\n  [   HTML ](02____html___user_interface_and_html_rendering_.md)  .       ** **        .\n\n##    \n\n       .  ,       .        ,        .\n\n        .\n\n##  \n\n### 1.   \n\n      .       .\n\n```python\n# views.py\ndef get_user_input(request):\n    user_input = request.POST.get('message')\n    return user_input\n```\n\n#### \n  `request.POST.get('message')`    .\n\n### 2.    \n\n        .\n\n```python\n# examples.py\ndef recommend_place(user_input):\n    #    \n    if \"\" in user_input:\n        return \"\"\n    elif \"\" in user_input:\n        return \"\"\n    else:\n        return \"\"\n```\n\n#### \n   \"\"   , \"\"   .     .\n\n##   \n\n     . \n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    participant \n\n     ->> : ' '\n     ->> Django:  \n    Django ->> :  \n     ->> :  \n     ->> : ''\n```\n\n###   \n\n      .\n\n```python\n# views.py\nfrom django.shortcuts import render\nfrom .examples import recommend_place\n\ndef chat_response(request):\n    user_input = request.POST.get('message')\n    place = recommend_place(user_input)\n    return render(request, 'chat.html', {'response': place})\n```\n\n#### \n `chat_response`    , `recommend_place`       .\n\n**settings.py POST   **\n```python\nMIDDLEWARE = [\n    ...\n    'django.middleware.csrf.CsrfViewMiddleware',  # CSRF  \n    ...\n]\n```\n\n   POST     .\n\n## \n\n           .           .   [   ](04______environment_configuration_and_secret_key_management_.md)       .",
    "\nIMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.\n\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `develop` about the concept: \"    (Environment Configuration and Secret Key Management)\". This is Chapter 4.\n\nConcept Details (Note: Provided in Korean):\n- Name:     (Environment Configuration and Secret Key Management)\n- Description:\n   API ,       .\n\nComplete Tutorial Structure (Note: Chapter names might be in Korean):\n1. [Django  (Django Framework)](01_django___django_framework_.md)\n2. [   HTML  (User Interface and HTML Rendering)](02____html___user_interface_and_html_rendering_.md)\n3. [  (Chatbot System)](03____chatbot_system_.md)\n4. [    (Environment Configuration and Secret Key Management)](04______environment_configuration_and_secret_key_management_.md)\n5. [  (Data Preprocessing)](05____data_preprocessing_.md)\n6. [ChromaDB     (ChromaDB Connection and Data Storage)](06_chromadb______chromadb_connection_and_data_storage_.md)\n7. [     (Data Embedding and Model Preparation)](07_______data_embedding_and_model_preparation_.md)\n8. [   (Similarity-based Retrieval)](08_____similarity_based_retrieval_.md)\n9. [   (Travel Review Processing)](09_____travel_review_processing_.md)\n10. [OpenAI  (OpenAI Integration)](10_openai___openai_integration_.md)\n\nContext from previous chapters (Note: This summary might be in Korean):\n# Chapter 1: Django  (Django Framework)\n\n##   \n\n              .  ,         .  , ,          .           .\n\nDjango       .    ,  ,             .\n\n## Django  \n\n   Django     .  Django    :\n\n### 1. MTV \nDjango **MTV (Model, Template, View)**  .\n- **Model ()**:       .\n- **Template ()**:     .\n- **View ()**:        .\n\n### 2. URL \nDjango URL       .    URL   , Django     .\n\n### 3.  \nDjango ORM(Object-Relational Mapping)    .      .\n\n## Django   \n\nDjango    ,  \"Hello, World!\"   .\n\n###  \n\n, Django  ,  .\n\n```bash\ndjango-admin startproject myproject\ncd myproject\npython manage.py startapp myapp\n```\n\n, URL  .\n\n**urls.py**  :\n```python\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('', views.hello_world, name='hello_world'),\n]\n```\n\n**views.py**  :\n```python\nfrom django.http import HttpResponse\n\ndef hello_world(request):\n    return HttpResponse(\"Hello, World!\")\n```\n\n#### \n    Django   .   URL  ,  URL  **hello_world**   . , `hello_world()`   \"Hello, World!\"  .\n\n##   \n\nDjango         .  URL     :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    \n     ->> : HTTP  (URL)\n     ->> Django: URL    \n    Django ->> :   \n     ->> : HTTP  ( )\n```\n\n###    \n\nDjango  **settings.py**  , **urls.py**  . `manage.py`    ,   .\n\n**settings.py**     :\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    ...\n    'myapp',  #    \n]\n```\n\n  Django     .\n\n## \n\n  Django      . Django         .   [   HTML ](02____html___user_interface_and_html_rendering_.md)  .\n---\n# Chapter 2:    HTML  (User Interface and HTML Rendering)\n\n  [Django ](01_django___django_framework_.md)  .       \"   HTML \"  .\n\n##    \n\n        UI ( ).  ,    ,          UI      .    HTML  ,      . \n\nHTML           .         .\n\n##  \n\n### 1.  \n\nDjango HTML      .    ,         .\n\n```html\n<!-- : templates/hello.html -->\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n    <h1>, {{ username }}!</h1>\n</body>\n</html>\n```\n\n#### \n `{{ username }}`   `views.py`   `username`  . \n\n### 2.   \n\n           .\n\n```python\n# views.py\nfrom django.shortcuts import render\n\ndef greet_user(request):\n    user_name = \"\"  #   \n    return render(request, 'hello.html', {'username': user_name})\n```\n\n#### \n  `render()`   `hello.html`    .     `{{ username }}` \"\" .\n\n##   \n\n Django    .       :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    participant HTML\n\n     ->> : HTTP \n     ->> Django:  \n    Django ->> :    \n     ->> HTML: HTML   \n    HTML ->> : HTTP  ( )\n```\n\n###    \n\nDjango          HTML .\n\n**settings.py**   :\n```python\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [os.path.join(BASE_DIR, 'templates')],  #     \n        ...\n    },\n]\n```\n\n  Django      . `BASE_DIR`    .\n\n## \n\n  HTML      Django      HTML  .   [ ](03____chatbot_system_.md)        .\n---\n# Chapter 3:   (Chatbot System)\n\n  [   HTML ](02____html___user_interface_and_html_rendering_.md)  .       ** **        .\n\n##    \n\n       .  ,       .        ,        .\n\n        .\n\n##  \n\n### 1.   \n\n      .       .\n\n```python\n# views.py\ndef get_user_input(request):\n    user_input = request.POST.get('message')\n    return user_input\n```\n\n#### \n  `request.POST.get('message')`    .\n\n### 2.    \n\n        .\n\n```python\n# examples.py\ndef recommend_place(user_input):\n    #    \n    if \"\" in user_input:\n        return \"\"\n    elif \"\" in user_input:\n        return \"\"\n    else:\n        return \"\"\n```\n\n#### \n   \"\"   , \"\"   .     .\n\n##   \n\n     . \n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    participant \n\n     ->> : ' '\n     ->> Django:  \n    Django ->> :  \n     ->> :  \n     ->> : ''\n```\n\n###   \n\n      .\n\n```python\n# views.py\nfrom django.shortcuts import render\nfrom .examples import recommend_place\n\ndef chat_response(request):\n    user_input = request.POST.get('message')\n    place = recommend_place(user_input)\n    return render(request, 'chat.html', {'response': place})\n```\n\n#### \n `chat_response`    , `recommend_place`       .\n\n**settings.py POST   **\n```python\nMIDDLEWARE = [\n    ...\n    'django.middleware.csrf.CsrfViewMiddleware',  # CSRF  \n    ...\n]\n```\n\n   POST     .\n\n## \n\n           .           .   [   ](04______environment_configuration_and_secret_key_management_.md)       .\n\nRelevant Code Snippets (Code itself remains unchanged):\nNo specific code snippets provided for this abstraction.\n\nInstructions for the chapter (Generate content in Korean unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 4:     (Environment Configuration and Secret Key Management)`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).\n\n- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).\n\n- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).\n\n- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).\n\n- Heavily use analogies and examples throughout (in Korean) to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 4:     (Environment Configuration and Secret Key Management)\n\n  [ ](03____chatbot_system_.md)   .          .        .\n\n##    \n\n   ,    API       .  ,  API   API  .    3    .           .\n\n##  \n\n### 1.   \n\n       ,       .         .\n\n```python\n# settings.py\nimport os\n\nDATABASE_URL = os.getenv('DATABASE_URL')\nSECRET_KEY = os.getenv('SECRET_KEY')\n```\n\n#### \n `os.getenv()`      . `DATABASE_URL` `SECRET_KEY`      .\n\n### 2. `.env`   \n\n    `.env`    .     ,     .\n\n```\n# .env \nDATABASE_URL=your_database_url_here\nSECRET_KEY=your_secret_key_here\n```\n\n#### \n`.env`      ,      .\n\n### 3. Python  \n\n`python-dotenv`   `.env`      .\n\n```bash\npip install python-dotenv\n```\n\n```python\n# manage.py  wsgi.py\nfrom dotenv import load_dotenv\nload_dotenv()\n```\n\n#### \n`load_dotenv()`   `.env`  ,      .\n\n##   \n\n           :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant dotenv\n    participant \n    participant \n\n     ->> :   \n     ->> dotenv: `.env`  \n    dotenv ->> :   \n     ->> :   \n```\n\n###   \n\n      `.env`       .\n\n```python\n# views.py\nimport os\n\ndef get_secret_key():\n    secret_key = os.getenv('SECRET_KEY')\n    if not secret_key:\n        raise ValueError(\"SECRET_KEY  .\")\n    return secret_key\n```\n\n#### \n  `os.getenv()`     `SECRET_KEY` .       .\n\n**settings.py    **\n```python\nDEBUG = os.getenv('DEBUG', 'False') == 'True'  #   \n```\n\n     ,          .\n\n## \n\n      ,         .               .\n\n  [ ](05____data_preprocessing_.md)  .        .",
    "\nIMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.\n\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `develop` about the concept: \"  (Data Preprocessing)\". This is Chapter 5.\n\nConcept Details (Note: Provided in Korean):\n- Name:   (Data Preprocessing)\n- Description:\n           .\n\nComplete Tutorial Structure (Note: Chapter names might be in Korean):\n1. [Django  (Django Framework)](01_django___django_framework_.md)\n2. [   HTML  (User Interface and HTML Rendering)](02____html___user_interface_and_html_rendering_.md)\n3. [  (Chatbot System)](03____chatbot_system_.md)\n4. [    (Environment Configuration and Secret Key Management)](04______environment_configuration_and_secret_key_management_.md)\n5. [  (Data Preprocessing)](05____data_preprocessing_.md)\n6. [ChromaDB     (ChromaDB Connection and Data Storage)](06_chromadb______chromadb_connection_and_data_storage_.md)\n7. [     (Data Embedding and Model Preparation)](07_______data_embedding_and_model_preparation_.md)\n8. [   (Similarity-based Retrieval)](08_____similarity_based_retrieval_.md)\n9. [   (Travel Review Processing)](09_____travel_review_processing_.md)\n10. [OpenAI  (OpenAI Integration)](10_openai___openai_integration_.md)\n\nContext from previous chapters (Note: This summary might be in Korean):\n# Chapter 1: Django  (Django Framework)\n\n##   \n\n              .  ,         .  , ,          .           .\n\nDjango       .    ,  ,             .\n\n## Django  \n\n   Django     .  Django    :\n\n### 1. MTV \nDjango **MTV (Model, Template, View)**  .\n- **Model ()**:       .\n- **Template ()**:     .\n- **View ()**:        .\n\n### 2. URL \nDjango URL       .    URL   , Django     .\n\n### 3.  \nDjango ORM(Object-Relational Mapping)    .      .\n\n## Django   \n\nDjango    ,  \"Hello, World!\"   .\n\n###  \n\n, Django  ,  .\n\n```bash\ndjango-admin startproject myproject\ncd myproject\npython manage.py startapp myapp\n```\n\n, URL  .\n\n**urls.py**  :\n```python\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('', views.hello_world, name='hello_world'),\n]\n```\n\n**views.py**  :\n```python\nfrom django.http import HttpResponse\n\ndef hello_world(request):\n    return HttpResponse(\"Hello, World!\")\n```\n\n#### \n    Django   .   URL  ,  URL  **hello_world**   . , `hello_world()`   \"Hello, World!\"  .\n\n##   \n\nDjango         .  URL     :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    \n     ->> : HTTP  (URL)\n     ->> Django: URL    \n    Django ->> :   \n     ->> : HTTP  ( )\n```\n\n###    \n\nDjango  **settings.py**  , **urls.py**  . `manage.py`    ,   .\n\n**settings.py**     :\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    ...\n    'myapp',  #    \n]\n```\n\n  Django     .\n\n## \n\n  Django      . Django         .   [   HTML ](02____html___user_interface_and_html_rendering_.md)  .\n---\n# Chapter 2:    HTML  (User Interface and HTML Rendering)\n\n  [Django ](01_django___django_framework_.md)  .       \"   HTML \"  .\n\n##    \n\n        UI ( ).  ,    ,          UI      .    HTML  ,      . \n\nHTML           .         .\n\n##  \n\n### 1.  \n\nDjango HTML      .    ,         .\n\n```html\n<!-- : templates/hello.html -->\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n    <h1>, {{ username }}!</h1>\n</body>\n</html>\n```\n\n#### \n `{{ username }}`   `views.py`   `username`  . \n\n### 2.   \n\n           .\n\n```python\n# views.py\nfrom django.shortcuts import render\n\ndef greet_user(request):\n    user_name = \"\"  #   \n    return render(request, 'hello.html', {'username': user_name})\n```\n\n#### \n  `render()`   `hello.html`    .     `{{ username }}` \"\" .\n\n##   \n\n Django    .       :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    participant HTML\n\n     ->> : HTTP \n     ->> Django:  \n    Django ->> :    \n     ->> HTML: HTML   \n    HTML ->> : HTTP  ( )\n```\n\n###    \n\nDjango          HTML .\n\n**settings.py**   :\n```python\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [os.path.join(BASE_DIR, 'templates')],  #     \n        ...\n    },\n]\n```\n\n  Django      . `BASE_DIR`    .\n\n## \n\n  HTML      Django      HTML  .   [ ](03____chatbot_system_.md)        .\n---\n# Chapter 3:   (Chatbot System)\n\n  [   HTML ](02____html___user_interface_and_html_rendering_.md)  .       ** **        .\n\n##    \n\n       .  ,       .        ,        .\n\n        .\n\n##  \n\n### 1.   \n\n      .       .\n\n```python\n# views.py\ndef get_user_input(request):\n    user_input = request.POST.get('message')\n    return user_input\n```\n\n#### \n  `request.POST.get('message')`    .\n\n### 2.    \n\n        .\n\n```python\n# examples.py\ndef recommend_place(user_input):\n    #    \n    if \"\" in user_input:\n        return \"\"\n    elif \"\" in user_input:\n        return \"\"\n    else:\n        return \"\"\n```\n\n#### \n   \"\"   , \"\"   .     .\n\n##   \n\n     . \n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    participant \n\n     ->> : ' '\n     ->> Django:  \n    Django ->> :  \n     ->> :  \n     ->> : ''\n```\n\n###   \n\n      .\n\n```python\n# views.py\nfrom django.shortcuts import render\nfrom .examples import recommend_place\n\ndef chat_response(request):\n    user_input = request.POST.get('message')\n    place = recommend_place(user_input)\n    return render(request, 'chat.html', {'response': place})\n```\n\n#### \n `chat_response`    , `recommend_place`       .\n\n**settings.py POST   **\n```python\nMIDDLEWARE = [\n    ...\n    'django.middleware.csrf.CsrfViewMiddleware',  # CSRF  \n    ...\n]\n```\n\n   POST     .\n\n## \n\n           .           .   [   ](04______environment_configuration_and_secret_key_management_.md)       .\n---\n# Chapter 4:     (Environment Configuration and Secret Key Management)\n\n  [ ](03____chatbot_system_.md)   .          .        .\n\n##    \n\n   ,    API       .  ,  API   API  .    3    .           .\n\n##  \n\n### 1.   \n\n       ,       .         .\n\n```python\n# settings.py\nimport os\n\nDATABASE_URL = os.getenv('DATABASE_URL')\nSECRET_KEY = os.getenv('SECRET_KEY')\n```\n\n#### \n `os.getenv()`      . `DATABASE_URL` `SECRET_KEY`      .\n\n### 2. `.env`   \n\n    `.env`    .     ,     .\n\n```\n# .env \nDATABASE_URL=your_database_url_here\nSECRET_KEY=your_secret_key_here\n```\n\n#### \n`.env`      ,      .\n\n### 3. Python  \n\n`python-dotenv`   `.env`      .\n\n```bash\npip install python-dotenv\n```\n\n```python\n# manage.py  wsgi.py\nfrom dotenv import load_dotenv\nload_dotenv()\n```\n\n#### \n`load_dotenv()`   `.env`  ,      .\n\n##   \n\n           :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant dotenv\n    participant \n    participant \n\n     ->> :   \n     ->> dotenv: `.env`  \n    dotenv ->> :   \n     ->> :   \n```\n\n###   \n\n      `.env`       .\n\n```python\n# views.py\nimport os\n\ndef get_secret_key():\n    secret_key = os.getenv('SECRET_KEY')\n    if not secret_key:\n        raise ValueError(\"SECRET_KEY  .\")\n    return secret_key\n```\n\n#### \n  `os.getenv()`     `SECRET_KEY` .       .\n\n**settings.py    **\n```python\nDEBUG = os.getenv('DEBUG', 'False') == 'True'  #   \n```\n\n     ,          .\n\n## \n\n      ,         .               .\n\n  [ ](05____data_preprocessing_.md)  .        .\n\nRelevant Code Snippets (Code itself remains unchanged):\nNo specific code snippets provided for this abstraction.\n\nInstructions for the chapter (Generate content in Korean unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 5:   (Data Preprocessing)`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).\n\n- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).\n\n- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).\n\n- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).\n\n- Heavily use analogies and examples throughout (in Korean) to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 5:   (Data Preprocessing)\n\n  [   ](04______environment_configuration_and_secret_key_management_.md)  .            .\n\n##    \n\n           .  ,       .       .                .\n\n##  \n\n### 1.  \n\n      .  ,      .\n\n```python\n#  \nimport pandas as pd\n\ndata = {'': ['', None, ''], '': [23, None, 30]}\ndf = pd.DataFrame(data)\ndf = df.dropna()  #    \n```\n\n#### \n      . `dropna()`      .\n\n### 2.  \n\n     ,    . \n\n```python\n#   \nimport numpy as np\n\nages = [23, 25, 22, 400, 21]\nages = [age if age < 120 else np.median(ages) for age in ages]  # 400  \n```\n\n#### \n  400    .\n\n### 3.  \n\n       .       .\n\n```python\n#  \nfrom sklearn.preprocessing import MinMaxScaler\n\nscaler = MinMaxScaler()\nnormalized_data = scaler.fit_transform([[25], [30], [45]])\n```\n\n#### \n 0 1   .         .\n\n##   \n\n         :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant \n    participant \n    participant \n\n     ->> : / \n     ->> :   \n     ->> :  \n     ->> :    \n```\n\n###   \n\n       .\n\n```python\n# data_preprocessing.py\nimport pandas as pd\nfrom sklearn.preprocessing import MinMaxScaler\n\ndef preprocess_data(data):\n    df = pd.DataFrame(data)\n    df = df.dropna()  #  \n    ages = df['age'].tolist()\n    median_age = np.median(ages)\n    df['age'] = [age if age < 120 else median_age for age in ages]  #  \n\n    scaler = MinMaxScaler()\n    df[['age_normalized']] = scaler.fit_transform(df[['age']])\n    return df\n```\n\n#### \n`preprocess_data`     ,  ,  .\n\n## \n\n        .        ,        .\n\n  [ChromaDB    ](06_chromadb______chromadb_connection_and_data_storage_.md)   .          .",
    "\nIMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.\n\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `develop` about the concept: \"ChromaDB     (ChromaDB Connection and Data Storage)\". This is Chapter 6.\n\nConcept Details (Note: Provided in Korean):\n- Name: ChromaDB     (ChromaDB Connection and Data Storage)\n- Description:\nChromaDB          .\n\nComplete Tutorial Structure (Note: Chapter names might be in Korean):\n1. [Django  (Django Framework)](01_django___django_framework_.md)\n2. [   HTML  (User Interface and HTML Rendering)](02____html___user_interface_and_html_rendering_.md)\n3. [  (Chatbot System)](03____chatbot_system_.md)\n4. [    (Environment Configuration and Secret Key Management)](04______environment_configuration_and_secret_key_management_.md)\n5. [  (Data Preprocessing)](05____data_preprocessing_.md)\n6. [ChromaDB     (ChromaDB Connection and Data Storage)](06_chromadb______chromadb_connection_and_data_storage_.md)\n7. [     (Data Embedding and Model Preparation)](07_______data_embedding_and_model_preparation_.md)\n8. [   (Similarity-based Retrieval)](08_____similarity_based_retrieval_.md)\n9. [   (Travel Review Processing)](09_____travel_review_processing_.md)\n10. [OpenAI  (OpenAI Integration)](10_openai___openai_integration_.md)\n\nContext from previous chapters (Note: This summary might be in Korean):\n# Chapter 1: Django  (Django Framework)\n\n##   \n\n              .  ,         .  , ,          .           .\n\nDjango       .    ,  ,             .\n\n## Django  \n\n   Django     .  Django    :\n\n### 1. MTV \nDjango **MTV (Model, Template, View)**  .\n- **Model ()**:       .\n- **Template ()**:     .\n- **View ()**:        .\n\n### 2. URL \nDjango URL       .    URL   , Django     .\n\n### 3.  \nDjango ORM(Object-Relational Mapping)    .      .\n\n## Django   \n\nDjango    ,  \"Hello, World!\"   .\n\n###  \n\n, Django  ,  .\n\n```bash\ndjango-admin startproject myproject\ncd myproject\npython manage.py startapp myapp\n```\n\n, URL  .\n\n**urls.py**  :\n```python\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('', views.hello_world, name='hello_world'),\n]\n```\n\n**views.py**  :\n```python\nfrom django.http import HttpResponse\n\ndef hello_world(request):\n    return HttpResponse(\"Hello, World!\")\n```\n\n#### \n    Django   .   URL  ,  URL  **hello_world**   . , `hello_world()`   \"Hello, World!\"  .\n\n##   \n\nDjango         .  URL     :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    \n     ->> : HTTP  (URL)\n     ->> Django: URL    \n    Django ->> :   \n     ->> : HTTP  ( )\n```\n\n###    \n\nDjango  **settings.py**  , **urls.py**  . `manage.py`    ,   .\n\n**settings.py**     :\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    ...\n    'myapp',  #    \n]\n```\n\n  Django     .\n\n## \n\n  Django      . Django         .   [   HTML ](02____html___user_interface_and_html_rendering_.md)  .\n---\n# Chapter 2:    HTML  (User Interface and HTML Rendering)\n\n  [Django ](01_django___django_framework_.md)  .       \"   HTML \"  .\n\n##    \n\n        UI ( ).  ,    ,          UI      .    HTML  ,      . \n\nHTML           .         .\n\n##  \n\n### 1.  \n\nDjango HTML      .    ,         .\n\n```html\n<!-- : templates/hello.html -->\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n    <h1>, {{ username }}!</h1>\n</body>\n</html>\n```\n\n#### \n `{{ username }}`   `views.py`   `username`  . \n\n### 2.   \n\n           .\n\n```python\n# views.py\nfrom django.shortcuts import render\n\ndef greet_user(request):\n    user_name = \"\"  #   \n    return render(request, 'hello.html', {'username': user_name})\n```\n\n#### \n  `render()`   `hello.html`    .     `{{ username }}` \"\" .\n\n##   \n\n Django    .       :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    participant HTML\n\n     ->> : HTTP \n     ->> Django:  \n    Django ->> :    \n     ->> HTML: HTML   \n    HTML ->> : HTTP  ( )\n```\n\n###    \n\nDjango          HTML .\n\n**settings.py**   :\n```python\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [os.path.join(BASE_DIR, 'templates')],  #     \n        ...\n    },\n]\n```\n\n  Django      . `BASE_DIR`    .\n\n## \n\n  HTML      Django      HTML  .   [ ](03____chatbot_system_.md)        .\n---\n# Chapter 3:   (Chatbot System)\n\n  [   HTML ](02____html___user_interface_and_html_rendering_.md)  .       ** **        .\n\n##    \n\n       .  ,       .        ,        .\n\n        .\n\n##  \n\n### 1.   \n\n      .       .\n\n```python\n# views.py\ndef get_user_input(request):\n    user_input = request.POST.get('message')\n    return user_input\n```\n\n#### \n  `request.POST.get('message')`    .\n\n### 2.    \n\n        .\n\n```python\n# examples.py\ndef recommend_place(user_input):\n    #    \n    if \"\" in user_input:\n        return \"\"\n    elif \"\" in user_input:\n        return \"\"\n    else:\n        return \"\"\n```\n\n#### \n   \"\"   , \"\"   .     .\n\n##   \n\n     . \n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    participant \n\n     ->> : ' '\n     ->> Django:  \n    Django ->> :  \n     ->> :  \n     ->> : ''\n```\n\n###   \n\n      .\n\n```python\n# views.py\nfrom django.shortcuts import render\nfrom .examples import recommend_place\n\ndef chat_response(request):\n    user_input = request.POST.get('message')\n    place = recommend_place(user_input)\n    return render(request, 'chat.html', {'response': place})\n```\n\n#### \n `chat_response`    , `recommend_place`       .\n\n**settings.py POST   **\n```python\nMIDDLEWARE = [\n    ...\n    'django.middleware.csrf.CsrfViewMiddleware',  # CSRF  \n    ...\n]\n```\n\n   POST     .\n\n## \n\n           .           .   [   ](04______environment_configuration_and_secret_key_management_.md)       .\n---\n# Chapter 4:     (Environment Configuration and Secret Key Management)\n\n  [ ](03____chatbot_system_.md)   .          .        .\n\n##    \n\n   ,    API       .  ,  API   API  .    3    .           .\n\n##  \n\n### 1.   \n\n       ,       .         .\n\n```python\n# settings.py\nimport os\n\nDATABASE_URL = os.getenv('DATABASE_URL')\nSECRET_KEY = os.getenv('SECRET_KEY')\n```\n\n#### \n `os.getenv()`      . `DATABASE_URL` `SECRET_KEY`      .\n\n### 2. `.env`   \n\n    `.env`    .     ,     .\n\n```\n# .env \nDATABASE_URL=your_database_url_here\nSECRET_KEY=your_secret_key_here\n```\n\n#### \n`.env`      ,      .\n\n### 3. Python  \n\n`python-dotenv`   `.env`      .\n\n```bash\npip install python-dotenv\n```\n\n```python\n# manage.py  wsgi.py\nfrom dotenv import load_dotenv\nload_dotenv()\n```\n\n#### \n`load_dotenv()`   `.env`  ,      .\n\n##   \n\n           :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant dotenv\n    participant \n    participant \n\n     ->> :   \n     ->> dotenv: `.env`  \n    dotenv ->> :   \n     ->> :   \n```\n\n###   \n\n      `.env`       .\n\n```python\n# views.py\nimport os\n\ndef get_secret_key():\n    secret_key = os.getenv('SECRET_KEY')\n    if not secret_key:\n        raise ValueError(\"SECRET_KEY  .\")\n    return secret_key\n```\n\n#### \n  `os.getenv()`     `SECRET_KEY` .       .\n\n**settings.py    **\n```python\nDEBUG = os.getenv('DEBUG', 'False') == 'True'  #   \n```\n\n     ,          .\n\n## \n\n      ,         .               .\n\n  [ ](05____data_preprocessing_.md)  .        .\n---\n# Chapter 5:   (Data Preprocessing)\n\n  [   ](04______environment_configuration_and_secret_key_management_.md)  .            .\n\n##    \n\n           .  ,       .       .                .\n\n##  \n\n### 1.  \n\n      .  ,      .\n\n```python\n#  \nimport pandas as pd\n\ndata = {'': ['', None, ''], '': [23, None, 30]}\ndf = pd.DataFrame(data)\ndf = df.dropna()  #    \n```\n\n#### \n      . `dropna()`      .\n\n### 2.  \n\n     ,    . \n\n```python\n#   \nimport numpy as np\n\nages = [23, 25, 22, 400, 21]\nages = [age if age < 120 else np.median(ages) for age in ages]  # 400  \n```\n\n#### \n  400    .\n\n### 3.  \n\n       .       .\n\n```python\n#  \nfrom sklearn.preprocessing import MinMaxScaler\n\nscaler = MinMaxScaler()\nnormalized_data = scaler.fit_transform([[25], [30], [45]])\n```\n\n#### \n 0 1   .         .\n\n##   \n\n         :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant \n    participant \n    participant \n\n     ->> : / \n     ->> :   \n     ->> :  \n     ->> :    \n```\n\n###   \n\n       .\n\n```python\n# data_preprocessing.py\nimport pandas as pd\nfrom sklearn.preprocessing import MinMaxScaler\n\ndef preprocess_data(data):\n    df = pd.DataFrame(data)\n    df = df.dropna()  #  \n    ages = df['age'].tolist()\n    median_age = np.median(ages)\n    df['age'] = [age if age < 120 else median_age for age in ages]  #  \n\n    scaler = MinMaxScaler()\n    df[['age_normalized']] = scaler.fit_transform(df[['age']])\n    return df\n```\n\n#### \n`preprocess_data`     ,  ,  .\n\n## \n\n        .        ,        .\n\n  [ChromaDB    ](06_chromadb______chromadb_connection_and_data_storage_.md)   .          .\n\nRelevant Code Snippets (Code itself remains unchanged):\nNo specific code snippets provided for this abstraction.\n\nInstructions for the chapter (Generate content in Korean unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 6: ChromaDB     (ChromaDB Connection and Data Storage)`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).\n\n- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).\n\n- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).\n\n- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).\n\n- Heavily use analogies and examples throughout (in Korean) to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 6: ChromaDB     (ChromaDB Connection and Data Storage)\n\n  [ ](05____data_preprocessing_.md)  .          **ChromaDB**   . ChromaDB   ,       .\n\n##    \n\n        .  ,       .          . ChromaDB   ,      .\n\n##  \n\n### 1. ChromaDB \n\nChromaDB      .      .\n\n```python\n# chromadb_setting.py\nfrom chromadb import Client\n\nclient = Client('your_chromadb_connection_string')\n```\n\n#### \n `Client`   ChromaDB  .       .\n\n### 2.  \n\n       ,    .\n\n```python\n#   \ndef store_in_chromadb(client, data):\n    table = client.create_table('reviews')\n    table.insert(data)\n```\n\n#### \n`create_table()`   , `insert()`   .      .\n\n### 3.  \n\n     .           .\n\n```python\n#   \ndef search_data(client, query):\n    table = client.table('reviews')\n    results = table.search(query)\n    return results\n```\n\n#### \n`search()`         .       .\n\n##   \n\nChromaDB      :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant ChromaDB\n    participant \n    participant \n\n     ->> :  \n     ->> ChromaDB:   \n    ChromaDB ->> :  \n     ->> :  \n     ->> :  \n     ->> :   \n```\n\n###   \n\nChromaDB         :\n\n```python\n# chromadb_connection.py\nfrom chromadb import Client\n\ndef connect_to_chromadb():\n    client = Client('your_chromadb_connection_string')\n    return client\n```\n\n#### \n      .          .\n\n## \n\n  ChromaDB       . ChromaDB       . \n\n  [    ](07_______data_embedding_and_model_preparation_.md)   .         .",
    "\nIMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.\n\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `develop` about the concept: \"     (Data Embedding and Model Preparation)\". This is Chapter 7.\n\nConcept Details (Note: Provided in Korean):\n- Name:      (Data Embedding and Model Preparation)\n- Description:\nSentenceTransformer        .\n\nComplete Tutorial Structure (Note: Chapter names might be in Korean):\n1. [Django  (Django Framework)](01_django___django_framework_.md)\n2. [   HTML  (User Interface and HTML Rendering)](02____html___user_interface_and_html_rendering_.md)\n3. [  (Chatbot System)](03____chatbot_system_.md)\n4. [    (Environment Configuration and Secret Key Management)](04______environment_configuration_and_secret_key_management_.md)\n5. [  (Data Preprocessing)](05____data_preprocessing_.md)\n6. [ChromaDB     (ChromaDB Connection and Data Storage)](06_chromadb______chromadb_connection_and_data_storage_.md)\n7. [     (Data Embedding and Model Preparation)](07_______data_embedding_and_model_preparation_.md)\n8. [   (Similarity-based Retrieval)](08_____similarity_based_retrieval_.md)\n9. [   (Travel Review Processing)](09_____travel_review_processing_.md)\n10. [OpenAI  (OpenAI Integration)](10_openai___openai_integration_.md)\n\nContext from previous chapters (Note: This summary might be in Korean):\n# Chapter 1: Django  (Django Framework)\n\n##   \n\n              .  ,         .  , ,          .           .\n\nDjango       .    ,  ,             .\n\n## Django  \n\n   Django     .  Django    :\n\n### 1. MTV \nDjango **MTV (Model, Template, View)**  .\n- **Model ()**:       .\n- **Template ()**:     .\n- **View ()**:        .\n\n### 2. URL \nDjango URL       .    URL   , Django     .\n\n### 3.  \nDjango ORM(Object-Relational Mapping)    .      .\n\n## Django   \n\nDjango    ,  \"Hello, World!\"   .\n\n###  \n\n, Django  ,  .\n\n```bash\ndjango-admin startproject myproject\ncd myproject\npython manage.py startapp myapp\n```\n\n, URL  .\n\n**urls.py**  :\n```python\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('', views.hello_world, name='hello_world'),\n]\n```\n\n**views.py**  :\n```python\nfrom django.http import HttpResponse\n\ndef hello_world(request):\n    return HttpResponse(\"Hello, World!\")\n```\n\n#### \n    Django   .   URL  ,  URL  **hello_world**   . , `hello_world()`   \"Hello, World!\"  .\n\n##   \n\nDjango         .  URL     :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    \n     ->> : HTTP  (URL)\n     ->> Django: URL    \n    Django ->> :   \n     ->> : HTTP  ( )\n```\n\n###    \n\nDjango  **settings.py**  , **urls.py**  . `manage.py`    ,   .\n\n**settings.py**     :\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    ...\n    'myapp',  #    \n]\n```\n\n  Django     .\n\n## \n\n  Django      . Django         .   [   HTML ](02____html___user_interface_and_html_rendering_.md)  .\n---\n# Chapter 2:    HTML  (User Interface and HTML Rendering)\n\n  [Django ](01_django___django_framework_.md)  .       \"   HTML \"  .\n\n##    \n\n        UI ( ).  ,    ,          UI      .    HTML  ,      . \n\nHTML           .         .\n\n##  \n\n### 1.  \n\nDjango HTML      .    ,         .\n\n```html\n<!-- : templates/hello.html -->\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n    <h1>, {{ username }}!</h1>\n</body>\n</html>\n```\n\n#### \n `{{ username }}`   `views.py`   `username`  . \n\n### 2.   \n\n           .\n\n```python\n# views.py\nfrom django.shortcuts import render\n\ndef greet_user(request):\n    user_name = \"\"  #   \n    return render(request, 'hello.html', {'username': user_name})\n```\n\n#### \n  `render()`   `hello.html`    .     `{{ username }}` \"\" .\n\n##   \n\n Django    .       :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    participant HTML\n\n     ->> : HTTP \n     ->> Django:  \n    Django ->> :    \n     ->> HTML: HTML   \n    HTML ->> : HTTP  ( )\n```\n\n###    \n\nDjango          HTML .\n\n**settings.py**   :\n```python\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [os.path.join(BASE_DIR, 'templates')],  #     \n        ...\n    },\n]\n```\n\n  Django      . `BASE_DIR`    .\n\n## \n\n  HTML      Django      HTML  .   [ ](03____chatbot_system_.md)        .\n---\n# Chapter 3:   (Chatbot System)\n\n  [   HTML ](02____html___user_interface_and_html_rendering_.md)  .       ** **        .\n\n##    \n\n       .  ,       .        ,        .\n\n        .\n\n##  \n\n### 1.   \n\n      .       .\n\n```python\n# views.py\ndef get_user_input(request):\n    user_input = request.POST.get('message')\n    return user_input\n```\n\n#### \n  `request.POST.get('message')`    .\n\n### 2.    \n\n        .\n\n```python\n# examples.py\ndef recommend_place(user_input):\n    #    \n    if \"\" in user_input:\n        return \"\"\n    elif \"\" in user_input:\n        return \"\"\n    else:\n        return \"\"\n```\n\n#### \n   \"\"   , \"\"   .     .\n\n##   \n\n     . \n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    participant \n\n     ->> : ' '\n     ->> Django:  \n    Django ->> :  \n     ->> :  \n     ->> : ''\n```\n\n###   \n\n      .\n\n```python\n# views.py\nfrom django.shortcuts import render\nfrom .examples import recommend_place\n\ndef chat_response(request):\n    user_input = request.POST.get('message')\n    place = recommend_place(user_input)\n    return render(request, 'chat.html', {'response': place})\n```\n\n#### \n `chat_response`    , `recommend_place`       .\n\n**settings.py POST   **\n```python\nMIDDLEWARE = [\n    ...\n    'django.middleware.csrf.CsrfViewMiddleware',  # CSRF  \n    ...\n]\n```\n\n   POST     .\n\n## \n\n           .           .   [   ](04______environment_configuration_and_secret_key_management_.md)       .\n---\n# Chapter 4:     (Environment Configuration and Secret Key Management)\n\n  [ ](03____chatbot_system_.md)   .          .        .\n\n##    \n\n   ,    API       .  ,  API   API  .    3    .           .\n\n##  \n\n### 1.   \n\n       ,       .         .\n\n```python\n# settings.py\nimport os\n\nDATABASE_URL = os.getenv('DATABASE_URL')\nSECRET_KEY = os.getenv('SECRET_KEY')\n```\n\n#### \n `os.getenv()`      . `DATABASE_URL` `SECRET_KEY`      .\n\n### 2. `.env`   \n\n    `.env`    .     ,     .\n\n```\n# .env \nDATABASE_URL=your_database_url_here\nSECRET_KEY=your_secret_key_here\n```\n\n#### \n`.env`      ,      .\n\n### 3. Python  \n\n`python-dotenv`   `.env`      .\n\n```bash\npip install python-dotenv\n```\n\n```python\n# manage.py  wsgi.py\nfrom dotenv import load_dotenv\nload_dotenv()\n```\n\n#### \n`load_dotenv()`   `.env`  ,      .\n\n##   \n\n           :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant dotenv\n    participant \n    participant \n\n     ->> :   \n     ->> dotenv: `.env`  \n    dotenv ->> :   \n     ->> :   \n```\n\n###   \n\n      `.env`       .\n\n```python\n# views.py\nimport os\n\ndef get_secret_key():\n    secret_key = os.getenv('SECRET_KEY')\n    if not secret_key:\n        raise ValueError(\"SECRET_KEY  .\")\n    return secret_key\n```\n\n#### \n  `os.getenv()`     `SECRET_KEY` .       .\n\n**settings.py    **\n```python\nDEBUG = os.getenv('DEBUG', 'False') == 'True'  #   \n```\n\n     ,          .\n\n## \n\n      ,         .               .\n\n  [ ](05____data_preprocessing_.md)  .        .\n---\n# Chapter 5:   (Data Preprocessing)\n\n  [   ](04______environment_configuration_and_secret_key_management_.md)  .            .\n\n##    \n\n           .  ,       .       .                .\n\n##  \n\n### 1.  \n\n      .  ,      .\n\n```python\n#  \nimport pandas as pd\n\ndata = {'': ['', None, ''], '': [23, None, 30]}\ndf = pd.DataFrame(data)\ndf = df.dropna()  #    \n```\n\n#### \n      . `dropna()`      .\n\n### 2.  \n\n     ,    . \n\n```python\n#   \nimport numpy as np\n\nages = [23, 25, 22, 400, 21]\nages = [age if age < 120 else np.median(ages) for age in ages]  # 400  \n```\n\n#### \n  400    .\n\n### 3.  \n\n       .       .\n\n```python\n#  \nfrom sklearn.preprocessing import MinMaxScaler\n\nscaler = MinMaxScaler()\nnormalized_data = scaler.fit_transform([[25], [30], [45]])\n```\n\n#### \n 0 1   .         .\n\n##   \n\n         :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant \n    participant \n    participant \n\n     ->> : / \n     ->> :   \n     ->> :  \n     ->> :    \n```\n\n###   \n\n       .\n\n```python\n# data_preprocessing.py\nimport pandas as pd\nfrom sklearn.preprocessing import MinMaxScaler\n\ndef preprocess_data(data):\n    df = pd.DataFrame(data)\n    df = df.dropna()  #  \n    ages = df['age'].tolist()\n    median_age = np.median(ages)\n    df['age'] = [age if age < 120 else median_age for age in ages]  #  \n\n    scaler = MinMaxScaler()\n    df[['age_normalized']] = scaler.fit_transform(df[['age']])\n    return df\n```\n\n#### \n`preprocess_data`     ,  ,  .\n\n## \n\n        .        ,        .\n\n  [ChromaDB    ](06_chromadb______chromadb_connection_and_data_storage_.md)   .          .\n---\n# Chapter 6: ChromaDB     (ChromaDB Connection and Data Storage)\n\n  [ ](05____data_preprocessing_.md)  .          **ChromaDB**   . ChromaDB   ,       .\n\n##    \n\n        .  ,       .          . ChromaDB   ,      .\n\n##  \n\n### 1. ChromaDB \n\nChromaDB      .      .\n\n```python\n# chromadb_setting.py\nfrom chromadb import Client\n\nclient = Client('your_chromadb_connection_string')\n```\n\n#### \n `Client`   ChromaDB  .       .\n\n### 2.  \n\n       ,    .\n\n```python\n#   \ndef store_in_chromadb(client, data):\n    table = client.create_table('reviews')\n    table.insert(data)\n```\n\n#### \n`create_table()`   , `insert()`   .      .\n\n### 3.  \n\n     .           .\n\n```python\n#   \ndef search_data(client, query):\n    table = client.table('reviews')\n    results = table.search(query)\n    return results\n```\n\n#### \n`search()`         .       .\n\n##   \n\nChromaDB      :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant ChromaDB\n    participant \n    participant \n\n     ->> :  \n     ->> ChromaDB:   \n    ChromaDB ->> :  \n     ->> :  \n     ->> :  \n     ->> :   \n```\n\n###   \n\nChromaDB         :\n\n```python\n# chromadb_connection.py\nfrom chromadb import Client\n\ndef connect_to_chromadb():\n    client = Client('your_chromadb_connection_string')\n    return client\n```\n\n#### \n      .          .\n\n## \n\n  ChromaDB       . ChromaDB       . \n\n  [    ](07_______data_embedding_and_model_preparation_.md)   .         .\n\nRelevant Code Snippets (Code itself remains unchanged):\nNo specific code snippets provided for this abstraction.\n\nInstructions for the chapter (Generate content in Korean unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 7:      (Data Embedding and Model Preparation)`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).\n\n- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).\n\n- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).\n\n- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).\n\n- Heavily use analogies and examples throughout (in Korean) to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 7:      (Data Embedding and Model Preparation)\n\n  [ChromaDB    ](06_chromadb______chromadb_connection_and_data_storage_.md)  .           '    '  .          .\n\n##    \n\n          .  ,      users   .   SentenceTransformer      .           .\n\n##  \n\n### 1. SentenceTransformer   \n\n       .         . \n\n```python\n#  \nfrom sentence_transformers import SentenceTransformer\n\nmodel = SentenceTransformer('all-MiniLM-L6-v2')\nembeddings = model.encode([\"  .\"])\n\nprint(embeddings)\n```\n\n#### \n  SentenceTransformer  , \"  .\"   .    ,   .\n\n### 2.     \n\n    ,    .          .\n\n```python\n#    \ndef prepare_model(embeddings):\n    #    \n    print(\"  .\")\n    return True\n```\n\n#### \n         \"  .\" . \n\n##   \n\nSentenceTransformer        :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant \n    participant \n    participant \n\n     ->> :  \n     ->> :  \n     ->> :  \n     ->> :  \n```\n\n###   \n\n SentenceTransformer       :\n\n```python\n# internal_embedding.py\ndef internal_embedding_process(sentence):\n    #    \n    print(f\"'{sentence}'()  .\")\n    return [0.5] * 384  #    \n```\n\n#### \n     .       .\n\n## \n\n           . SentenceTransformer       .   [  ](08_____similarity_based_retrieval_.md)   .         .",
    "\nIMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.\n\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `develop` about the concept: \"   (Similarity-based Retrieval)\". This is Chapter 8.\n\nConcept Details (Note: Provided in Korean):\n- Name:    (Similarity-based Retrieval)\n- Description:\n      ChromaDB     .\n\nComplete Tutorial Structure (Note: Chapter names might be in Korean):\n1. [Django  (Django Framework)](01_django___django_framework_.md)\n2. [   HTML  (User Interface and HTML Rendering)](02____html___user_interface_and_html_rendering_.md)\n3. [  (Chatbot System)](03____chatbot_system_.md)\n4. [    (Environment Configuration and Secret Key Management)](04______environment_configuration_and_secret_key_management_.md)\n5. [  (Data Preprocessing)](05____data_preprocessing_.md)\n6. [ChromaDB     (ChromaDB Connection and Data Storage)](06_chromadb______chromadb_connection_and_data_storage_.md)\n7. [     (Data Embedding and Model Preparation)](07_______data_embedding_and_model_preparation_.md)\n8. [   (Similarity-based Retrieval)](08_____similarity_based_retrieval_.md)\n9. [   (Travel Review Processing)](09_____travel_review_processing_.md)\n10. [OpenAI  (OpenAI Integration)](10_openai___openai_integration_.md)\n\nContext from previous chapters (Note: This summary might be in Korean):\n# Chapter 1: Django  (Django Framework)\n\n##   \n\n              .  ,         .  , ,          .           .\n\nDjango       .    ,  ,             .\n\n## Django  \n\n   Django     .  Django    :\n\n### 1. MTV \nDjango **MTV (Model, Template, View)**  .\n- **Model ()**:       .\n- **Template ()**:     .\n- **View ()**:        .\n\n### 2. URL \nDjango URL       .    URL   , Django     .\n\n### 3.  \nDjango ORM(Object-Relational Mapping)    .      .\n\n## Django   \n\nDjango    ,  \"Hello, World!\"   .\n\n###  \n\n, Django  ,  .\n\n```bash\ndjango-admin startproject myproject\ncd myproject\npython manage.py startapp myapp\n```\n\n, URL  .\n\n**urls.py**  :\n```python\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('', views.hello_world, name='hello_world'),\n]\n```\n\n**views.py**  :\n```python\nfrom django.http import HttpResponse\n\ndef hello_world(request):\n    return HttpResponse(\"Hello, World!\")\n```\n\n#### \n    Django   .   URL  ,  URL  **hello_world**   . , `hello_world()`   \"Hello, World!\"  .\n\n##   \n\nDjango         .  URL     :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    \n     ->> : HTTP  (URL)\n     ->> Django: URL    \n    Django ->> :   \n     ->> : HTTP  ( )\n```\n\n###    \n\nDjango  **settings.py**  , **urls.py**  . `manage.py`    ,   .\n\n**settings.py**     :\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    ...\n    'myapp',  #    \n]\n```\n\n  Django     .\n\n## \n\n  Django      . Django         .   [   HTML ](02____html___user_interface_and_html_rendering_.md)  .\n---\n# Chapter 2:    HTML  (User Interface and HTML Rendering)\n\n  [Django ](01_django___django_framework_.md)  .       \"   HTML \"  .\n\n##    \n\n        UI ( ).  ,    ,          UI      .    HTML  ,      . \n\nHTML           .         .\n\n##  \n\n### 1.  \n\nDjango HTML      .    ,         .\n\n```html\n<!-- : templates/hello.html -->\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n    <h1>, {{ username }}!</h1>\n</body>\n</html>\n```\n\n#### \n `{{ username }}`   `views.py`   `username`  . \n\n### 2.   \n\n           .\n\n```python\n# views.py\nfrom django.shortcuts import render\n\ndef greet_user(request):\n    user_name = \"\"  #   \n    return render(request, 'hello.html', {'username': user_name})\n```\n\n#### \n  `render()`   `hello.html`    .     `{{ username }}` \"\" .\n\n##   \n\n Django    .       :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    participant HTML\n\n     ->> : HTTP \n     ->> Django:  \n    Django ->> :    \n     ->> HTML: HTML   \n    HTML ->> : HTTP  ( )\n```\n\n###    \n\nDjango          HTML .\n\n**settings.py**   :\n```python\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [os.path.join(BASE_DIR, 'templates')],  #     \n        ...\n    },\n]\n```\n\n  Django      . `BASE_DIR`    .\n\n## \n\n  HTML      Django      HTML  .   [ ](03____chatbot_system_.md)        .\n---\n# Chapter 3:   (Chatbot System)\n\n  [   HTML ](02____html___user_interface_and_html_rendering_.md)  .       ** **        .\n\n##    \n\n       .  ,       .        ,        .\n\n        .\n\n##  \n\n### 1.   \n\n      .       .\n\n```python\n# views.py\ndef get_user_input(request):\n    user_input = request.POST.get('message')\n    return user_input\n```\n\n#### \n  `request.POST.get('message')`    .\n\n### 2.    \n\n        .\n\n```python\n# examples.py\ndef recommend_place(user_input):\n    #    \n    if \"\" in user_input:\n        return \"\"\n    elif \"\" in user_input:\n        return \"\"\n    else:\n        return \"\"\n```\n\n#### \n   \"\"   , \"\"   .     .\n\n##   \n\n     . \n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    participant \n\n     ->> : ' '\n     ->> Django:  \n    Django ->> :  \n     ->> :  \n     ->> : ''\n```\n\n###   \n\n      .\n\n```python\n# views.py\nfrom django.shortcuts import render\nfrom .examples import recommend_place\n\ndef chat_response(request):\n    user_input = request.POST.get('message')\n    place = recommend_place(user_input)\n    return render(request, 'chat.html', {'response': place})\n```\n\n#### \n `chat_response`    , `recommend_place`       .\n\n**settings.py POST   **\n```python\nMIDDLEWARE = [\n    ...\n    'django.middleware.csrf.CsrfViewMiddleware',  # CSRF  \n    ...\n]\n```\n\n   POST     .\n\n## \n\n           .           .   [   ](04______environment_configuration_and_secret_key_management_.md)       .\n---\n# Chapter 4:     (Environment Configuration and Secret Key Management)\n\n  [ ](03____chatbot_system_.md)   .          .        .\n\n##    \n\n   ,    API       .  ,  API   API  .    3    .           .\n\n##  \n\n### 1.   \n\n       ,       .         .\n\n```python\n# settings.py\nimport os\n\nDATABASE_URL = os.getenv('DATABASE_URL')\nSECRET_KEY = os.getenv('SECRET_KEY')\n```\n\n#### \n `os.getenv()`      . `DATABASE_URL` `SECRET_KEY`      .\n\n### 2. `.env`   \n\n    `.env`    .     ,     .\n\n```\n# .env \nDATABASE_URL=your_database_url_here\nSECRET_KEY=your_secret_key_here\n```\n\n#### \n`.env`      ,      .\n\n### 3. Python  \n\n`python-dotenv`   `.env`      .\n\n```bash\npip install python-dotenv\n```\n\n```python\n# manage.py  wsgi.py\nfrom dotenv import load_dotenv\nload_dotenv()\n```\n\n#### \n`load_dotenv()`   `.env`  ,      .\n\n##   \n\n           :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant dotenv\n    participant \n    participant \n\n     ->> :   \n     ->> dotenv: `.env`  \n    dotenv ->> :   \n     ->> :   \n```\n\n###   \n\n      `.env`       .\n\n```python\n# views.py\nimport os\n\ndef get_secret_key():\n    secret_key = os.getenv('SECRET_KEY')\n    if not secret_key:\n        raise ValueError(\"SECRET_KEY  .\")\n    return secret_key\n```\n\n#### \n  `os.getenv()`     `SECRET_KEY` .       .\n\n**settings.py    **\n```python\nDEBUG = os.getenv('DEBUG', 'False') == 'True'  #   \n```\n\n     ,          .\n\n## \n\n      ,         .               .\n\n  [ ](05____data_preprocessing_.md)  .        .\n---\n# Chapter 5:   (Data Preprocessing)\n\n  [   ](04______environment_configuration_and_secret_key_management_.md)  .            .\n\n##    \n\n           .  ,       .       .                .\n\n##  \n\n### 1.  \n\n      .  ,      .\n\n```python\n#  \nimport pandas as pd\n\ndata = {'': ['', None, ''], '': [23, None, 30]}\ndf = pd.DataFrame(data)\ndf = df.dropna()  #    \n```\n\n#### \n      . `dropna()`      .\n\n### 2.  \n\n     ,    . \n\n```python\n#   \nimport numpy as np\n\nages = [23, 25, 22, 400, 21]\nages = [age if age < 120 else np.median(ages) for age in ages]  # 400  \n```\n\n#### \n  400    .\n\n### 3.  \n\n       .       .\n\n```python\n#  \nfrom sklearn.preprocessing import MinMaxScaler\n\nscaler = MinMaxScaler()\nnormalized_data = scaler.fit_transform([[25], [30], [45]])\n```\n\n#### \n 0 1   .         .\n\n##   \n\n         :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant \n    participant \n    participant \n\n     ->> : / \n     ->> :   \n     ->> :  \n     ->> :    \n```\n\n###   \n\n       .\n\n```python\n# data_preprocessing.py\nimport pandas as pd\nfrom sklearn.preprocessing import MinMaxScaler\n\ndef preprocess_data(data):\n    df = pd.DataFrame(data)\n    df = df.dropna()  #  \n    ages = df['age'].tolist()\n    median_age = np.median(ages)\n    df['age'] = [age if age < 120 else median_age for age in ages]  #  \n\n    scaler = MinMaxScaler()\n    df[['age_normalized']] = scaler.fit_transform(df[['age']])\n    return df\n```\n\n#### \n`preprocess_data`     ,  ,  .\n\n## \n\n        .        ,        .\n\n  [ChromaDB    ](06_chromadb______chromadb_connection_and_data_storage_.md)   .          .\n---\n# Chapter 6: ChromaDB     (ChromaDB Connection and Data Storage)\n\n  [ ](05____data_preprocessing_.md)  .          **ChromaDB**   . ChromaDB   ,       .\n\n##    \n\n        .  ,       .          . ChromaDB   ,      .\n\n##  \n\n### 1. ChromaDB \n\nChromaDB      .      .\n\n```python\n# chromadb_setting.py\nfrom chromadb import Client\n\nclient = Client('your_chromadb_connection_string')\n```\n\n#### \n `Client`   ChromaDB  .       .\n\n### 2.  \n\n       ,    .\n\n```python\n#   \ndef store_in_chromadb(client, data):\n    table = client.create_table('reviews')\n    table.insert(data)\n```\n\n#### \n`create_table()`   , `insert()`   .      .\n\n### 3.  \n\n     .           .\n\n```python\n#   \ndef search_data(client, query):\n    table = client.table('reviews')\n    results = table.search(query)\n    return results\n```\n\n#### \n`search()`         .       .\n\n##   \n\nChromaDB      :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant ChromaDB\n    participant \n    participant \n\n     ->> :  \n     ->> ChromaDB:   \n    ChromaDB ->> :  \n     ->> :  \n     ->> :  \n     ->> :   \n```\n\n###   \n\nChromaDB         :\n\n```python\n# chromadb_connection.py\nfrom chromadb import Client\n\ndef connect_to_chromadb():\n    client = Client('your_chromadb_connection_string')\n    return client\n```\n\n#### \n      .          .\n\n## \n\n  ChromaDB       . ChromaDB       . \n\n  [    ](07_______data_embedding_and_model_preparation_.md)   .         .\n---\n# Chapter 7:      (Data Embedding and Model Preparation)\n\n  [ChromaDB    ](06_chromadb______chromadb_connection_and_data_storage_.md)  .           '    '  .          .\n\n##    \n\n          .  ,      users   .   SentenceTransformer      .           .\n\n##  \n\n### 1. SentenceTransformer   \n\n       .         . \n\n```python\n#  \nfrom sentence_transformers import SentenceTransformer\n\nmodel = SentenceTransformer('all-MiniLM-L6-v2')\nembeddings = model.encode([\"  .\"])\n\nprint(embeddings)\n```\n\n#### \n  SentenceTransformer  , \"  .\"   .    ,   .\n\n### 2.     \n\n    ,    .          .\n\n```python\n#    \ndef prepare_model(embeddings):\n    #    \n    print(\"  .\")\n    return True\n```\n\n#### \n         \"  .\" . \n\n##   \n\nSentenceTransformer        :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant \n    participant \n    participant \n\n     ->> :  \n     ->> :  \n     ->> :  \n     ->> :  \n```\n\n###   \n\n SentenceTransformer       :\n\n```python\n# internal_embedding.py\ndef internal_embedding_process(sentence):\n    #    \n    print(f\"'{sentence}'()  .\")\n    return [0.5] * 384  #    \n```\n\n#### \n     .       .\n\n## \n\n           . SentenceTransformer       .   [  ](08_____similarity_based_retrieval_.md)   .         .\n\nRelevant Code Snippets (Code itself remains unchanged):\nNo specific code snippets provided for this abstraction.\n\nInstructions for the chapter (Generate content in Korean unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 8:    (Similarity-based Retrieval)`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).\n\n- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).\n\n- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).\n\n- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).\n\n- Heavily use analogies and examples throughout (in Korean) to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 8:    (Similarity-based Retrieval)\n\n  [    ](07_______data_embedding_and_model_preparation_.md)  .             **  **  .        .\n\n##    \n\n          .              .    ,     .\n\n##  \n\n### 1.   \n\n      .          .\n\n```python\n#   \nfrom sklearn.metrics.pairwise import cosine_similarity\n\ndef calculate_similarity(vector1, vector2):\n    similarity = cosine_similarity([vector1], [vector2])\n    return similarity[0][0]\n```\n\n#### \n          .  1      .\n\n### 2.    \n\nChromaDB      .        .\n\n```python\n#    \ndef retrieve_similar_places(client, embedded_query):\n    table = client.table('places')\n    results = table.find_nearest(embedded_query, top_k=5)\n    return results\n```\n\n#### \n`find_nearest`        5  .        .\n\n##   \n\n          .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant \n    participant \n    participant \n\n     ->> :  \n     ->> :  \n     ->> :  \n     ->> :   \n```\n\n###   \n\n         .\n\n```python\n# search.py\nfrom sentence_transformers import SentenceTransformer\nfrom sklearn.metrics.pairwise import cosine_similarity\n\ndef search_similar_places(client, query):\n    model = SentenceTransformer('all-MiniLM-L6-v2')\n    embedded_query = model.encode(query)\n\n    results = retrieve_similar_places(client, embedded_query)\n\n    return results\n```\n\n#### \n    ,     .      .\n\n## \n\n          .     ChromaDB       .   [  ](09_____travel_review_processing_.md)    .         .",
    "\nIMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.\n\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `develop` about the concept: \"   (Travel Review Processing)\". This is Chapter 9.\n\nConcept Details (Note: Provided in Korean):\n- Name:    (Travel Review Processing)\n- Description:\nTripAdvisor API     OpenAI     .\n\nComplete Tutorial Structure (Note: Chapter names might be in Korean):\n1. [Django  (Django Framework)](01_django___django_framework_.md)\n2. [   HTML  (User Interface and HTML Rendering)](02____html___user_interface_and_html_rendering_.md)\n3. [  (Chatbot System)](03____chatbot_system_.md)\n4. [    (Environment Configuration and Secret Key Management)](04______environment_configuration_and_secret_key_management_.md)\n5. [  (Data Preprocessing)](05____data_preprocessing_.md)\n6. [ChromaDB     (ChromaDB Connection and Data Storage)](06_chromadb______chromadb_connection_and_data_storage_.md)\n7. [     (Data Embedding and Model Preparation)](07_______data_embedding_and_model_preparation_.md)\n8. [   (Similarity-based Retrieval)](08_____similarity_based_retrieval_.md)\n9. [   (Travel Review Processing)](09_____travel_review_processing_.md)\n10. [OpenAI  (OpenAI Integration)](10_openai___openai_integration_.md)\n\nContext from previous chapters (Note: This summary might be in Korean):\n# Chapter 1: Django  (Django Framework)\n\n##   \n\n              .  ,         .  , ,          .           .\n\nDjango       .    ,  ,             .\n\n## Django  \n\n   Django     .  Django    :\n\n### 1. MTV \nDjango **MTV (Model, Template, View)**  .\n- **Model ()**:       .\n- **Template ()**:     .\n- **View ()**:        .\n\n### 2. URL \nDjango URL       .    URL   , Django     .\n\n### 3.  \nDjango ORM(Object-Relational Mapping)    .      .\n\n## Django   \n\nDjango    ,  \"Hello, World!\"   .\n\n###  \n\n, Django  ,  .\n\n```bash\ndjango-admin startproject myproject\ncd myproject\npython manage.py startapp myapp\n```\n\n, URL  .\n\n**urls.py**  :\n```python\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('', views.hello_world, name='hello_world'),\n]\n```\n\n**views.py**  :\n```python\nfrom django.http import HttpResponse\n\ndef hello_world(request):\n    return HttpResponse(\"Hello, World!\")\n```\n\n#### \n    Django   .   URL  ,  URL  **hello_world**   . , `hello_world()`   \"Hello, World!\"  .\n\n##   \n\nDjango         .  URL     :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    \n     ->> : HTTP  (URL)\n     ->> Django: URL    \n    Django ->> :   \n     ->> : HTTP  ( )\n```\n\n###    \n\nDjango  **settings.py**  , **urls.py**  . `manage.py`    ,   .\n\n**settings.py**     :\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    ...\n    'myapp',  #    \n]\n```\n\n  Django     .\n\n## \n\n  Django      . Django         .   [   HTML ](02____html___user_interface_and_html_rendering_.md)  .\n---\n# Chapter 2:    HTML  (User Interface and HTML Rendering)\n\n  [Django ](01_django___django_framework_.md)  .       \"   HTML \"  .\n\n##    \n\n        UI ( ).  ,    ,          UI      .    HTML  ,      . \n\nHTML           .         .\n\n##  \n\n### 1.  \n\nDjango HTML      .    ,         .\n\n```html\n<!-- : templates/hello.html -->\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n    <h1>, {{ username }}!</h1>\n</body>\n</html>\n```\n\n#### \n `{{ username }}`   `views.py`   `username`  . \n\n### 2.   \n\n           .\n\n```python\n# views.py\nfrom django.shortcuts import render\n\ndef greet_user(request):\n    user_name = \"\"  #   \n    return render(request, 'hello.html', {'username': user_name})\n```\n\n#### \n  `render()`   `hello.html`    .     `{{ username }}` \"\" .\n\n##   \n\n Django    .       :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    participant HTML\n\n     ->> : HTTP \n     ->> Django:  \n    Django ->> :    \n     ->> HTML: HTML   \n    HTML ->> : HTTP  ( )\n```\n\n###    \n\nDjango          HTML .\n\n**settings.py**   :\n```python\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [os.path.join(BASE_DIR, 'templates')],  #     \n        ...\n    },\n]\n```\n\n  Django      . `BASE_DIR`    .\n\n## \n\n  HTML      Django      HTML  .   [ ](03____chatbot_system_.md)        .\n---\n# Chapter 3:   (Chatbot System)\n\n  [   HTML ](02____html___user_interface_and_html_rendering_.md)  .       ** **        .\n\n##    \n\n       .  ,       .        ,        .\n\n        .\n\n##  \n\n### 1.   \n\n      .       .\n\n```python\n# views.py\ndef get_user_input(request):\n    user_input = request.POST.get('message')\n    return user_input\n```\n\n#### \n  `request.POST.get('message')`    .\n\n### 2.    \n\n        .\n\n```python\n# examples.py\ndef recommend_place(user_input):\n    #    \n    if \"\" in user_input:\n        return \"\"\n    elif \"\" in user_input:\n        return \"\"\n    else:\n        return \"\"\n```\n\n#### \n   \"\"   , \"\"   .     .\n\n##   \n\n     . \n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    participant \n\n     ->> : ' '\n     ->> Django:  \n    Django ->> :  \n     ->> :  \n     ->> : ''\n```\n\n###   \n\n      .\n\n```python\n# views.py\nfrom django.shortcuts import render\nfrom .examples import recommend_place\n\ndef chat_response(request):\n    user_input = request.POST.get('message')\n    place = recommend_place(user_input)\n    return render(request, 'chat.html', {'response': place})\n```\n\n#### \n `chat_response`    , `recommend_place`       .\n\n**settings.py POST   **\n```python\nMIDDLEWARE = [\n    ...\n    'django.middleware.csrf.CsrfViewMiddleware',  # CSRF  \n    ...\n]\n```\n\n   POST     .\n\n## \n\n           .           .   [   ](04______environment_configuration_and_secret_key_management_.md)       .\n---\n# Chapter 4:     (Environment Configuration and Secret Key Management)\n\n  [ ](03____chatbot_system_.md)   .          .        .\n\n##    \n\n   ,    API       .  ,  API   API  .    3    .           .\n\n##  \n\n### 1.   \n\n       ,       .         .\n\n```python\n# settings.py\nimport os\n\nDATABASE_URL = os.getenv('DATABASE_URL')\nSECRET_KEY = os.getenv('SECRET_KEY')\n```\n\n#### \n `os.getenv()`      . `DATABASE_URL` `SECRET_KEY`      .\n\n### 2. `.env`   \n\n    `.env`    .     ,     .\n\n```\n# .env \nDATABASE_URL=your_database_url_here\nSECRET_KEY=your_secret_key_here\n```\n\n#### \n`.env`      ,      .\n\n### 3. Python  \n\n`python-dotenv`   `.env`      .\n\n```bash\npip install python-dotenv\n```\n\n```python\n# manage.py  wsgi.py\nfrom dotenv import load_dotenv\nload_dotenv()\n```\n\n#### \n`load_dotenv()`   `.env`  ,      .\n\n##   \n\n           :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant dotenv\n    participant \n    participant \n\n     ->> :   \n     ->> dotenv: `.env`  \n    dotenv ->> :   \n     ->> :   \n```\n\n###   \n\n      `.env`       .\n\n```python\n# views.py\nimport os\n\ndef get_secret_key():\n    secret_key = os.getenv('SECRET_KEY')\n    if not secret_key:\n        raise ValueError(\"SECRET_KEY  .\")\n    return secret_key\n```\n\n#### \n  `os.getenv()`     `SECRET_KEY` .       .\n\n**settings.py    **\n```python\nDEBUG = os.getenv('DEBUG', 'False') == 'True'  #   \n```\n\n     ,          .\n\n## \n\n      ,         .               .\n\n  [ ](05____data_preprocessing_.md)  .        .\n---\n# Chapter 5:   (Data Preprocessing)\n\n  [   ](04______environment_configuration_and_secret_key_management_.md)  .            .\n\n##    \n\n           .  ,       .       .                .\n\n##  \n\n### 1.  \n\n      .  ,      .\n\n```python\n#  \nimport pandas as pd\n\ndata = {'': ['', None, ''], '': [23, None, 30]}\ndf = pd.DataFrame(data)\ndf = df.dropna()  #    \n```\n\n#### \n      . `dropna()`      .\n\n### 2.  \n\n     ,    . \n\n```python\n#   \nimport numpy as np\n\nages = [23, 25, 22, 400, 21]\nages = [age if age < 120 else np.median(ages) for age in ages]  # 400  \n```\n\n#### \n  400    .\n\n### 3.  \n\n       .       .\n\n```python\n#  \nfrom sklearn.preprocessing import MinMaxScaler\n\nscaler = MinMaxScaler()\nnormalized_data = scaler.fit_transform([[25], [30], [45]])\n```\n\n#### \n 0 1   .         .\n\n##   \n\n         :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant \n    participant \n    participant \n\n     ->> : / \n     ->> :   \n     ->> :  \n     ->> :    \n```\n\n###   \n\n       .\n\n```python\n# data_preprocessing.py\nimport pandas as pd\nfrom sklearn.preprocessing import MinMaxScaler\n\ndef preprocess_data(data):\n    df = pd.DataFrame(data)\n    df = df.dropna()  #  \n    ages = df['age'].tolist()\n    median_age = np.median(ages)\n    df['age'] = [age if age < 120 else median_age for age in ages]  #  \n\n    scaler = MinMaxScaler()\n    df[['age_normalized']] = scaler.fit_transform(df[['age']])\n    return df\n```\n\n#### \n`preprocess_data`     ,  ,  .\n\n## \n\n        .        ,        .\n\n  [ChromaDB    ](06_chromadb______chromadb_connection_and_data_storage_.md)   .          .\n---\n# Chapter 6: ChromaDB     (ChromaDB Connection and Data Storage)\n\n  [ ](05____data_preprocessing_.md)  .          **ChromaDB**   . ChromaDB   ,       .\n\n##    \n\n        .  ,       .          . ChromaDB   ,      .\n\n##  \n\n### 1. ChromaDB \n\nChromaDB      .      .\n\n```python\n# chromadb_setting.py\nfrom chromadb import Client\n\nclient = Client('your_chromadb_connection_string')\n```\n\n#### \n `Client`   ChromaDB  .       .\n\n### 2.  \n\n       ,    .\n\n```python\n#   \ndef store_in_chromadb(client, data):\n    table = client.create_table('reviews')\n    table.insert(data)\n```\n\n#### \n`create_table()`   , `insert()`   .      .\n\n### 3.  \n\n     .           .\n\n```python\n#   \ndef search_data(client, query):\n    table = client.table('reviews')\n    results = table.search(query)\n    return results\n```\n\n#### \n`search()`         .       .\n\n##   \n\nChromaDB      :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant ChromaDB\n    participant \n    participant \n\n     ->> :  \n     ->> ChromaDB:   \n    ChromaDB ->> :  \n     ->> :  \n     ->> :  \n     ->> :   \n```\n\n###   \n\nChromaDB         :\n\n```python\n# chromadb_connection.py\nfrom chromadb import Client\n\ndef connect_to_chromadb():\n    client = Client('your_chromadb_connection_string')\n    return client\n```\n\n#### \n      .          .\n\n## \n\n  ChromaDB       . ChromaDB       . \n\n  [    ](07_______data_embedding_and_model_preparation_.md)   .         .\n---\n# Chapter 7:      (Data Embedding and Model Preparation)\n\n  [ChromaDB    ](06_chromadb______chromadb_connection_and_data_storage_.md)  .           '    '  .          .\n\n##    \n\n          .  ,      users   .   SentenceTransformer      .           .\n\n##  \n\n### 1. SentenceTransformer   \n\n       .         . \n\n```python\n#  \nfrom sentence_transformers import SentenceTransformer\n\nmodel = SentenceTransformer('all-MiniLM-L6-v2')\nembeddings = model.encode([\"  .\"])\n\nprint(embeddings)\n```\n\n#### \n  SentenceTransformer  , \"  .\"   .    ,   .\n\n### 2.     \n\n    ,    .          .\n\n```python\n#    \ndef prepare_model(embeddings):\n    #    \n    print(\"  .\")\n    return True\n```\n\n#### \n         \"  .\" . \n\n##   \n\nSentenceTransformer        :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant \n    participant \n    participant \n\n     ->> :  \n     ->> :  \n     ->> :  \n     ->> :  \n```\n\n###   \n\n SentenceTransformer       :\n\n```python\n# internal_embedding.py\ndef internal_embedding_process(sentence):\n    #    \n    print(f\"'{sentence}'()  .\")\n    return [0.5] * 384  #    \n```\n\n#### \n     .       .\n\n## \n\n           . SentenceTransformer       .   [  ](08_____similarity_based_retrieval_.md)   .         .\n---\n# Chapter 8:    (Similarity-based Retrieval)\n\n  [    ](07_______data_embedding_and_model_preparation_.md)  .             **  **  .        .\n\n##    \n\n          .              .    ,     .\n\n##  \n\n### 1.   \n\n      .          .\n\n```python\n#   \nfrom sklearn.metrics.pairwise import cosine_similarity\n\ndef calculate_similarity(vector1, vector2):\n    similarity = cosine_similarity([vector1], [vector2])\n    return similarity[0][0]\n```\n\n#### \n          .  1      .\n\n### 2.    \n\nChromaDB      .        .\n\n```python\n#    \ndef retrieve_similar_places(client, embedded_query):\n    table = client.table('places')\n    results = table.find_nearest(embedded_query, top_k=5)\n    return results\n```\n\n#### \n`find_nearest`        5  .        .\n\n##   \n\n          .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant \n    participant \n    participant \n\n     ->> :  \n     ->> :  \n     ->> :  \n     ->> :   \n```\n\n###   \n\n         .\n\n```python\n# search.py\nfrom sentence_transformers import SentenceTransformer\nfrom sklearn.metrics.pairwise import cosine_similarity\n\ndef search_similar_places(client, query):\n    model = SentenceTransformer('all-MiniLM-L6-v2')\n    embedded_query = model.encode(query)\n\n    results = retrieve_similar_places(client, embedded_query)\n\n    return results\n```\n\n#### \n    ,     .      .\n\n## \n\n          .     ChromaDB       .   [  ](09_____travel_review_processing_.md)    .         .\n\nRelevant Code Snippets (Code itself remains unchanged):\nNo specific code snippets provided for this abstraction.\n\nInstructions for the chapter (Generate content in Korean unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 9:    (Travel Review Processing)`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).\n\n- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).\n\n- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).\n\n- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).\n\n- Heavily use analogies and examples throughout (in Korean) to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 9:    (Travel Review Processing)\n\n  [  ](08_____similarity_based_retrieval_.md)          .                .\n\n##    \n\n     .  TripAdvisor     .      , API    , OpenAI       .\n\n##  \n\n### 1. TripAdvisor API   \n\nTripAdvisor API       .       .\n\n```python\n#   \ndef fetch_reviews():\n    api_url = \"https://api.tripadvisor.com/reviews\"\n    response = requests.get(api_url, headers={\"Authorization\": \"Bearer YOUR_API_KEY\"})\n    return response.json()\n```\n\n#### \n  TripAdvisor API   , JSON    . `YOUR_API_KEY` ,     .\n\n### 2. OpenAI   \n\n      OpenAI     .\n\n```python\n#  \ndef summarize_reviews(reviews):\n    summary = openai.Completion.create(\n        engine=\"text-davinci-002\",\n        prompt=f\": {reviews[:3000]}\",\n        max_tokens=150\n    )\n    return summary.choices[0].text.strip()\n```\n\n#### \n  OpenAI API     3000  . `max_tokens`     .\n\n##   \n\n           :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant API\n    participant \n    participant OpenAI\n    participant \n\n     ->> API: TripAdvisor \n    API ->> :  \n     ->> OpenAI:   \n    OpenAI ->> :  \n```\n\n###   \n\n          .\n\n```python\n# reviews_processing.py\ndef process_reviews():\n    reviews = fetch_reviews()\n    summarized_reviews = summarize_reviews(reviews)\n    return summarized_reviews\n```\n\n#### \n`process_reviews`   ,      .       .\n\n## \n\n  TripAdvisor API OpenAI        .         .   [OpenAI ](10_openai___openai_integration_.md)       .    OpenAI API     .",
    "\nIMPORTANT: Write this ENTIRE tutorial chapter in **Korean**. Some input context (like concept name, description, chapter list, previous summary) might already be in Korean, but you MUST translate ALL other generated content including explanations, examples, technical terms, and potentially code comments into Korean. DO NOT use English anywhere except in code syntax, required proper nouns, or when specified. The entire output MUST be in Korean.\n\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `develop` about the concept: \"OpenAI  (OpenAI Integration)\". This is Chapter 10.\n\nConcept Details (Note: Provided in Korean):\n- Name: OpenAI  (OpenAI Integration)\n- Description:\nOpenAI API  GPT-3.5-Turbo       .\n\nComplete Tutorial Structure (Note: Chapter names might be in Korean):\n1. [Django  (Django Framework)](01_django___django_framework_.md)\n2. [   HTML  (User Interface and HTML Rendering)](02____html___user_interface_and_html_rendering_.md)\n3. [  (Chatbot System)](03____chatbot_system_.md)\n4. [    (Environment Configuration and Secret Key Management)](04______environment_configuration_and_secret_key_management_.md)\n5. [  (Data Preprocessing)](05____data_preprocessing_.md)\n6. [ChromaDB     (ChromaDB Connection and Data Storage)](06_chromadb______chromadb_connection_and_data_storage_.md)\n7. [     (Data Embedding and Model Preparation)](07_______data_embedding_and_model_preparation_.md)\n8. [   (Similarity-based Retrieval)](08_____similarity_based_retrieval_.md)\n9. [   (Travel Review Processing)](09_____travel_review_processing_.md)\n10. [OpenAI  (OpenAI Integration)](10_openai___openai_integration_.md)\n\nContext from previous chapters (Note: This summary might be in Korean):\n# Chapter 1: Django  (Django Framework)\n\n##   \n\n              .  ,         .  , ,          .           .\n\nDjango       .    ,  ,             .\n\n## Django  \n\n   Django     .  Django    :\n\n### 1. MTV \nDjango **MTV (Model, Template, View)**  .\n- **Model ()**:       .\n- **Template ()**:     .\n- **View ()**:        .\n\n### 2. URL \nDjango URL       .    URL   , Django     .\n\n### 3.  \nDjango ORM(Object-Relational Mapping)    .      .\n\n## Django   \n\nDjango    ,  \"Hello, World!\"   .\n\n###  \n\n, Django  ,  .\n\n```bash\ndjango-admin startproject myproject\ncd myproject\npython manage.py startapp myapp\n```\n\n, URL  .\n\n**urls.py**  :\n```python\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('', views.hello_world, name='hello_world'),\n]\n```\n\n**views.py**  :\n```python\nfrom django.http import HttpResponse\n\ndef hello_world(request):\n    return HttpResponse(\"Hello, World!\")\n```\n\n#### \n    Django   .   URL  ,  URL  **hello_world**   . , `hello_world()`   \"Hello, World!\"  .\n\n##   \n\nDjango         .  URL     :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    \n     ->> : HTTP  (URL)\n     ->> Django: URL    \n    Django ->> :   \n     ->> : HTTP  ( )\n```\n\n###    \n\nDjango  **settings.py**  , **urls.py**  . `manage.py`    ,   .\n\n**settings.py**     :\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    ...\n    'myapp',  #    \n]\n```\n\n  Django     .\n\n## \n\n  Django      . Django         .   [   HTML ](02____html___user_interface_and_html_rendering_.md)  .\n---\n# Chapter 2:    HTML  (User Interface and HTML Rendering)\n\n  [Django ](01_django___django_framework_.md)  .       \"   HTML \"  .\n\n##    \n\n        UI ( ).  ,    ,          UI      .    HTML  ,      . \n\nHTML           .         .\n\n##  \n\n### 1.  \n\nDjango HTML      .    ,         .\n\n```html\n<!-- : templates/hello.html -->\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n    <h1>, {{ username }}!</h1>\n</body>\n</html>\n```\n\n#### \n `{{ username }}`   `views.py`   `username`  . \n\n### 2.   \n\n           .\n\n```python\n# views.py\nfrom django.shortcuts import render\n\ndef greet_user(request):\n    user_name = \"\"  #   \n    return render(request, 'hello.html', {'username': user_name})\n```\n\n#### \n  `render()`   `hello.html`    .     `{{ username }}` \"\" .\n\n##   \n\n Django    .       :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    participant HTML\n\n     ->> : HTTP \n     ->> Django:  \n    Django ->> :    \n     ->> HTML: HTML   \n    HTML ->> : HTTP  ( )\n```\n\n###    \n\nDjango          HTML .\n\n**settings.py**   :\n```python\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [os.path.join(BASE_DIR, 'templates')],  #     \n        ...\n    },\n]\n```\n\n  Django      . `BASE_DIR`    .\n\n## \n\n  HTML      Django      HTML  .   [ ](03____chatbot_system_.md)        .\n---\n# Chapter 3:   (Chatbot System)\n\n  [   HTML ](02____html___user_interface_and_html_rendering_.md)  .       ** **        .\n\n##    \n\n       .  ,       .        ,        .\n\n        .\n\n##  \n\n### 1.   \n\n      .       .\n\n```python\n# views.py\ndef get_user_input(request):\n    user_input = request.POST.get('message')\n    return user_input\n```\n\n#### \n  `request.POST.get('message')`    .\n\n### 2.    \n\n        .\n\n```python\n# examples.py\ndef recommend_place(user_input):\n    #    \n    if \"\" in user_input:\n        return \"\"\n    elif \"\" in user_input:\n        return \"\"\n    else:\n        return \"\"\n```\n\n#### \n   \"\"   , \"\"   .     .\n\n##   \n\n     . \n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant Django\n    participant \n    participant \n\n     ->> : ' '\n     ->> Django:  \n    Django ->> :  \n     ->> :  \n     ->> : ''\n```\n\n###   \n\n      .\n\n```python\n# views.py\nfrom django.shortcuts import render\nfrom .examples import recommend_place\n\ndef chat_response(request):\n    user_input = request.POST.get('message')\n    place = recommend_place(user_input)\n    return render(request, 'chat.html', {'response': place})\n```\n\n#### \n `chat_response`    , `recommend_place`       .\n\n**settings.py POST   **\n```python\nMIDDLEWARE = [\n    ...\n    'django.middleware.csrf.CsrfViewMiddleware',  # CSRF  \n    ...\n]\n```\n\n   POST     .\n\n## \n\n           .           .   [   ](04______environment_configuration_and_secret_key_management_.md)       .\n---\n# Chapter 4:     (Environment Configuration and Secret Key Management)\n\n  [ ](03____chatbot_system_.md)   .          .        .\n\n##    \n\n   ,    API       .  ,  API   API  .    3    .           .\n\n##  \n\n### 1.   \n\n       ,       .         .\n\n```python\n# settings.py\nimport os\n\nDATABASE_URL = os.getenv('DATABASE_URL')\nSECRET_KEY = os.getenv('SECRET_KEY')\n```\n\n#### \n `os.getenv()`      . `DATABASE_URL` `SECRET_KEY`      .\n\n### 2. `.env`   \n\n    `.env`    .     ,     .\n\n```\n# .env \nDATABASE_URL=your_database_url_here\nSECRET_KEY=your_secret_key_here\n```\n\n#### \n`.env`      ,      .\n\n### 3. Python  \n\n`python-dotenv`   `.env`      .\n\n```bash\npip install python-dotenv\n```\n\n```python\n# manage.py  wsgi.py\nfrom dotenv import load_dotenv\nload_dotenv()\n```\n\n#### \n`load_dotenv()`   `.env`  ,      .\n\n##   \n\n           :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant dotenv\n    participant \n    participant \n\n     ->> :   \n     ->> dotenv: `.env`  \n    dotenv ->> :   \n     ->> :   \n```\n\n###   \n\n      `.env`       .\n\n```python\n# views.py\nimport os\n\ndef get_secret_key():\n    secret_key = os.getenv('SECRET_KEY')\n    if not secret_key:\n        raise ValueError(\"SECRET_KEY  .\")\n    return secret_key\n```\n\n#### \n  `os.getenv()`     `SECRET_KEY` .       .\n\n**settings.py    **\n```python\nDEBUG = os.getenv('DEBUG', 'False') == 'True'  #   \n```\n\n     ,          .\n\n## \n\n      ,         .               .\n\n  [ ](05____data_preprocessing_.md)  .        .\n---\n# Chapter 5:   (Data Preprocessing)\n\n  [   ](04______environment_configuration_and_secret_key_management_.md)  .            .\n\n##    \n\n           .  ,       .       .                .\n\n##  \n\n### 1.  \n\n      .  ,      .\n\n```python\n#  \nimport pandas as pd\n\ndata = {'': ['', None, ''], '': [23, None, 30]}\ndf = pd.DataFrame(data)\ndf = df.dropna()  #    \n```\n\n#### \n      . `dropna()`      .\n\n### 2.  \n\n     ,    . \n\n```python\n#   \nimport numpy as np\n\nages = [23, 25, 22, 400, 21]\nages = [age if age < 120 else np.median(ages) for age in ages]  # 400  \n```\n\n#### \n  400    .\n\n### 3.  \n\n       .       .\n\n```python\n#  \nfrom sklearn.preprocessing import MinMaxScaler\n\nscaler = MinMaxScaler()\nnormalized_data = scaler.fit_transform([[25], [30], [45]])\n```\n\n#### \n 0 1   .         .\n\n##   \n\n         :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant \n    participant \n    participant \n\n     ->> : / \n     ->> :   \n     ->> :  \n     ->> :    \n```\n\n###   \n\n       .\n\n```python\n# data_preprocessing.py\nimport pandas as pd\nfrom sklearn.preprocessing import MinMaxScaler\n\ndef preprocess_data(data):\n    df = pd.DataFrame(data)\n    df = df.dropna()  #  \n    ages = df['age'].tolist()\n    median_age = np.median(ages)\n    df['age'] = [age if age < 120 else median_age for age in ages]  #  \n\n    scaler = MinMaxScaler()\n    df[['age_normalized']] = scaler.fit_transform(df[['age']])\n    return df\n```\n\n#### \n`preprocess_data`     ,  ,  .\n\n## \n\n        .        ,        .\n\n  [ChromaDB    ](06_chromadb______chromadb_connection_and_data_storage_.md)   .          .\n---\n# Chapter 6: ChromaDB     (ChromaDB Connection and Data Storage)\n\n  [ ](05____data_preprocessing_.md)  .          **ChromaDB**   . ChromaDB   ,       .\n\n##    \n\n        .  ,       .          . ChromaDB   ,      .\n\n##  \n\n### 1. ChromaDB \n\nChromaDB      .      .\n\n```python\n# chromadb_setting.py\nfrom chromadb import Client\n\nclient = Client('your_chromadb_connection_string')\n```\n\n#### \n `Client`   ChromaDB  .       .\n\n### 2.  \n\n       ,    .\n\n```python\n#   \ndef store_in_chromadb(client, data):\n    table = client.create_table('reviews')\n    table.insert(data)\n```\n\n#### \n`create_table()`   , `insert()`   .      .\n\n### 3.  \n\n     .           .\n\n```python\n#   \ndef search_data(client, query):\n    table = client.table('reviews')\n    results = table.search(query)\n    return results\n```\n\n#### \n`search()`         .       .\n\n##   \n\nChromaDB      :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant ChromaDB\n    participant \n    participant \n\n     ->> :  \n     ->> ChromaDB:   \n    ChromaDB ->> :  \n     ->> :  \n     ->> :  \n     ->> :   \n```\n\n###   \n\nChromaDB         :\n\n```python\n# chromadb_connection.py\nfrom chromadb import Client\n\ndef connect_to_chromadb():\n    client = Client('your_chromadb_connection_string')\n    return client\n```\n\n#### \n      .          .\n\n## \n\n  ChromaDB       . ChromaDB       . \n\n  [    ](07_______data_embedding_and_model_preparation_.md)   .         .\n---\n# Chapter 7:      (Data Embedding and Model Preparation)\n\n  [ChromaDB    ](06_chromadb______chromadb_connection_and_data_storage_.md)  .           '    '  .          .\n\n##    \n\n          .  ,      users   .   SentenceTransformer      .           .\n\n##  \n\n### 1. SentenceTransformer   \n\n       .         . \n\n```python\n#  \nfrom sentence_transformers import SentenceTransformer\n\nmodel = SentenceTransformer('all-MiniLM-L6-v2')\nembeddings = model.encode([\"  .\"])\n\nprint(embeddings)\n```\n\n#### \n  SentenceTransformer  , \"  .\"   .    ,   .\n\n### 2.     \n\n    ,    .          .\n\n```python\n#    \ndef prepare_model(embeddings):\n    #    \n    print(\"  .\")\n    return True\n```\n\n#### \n         \"  .\" . \n\n##   \n\nSentenceTransformer        :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant \n    participant \n    participant \n\n     ->> :  \n     ->> :  \n     ->> :  \n     ->> :  \n```\n\n###   \n\n SentenceTransformer       :\n\n```python\n# internal_embedding.py\ndef internal_embedding_process(sentence):\n    #    \n    print(f\"'{sentence}'()  .\")\n    return [0.5] * 384  #    \n```\n\n#### \n     .       .\n\n## \n\n           . SentenceTransformer       .   [  ](08_____similarity_based_retrieval_.md)   .         .\n---\n# Chapter 8:    (Similarity-based Retrieval)\n\n  [    ](07_______data_embedding_and_model_preparation_.md)  .             **  **  .        .\n\n##    \n\n          .              .    ,     .\n\n##  \n\n### 1.   \n\n      .          .\n\n```python\n#   \nfrom sklearn.metrics.pairwise import cosine_similarity\n\ndef calculate_similarity(vector1, vector2):\n    similarity = cosine_similarity([vector1], [vector2])\n    return similarity[0][0]\n```\n\n#### \n          .  1      .\n\n### 2.    \n\nChromaDB      .        .\n\n```python\n#    \ndef retrieve_similar_places(client, embedded_query):\n    table = client.table('places')\n    results = table.find_nearest(embedded_query, top_k=5)\n    return results\n```\n\n#### \n`find_nearest`        5  .        .\n\n##   \n\n          .\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant \n    participant \n    participant \n\n     ->> :  \n     ->> :  \n     ->> :  \n     ->> :   \n```\n\n###   \n\n         .\n\n```python\n# search.py\nfrom sentence_transformers import SentenceTransformer\nfrom sklearn.metrics.pairwise import cosine_similarity\n\ndef search_similar_places(client, query):\n    model = SentenceTransformer('all-MiniLM-L6-v2')\n    embedded_query = model.encode(query)\n\n    results = retrieve_similar_places(client, embedded_query)\n\n    return results\n```\n\n#### \n    ,     .      .\n\n## \n\n          .     ChromaDB       .   [  ](09_____travel_review_processing_.md)    .         .\n---\n# Chapter 9:    (Travel Review Processing)\n\n  [  ](08_____similarity_based_retrieval_.md)          .                .\n\n##    \n\n     .  TripAdvisor     .      , API    , OpenAI       .\n\n##  \n\n### 1. TripAdvisor API   \n\nTripAdvisor API       .       .\n\n```python\n#   \ndef fetch_reviews():\n    api_url = \"https://api.tripadvisor.com/reviews\"\n    response = requests.get(api_url, headers={\"Authorization\": \"Bearer YOUR_API_KEY\"})\n    return response.json()\n```\n\n#### \n  TripAdvisor API   , JSON    . `YOUR_API_KEY` ,     .\n\n### 2. OpenAI   \n\n      OpenAI     .\n\n```python\n#  \ndef summarize_reviews(reviews):\n    summary = openai.Completion.create(\n        engine=\"text-davinci-002\",\n        prompt=f\": {reviews[:3000]}\",\n        max_tokens=150\n    )\n    return summary.choices[0].text.strip()\n```\n\n#### \n  OpenAI API     3000  . `max_tokens`     .\n\n##   \n\n           :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant API\n    participant \n    participant OpenAI\n    participant \n\n     ->> API: TripAdvisor \n    API ->> :  \n     ->> OpenAI:   \n    OpenAI ->> :  \n```\n\n###   \n\n          .\n\n```python\n# reviews_processing.py\ndef process_reviews():\n    reviews = fetch_reviews()\n    summarized_reviews = summarize_reviews(reviews)\n    return summarized_reviews\n```\n\n#### \n`process_reviews`   ,      .       .\n\n## \n\n  TripAdvisor API OpenAI        .         .   [OpenAI ](10_openai___openai_integration_.md)       .    OpenAI API     .\n\nRelevant Code Snippets (Code itself remains unchanged):\nNo specific code snippets provided for this abstraction.\n\nInstructions for the chapter (Generate content in Korean unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 10: OpenAI  (OpenAI Integration)`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter (in Korean), referencing it with a proper Markdown link using its name (Use the Korean chapter title from the structure above).\n\n- Begin with a high-level motivation explaining what problem this abstraction solves (in Korean). Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way (in Korean).\n\n- Explain how to use this abstraction to solve the use case (in Korean). Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen (in Korean)).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments (Translate to Korean if possible, otherwise keep minimal English for clarity) to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it (in Korean).\n\n- Describe the internal implementation to help understand what's under the hood (in Korean). First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called (in Korean). It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`.  (Use Korean for labels/text if appropriate).\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain (in Korean).\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title (Use the Korean chapter title from the structure above). Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format).  (Use Korean for labels/text if appropriate).\n\n- Heavily use analogies and examples throughout (in Korean) to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned (in Korean) and provides a transition to the next chapter (in Korean). If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename) (Use the Korean chapter title from the structure above).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand (appropriate for Korean readers).\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 10: OpenAI  (OpenAI Integration)\n\n  [  ](09_____travel_review_processing_.md)  .  OpenAI API     GPT-3.5-Turbo     .\n\n##    \n\nOpenAI API      .   ,            .  ,  \"  ?\"   , AI             .\n\n##  \n\n### 1. OpenAI API  \n\nOpenAI API   API  .       .\n\n```python\n# OpenAI API  \nimport openai\n\nopenai.api_key = \"YOUR_OPENAI_API_KEY\"\n```\n\n#### \nAPI   OpenAI    .    .\n\n### 2.    \n\n  , OpenAI    .\n\n```python\n#    \ndef get_openai_response(question):\n    response = openai.Completion.create(\n        model=\"gpt-3.5-turbo\",\n        prompt=question,\n        max_tokens=100\n    )\n    return response.choices[0].text.strip()\n```\n\n#### \n  OpenAI API   . `prompt`  , `max_tokens`    .\n\n##   \n\nOpenAI    ?    :\n\n```mermaid\nsequenceDiagram\n    participant \n    participant \n    participant OpenAI\n    participant \n    participant \n\n     ->> :  \n     ->> OpenAI:  \n    OpenAI ->> :  \n     ->> :  \n     ->> :  \n```\n\n###   \n\nOpenAI API        .\n\n```python\n# openai_integration.py\nimport openai\n\ndef connect_and_respond(question):\n    openai.api_key = \"YOUR_OPENAI_API_KEY\"  #  API \n    response = openai.Completion.create(\n        engine=\"gpt-3.5-turbo\",\n        prompt=question,\n        max_tokens=150\n    )\n    return response.choices[0].text.strip()\n```\n\n#### \n`connect_and_respond`  OpenAI API ,     .     AI     .\n\n## \n\n  OpenAI API      AI    .         .   [    ](11_______data_visualization_and_results_analysis_.md) .            ."
}